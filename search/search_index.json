{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Solana.py \ud83d\udc0d The Solana Python SDK \ud83d\udc0d Solana.py is the base Python library for interacting with Solana. You can use it to build transactions and interact with the Solana JSON RPC API , much like you would do with solana-web3.js It also covers the SPL Token Program . Latest Documentation . \u2693\ufe0e See also: AnchorPy , a Python client for Anchor -based programs on Solana. \u2693\ufe0e \u26a1 Quickstart Installation pip install solana General Usage Note: check out the Solana Cookbook for more detailed examples! import solana API Client from solana.rpc.api import Client http_client = Client ( \"https://api.devnet.solana.com\" ) Async API Client import asyncio from solana.rpc.async_api import AsyncClient async def main (): async with AsyncClient ( \"https://api.devnet.solana.com\" ) as client : res = await client . is_connected () print ( res ) # True # Alternatively, close the client explicitly instead of using a context manager: client = AsyncClient ( \"https://api.devnet.solana.com\" ) res = await client . is_connected () print ( res ) # True await client . close () asyncio . run ( main ()) Websockets Client import asyncio from asyncstdlib import enumerate from solana.rpc.websocket_api import connect async def main (): async with connect ( \"wss://api.devnet.solana.com\" ) as websocket : await websocket . logs_subscribe () first_resp = await websocket . recv () subscription_id = first_resp . result next_resp = await websocket . recv () print ( next_resp ) await websocket . logs_unsubscribe ( subscription_id ) # Alternatively, use the client as an infinite asynchronous iterator: async with connect ( \"wss://api.devnet.solana.com\" ) as websocket : await websocket . logs_subscribe () first_resp = await websocket . recv () subscription_id = first_resp . result async for idx , msg in enumerate ( websocket ): if idx == 3 : break print ( msg ) await websocket . logs_unsubscribe ( subscription_id ) asyncio . run ( main ()) \ud83d\udd28 Development Setup Install poetry Install dev dependencies: poetry install Activate the poetry shell. poetry shell Lint make lint Tests # All tests make tests # Unit tests only make unit-tests # Integration tests only make int-tests","title":"Home"},{"location":"#solanapy","text":"\ud83d\udc0d The Solana Python SDK \ud83d\udc0d Solana.py is the base Python library for interacting with Solana. You can use it to build transactions and interact with the Solana JSON RPC API , much like you would do with solana-web3.js It also covers the SPL Token Program . Latest Documentation . \u2693\ufe0e See also: AnchorPy , a Python client for Anchor -based programs on Solana. \u2693\ufe0e","title":"Solana.py"},{"location":"#quickstart","text":"","title":"\u26a1 Quickstart"},{"location":"#installation","text":"pip install solana","title":"Installation"},{"location":"#general-usage","text":"Note: check out the Solana Cookbook for more detailed examples! import solana","title":"General Usage"},{"location":"#api-client","text":"from solana.rpc.api import Client http_client = Client ( \"https://api.devnet.solana.com\" )","title":"API Client"},{"location":"#async-api-client","text":"import asyncio from solana.rpc.async_api import AsyncClient async def main (): async with AsyncClient ( \"https://api.devnet.solana.com\" ) as client : res = await client . is_connected () print ( res ) # True # Alternatively, close the client explicitly instead of using a context manager: client = AsyncClient ( \"https://api.devnet.solana.com\" ) res = await client . is_connected () print ( res ) # True await client . close () asyncio . run ( main ())","title":"Async API Client"},{"location":"#websockets-client","text":"import asyncio from asyncstdlib import enumerate from solana.rpc.websocket_api import connect async def main (): async with connect ( \"wss://api.devnet.solana.com\" ) as websocket : await websocket . logs_subscribe () first_resp = await websocket . recv () subscription_id = first_resp . result next_resp = await websocket . recv () print ( next_resp ) await websocket . logs_unsubscribe ( subscription_id ) # Alternatively, use the client as an infinite asynchronous iterator: async with connect ( \"wss://api.devnet.solana.com\" ) as websocket : await websocket . logs_subscribe () first_resp = await websocket . recv () subscription_id = first_resp . result async for idx , msg in enumerate ( websocket ): if idx == 3 : break print ( msg ) await websocket . logs_unsubscribe ( subscription_id ) asyncio . run ( main ())","title":"Websockets Client"},{"location":"#development","text":"","title":"\ud83d\udd28 Development"},{"location":"#setup","text":"Install poetry Install dev dependencies: poetry install Activate the poetry shell. poetry shell","title":"Setup"},{"location":"#lint","text":"make lint","title":"Lint"},{"location":"#tests","text":"# All tests make tests # Unit tests only make unit-tests # Integration tests only make int-tests","title":"Tests"},{"location":"core/blockhash/","text":"Blockhash solana.blockhash Blockhash. Examples: >>> # An arbitrary base58 encoded blockhash: >>> Blockhash ( \"EETubP5AKHgjPAhzPAFcb8BAY1hMH639CWCFTqi3hq1k\" ) 'EETubP5AKHgjPAhzPAFcb8BAY1hMH639CWCFTqi3hq1k' Blockhash Type for blockhash. BlockhashCache A recent blockhash cache that expires after a given number of seconds. Parameters: Name Type Description Default ttl int Seconds until cached blockhash expires. 60 Source code in solana/blockhash.py class BlockhashCache : \"\"\"A recent blockhash cache that expires after a given number of seconds. Args: ttl: Seconds until cached blockhash expires. \"\"\" def __init__ ( self , ttl : int = 60 ) -> None : \"\"\"Instantiate the cache (you only need to do this once).\"\"\" maxsize = 300 self . unused_blockhashes : TTLCache = TTLCache ( maxsize = maxsize , ttl = ttl ) self . used_blockhashes : TTLCache = TTLCache ( maxsize = maxsize , ttl = ttl ) def set ( self , blockhash : Blockhash , slot : int , used_immediately : bool = False ) -> None : \"\"\"Update the cache. Args: blockhash: new Blockhash value. slot: the slot which the blockhash came from. used_immediately: whether the client used the blockhash immediately after fetching it. \"\"\" if used_immediately : if slot not in self . used_blockhashes : self . used_blockhashes [ slot ] = blockhash return if slot in self . used_blockhashes or slot in self . unused_blockhashes : return self . unused_blockhashes [ slot ] = blockhash def get ( self ) -> Blockhash : \"\"\"Get the cached Blockhash. Raises KeyError if cache has expired. Returns: cached Blockhash. \"\"\" try : slot , blockhash = self . unused_blockhashes . popitem () self . used_blockhashes [ slot ] = blockhash except KeyError : with self . used_blockhashes . timer : # type: ignore blockhash = self . used_blockhashes [ min ( self . used_blockhashes )] # raises ValueError if used_blockhashes is empty return blockhash __init__ ( self , ttl = 60 ) special Instantiate the cache (you only need to do this once). Source code in solana/blockhash.py def __init__ ( self , ttl : int = 60 ) -> None : \"\"\"Instantiate the cache (you only need to do this once).\"\"\" maxsize = 300 self . unused_blockhashes : TTLCache = TTLCache ( maxsize = maxsize , ttl = ttl ) self . used_blockhashes : TTLCache = TTLCache ( maxsize = maxsize , ttl = ttl ) get ( self ) Get the cached Blockhash. Raises KeyError if cache has expired. Returns: Type Description <function NewType.<locals>.new_type at 0x7f7a958658b0> cached Blockhash. Source code in solana/blockhash.py def get ( self ) -> Blockhash : \"\"\"Get the cached Blockhash. Raises KeyError if cache has expired. Returns: cached Blockhash. \"\"\" try : slot , blockhash = self . unused_blockhashes . popitem () self . used_blockhashes [ slot ] = blockhash except KeyError : with self . used_blockhashes . timer : # type: ignore blockhash = self . used_blockhashes [ min ( self . used_blockhashes )] # raises ValueError if used_blockhashes is empty return blockhash set ( self , blockhash , slot , used_immediately = False ) Update the cache. Parameters: Name Type Description Default blockhash <function NewType.<locals>.new_type at 0x7f7a958658b0> new Blockhash value. required slot int the slot which the blockhash came from. required used_immediately bool whether the client used the blockhash immediately after fetching it. False Source code in solana/blockhash.py def set ( self , blockhash : Blockhash , slot : int , used_immediately : bool = False ) -> None : \"\"\"Update the cache. Args: blockhash: new Blockhash value. slot: the slot which the blockhash came from. used_immediately: whether the client used the blockhash immediately after fetching it. \"\"\" if used_immediately : if slot not in self . used_blockhashes : self . used_blockhashes [ slot ] = blockhash return if slot in self . used_blockhashes or slot in self . unused_blockhashes : return self . unused_blockhashes [ slot ] = blockhash","title":"Blockhash"},{"location":"core/blockhash/#blockhash","text":"","title":"Blockhash"},{"location":"core/blockhash/#solana.blockhash","text":"Blockhash. Examples: >>> # An arbitrary base58 encoded blockhash: >>> Blockhash ( \"EETubP5AKHgjPAhzPAFcb8BAY1hMH639CWCFTqi3hq1k\" ) 'EETubP5AKHgjPAhzPAFcb8BAY1hMH639CWCFTqi3hq1k'","title":"blockhash"},{"location":"core/blockhash/#solana.blockhash.Blockhash","text":"Type for blockhash.","title":"Blockhash"},{"location":"core/blockhash/#solana.blockhash.BlockhashCache","text":"A recent blockhash cache that expires after a given number of seconds. Parameters: Name Type Description Default ttl int Seconds until cached blockhash expires. 60 Source code in solana/blockhash.py class BlockhashCache : \"\"\"A recent blockhash cache that expires after a given number of seconds. Args: ttl: Seconds until cached blockhash expires. \"\"\" def __init__ ( self , ttl : int = 60 ) -> None : \"\"\"Instantiate the cache (you only need to do this once).\"\"\" maxsize = 300 self . unused_blockhashes : TTLCache = TTLCache ( maxsize = maxsize , ttl = ttl ) self . used_blockhashes : TTLCache = TTLCache ( maxsize = maxsize , ttl = ttl ) def set ( self , blockhash : Blockhash , slot : int , used_immediately : bool = False ) -> None : \"\"\"Update the cache. Args: blockhash: new Blockhash value. slot: the slot which the blockhash came from. used_immediately: whether the client used the blockhash immediately after fetching it. \"\"\" if used_immediately : if slot not in self . used_blockhashes : self . used_blockhashes [ slot ] = blockhash return if slot in self . used_blockhashes or slot in self . unused_blockhashes : return self . unused_blockhashes [ slot ] = blockhash def get ( self ) -> Blockhash : \"\"\"Get the cached Blockhash. Raises KeyError if cache has expired. Returns: cached Blockhash. \"\"\" try : slot , blockhash = self . unused_blockhashes . popitem () self . used_blockhashes [ slot ] = blockhash except KeyError : with self . used_blockhashes . timer : # type: ignore blockhash = self . used_blockhashes [ min ( self . used_blockhashes )] # raises ValueError if used_blockhashes is empty return blockhash","title":"BlockhashCache"},{"location":"core/blockhash/#solana.blockhash.BlockhashCache.__init__","text":"Instantiate the cache (you only need to do this once). Source code in solana/blockhash.py def __init__ ( self , ttl : int = 60 ) -> None : \"\"\"Instantiate the cache (you only need to do this once).\"\"\" maxsize = 300 self . unused_blockhashes : TTLCache = TTLCache ( maxsize = maxsize , ttl = ttl ) self . used_blockhashes : TTLCache = TTLCache ( maxsize = maxsize , ttl = ttl )","title":"__init__()"},{"location":"core/blockhash/#solana.blockhash.BlockhashCache.get","text":"Get the cached Blockhash. Raises KeyError if cache has expired. Returns: Type Description <function NewType.<locals>.new_type at 0x7f7a958658b0> cached Blockhash. Source code in solana/blockhash.py def get ( self ) -> Blockhash : \"\"\"Get the cached Blockhash. Raises KeyError if cache has expired. Returns: cached Blockhash. \"\"\" try : slot , blockhash = self . unused_blockhashes . popitem () self . used_blockhashes [ slot ] = blockhash except KeyError : with self . used_blockhashes . timer : # type: ignore blockhash = self . used_blockhashes [ min ( self . used_blockhashes )] # raises ValueError if used_blockhashes is empty return blockhash","title":"get()"},{"location":"core/blockhash/#solana.blockhash.BlockhashCache.set","text":"Update the cache. Parameters: Name Type Description Default blockhash <function NewType.<locals>.new_type at 0x7f7a958658b0> new Blockhash value. required slot int the slot which the blockhash came from. required used_immediately bool whether the client used the blockhash immediately after fetching it. False Source code in solana/blockhash.py def set ( self , blockhash : Blockhash , slot : int , used_immediately : bool = False ) -> None : \"\"\"Update the cache. Args: blockhash: new Blockhash value. slot: the slot which the blockhash came from. used_immediately: whether the client used the blockhash immediately after fetching it. \"\"\" if used_immediately : if slot not in self . used_blockhashes : self . used_blockhashes [ slot ] = blockhash return if slot in self . used_blockhashes or slot in self . unused_blockhashes : return self . unused_blockhashes [ slot ] = blockhash","title":"set()"},{"location":"core/keypair/","text":"Keypair solana.keypair Keypair module to manage public-private key pair. Keypair An account keypair used for signing transactions. Parameters: Name Type Description Default keypair Optional[solders.keypair.Keypair] a solders.keypair.Keypair instance. Optional, defaults to None. None Examples: >>> # Init with random keypair: >>> keypair = Keypair () >>> # Init with existing keypair: >>> underlying = solders . keypair . Keypair () >>> keypair = Keypair ( underlying ) Source code in solana/keypair.py class Keypair : \"\"\"An account keypair used for signing transactions. Args: keypair: a `solders.keypair.Keypair` instance. Optional, defaults to None. Example: >>> # Init with random keypair: >>> keypair = Keypair() >>> # Init with existing keypair: >>> underlying = solders.keypair.Keypair() >>> keypair = Keypair(underlying) \"\"\" def __init__ ( self , keypair : Optional [ solders . keypair . Keypair ] = None ) -> None : \"\"\"Create a new keypair instance. Generate random keypair if no keypair is provided. Initialize class variables. \"\"\" if keypair is None : # the PrivateKey object comes with a public key too self . _solders = solders . keypair . Keypair () else : self . _solders = keypair @classmethod def from_solders ( cls , keypair : solders . keypair . Keypair ) -> Keypair : \"\"\"Convert from the corresponding `solders` type. Args: keypair: A `solders` keypair. Returns: A `solana-py` keypair. \"\"\" return cls ( keypair ) def to_solders ( self ) -> solders . keypair . Keypair : \"\"\"Convert to the corresponding `solders` type. Returns: A `solders` keypair. \"\"\" return self . _solders @classmethod def generate ( cls ) -> Keypair : \"\"\"Generate a new random keypair. This method exists to provide familiarity for web3.js users. There isn't much reason to use it instead of just instantiating `Keypair()`. Returns: The generated keypair. \"\"\" return cls () @classmethod def from_secret_key ( cls , secret_key : bytes ) -> Keypair : \"\"\"Create a keypair from the 64-byte secret key. This method should only be used to recreate a keypair from a previously generated secret key. Generating keypairs from a random seed should be done with the `.from_seed` method. Args: secret_key: secret key in bytes. Returns: The generated keypair. \"\"\" seed = secret_key [: 32 ] return cls . from_seed ( seed ) @classmethod def from_seed ( cls , seed : bytes ) -> Keypair : \"\"\"Generate a keypair from a 32 byte seed. Args: seed: 32-byte seed. Returns: The generated keypair. \"\"\" return cls ( solders . keypair . Keypair . from_seed ( seed )) def sign ( self , msg : bytes ) -> Signature : \"\"\"Sign a message with this keypair. Args: msg: message to sign. Returns: A signed messeged object. Example: >>> seed = bytes([1] * 32) >>> keypair = Keypair.from_seed(seed) >>> msg = b\"hello\" >>> signature = keypair.sign(msg) >>> bytes(signature).hex() 'e1430c6ebd0d53573b5c803452174f8991ef5955e0906a09e8fdc7310459e9c82a402526748c3431fe7f0e5faafbf7e703234789734063ee42be17af16438d08' \"\"\" # pylint: disable=line-too-long return self . _solders . sign_message ( msg ) @property def seed ( self ) -> bytes : \"\"\"The 32-byte secret seed.\"\"\" return bytes ( self . _solders . secret ()) @property def public_key ( self ) -> solana . publickey . PublicKey : \"\"\"The public key for this keypair.\"\"\" underlying = self . _solders . pubkey () return solana . publickey . PublicKey . from_solders ( underlying ) @property def secret_key ( self ) -> bytes : \"\"\"The raw 64-byte secret key for this keypair.\"\"\" return self . seed + bytes ( self . public_key ) def __eq__ ( self , other ) -> bool : \"\"\"Checks for equality by comparing public keys.\"\"\" if not isinstance ( other , self . __class__ ): return False return self . secret_key == other . secret_key def __ne__ ( self , other ) -> bool : \"\"\"Implemented by negating __eq__.\"\"\" return not ( self == other ) # pylint: disable=superfluous-parens def __hash__ ( self ) -> int : \"\"\"Returns a unique hash for set operations.\"\"\" return hash ( self . _solders ) public_key : solana . publickey . PublicKey property readonly The public key for this keypair. secret_key : bytes property readonly The raw 64-byte secret key for this keypair. seed : bytes property readonly The 32-byte secret seed. __init__ ( self , keypair = None ) special Create a new keypair instance. Generate random keypair if no keypair is provided. Initialize class variables. Source code in solana/keypair.py def __init__ ( self , keypair : Optional [ solders . keypair . Keypair ] = None ) -> None : \"\"\"Create a new keypair instance. Generate random keypair if no keypair is provided. Initialize class variables. \"\"\" if keypair is None : # the PrivateKey object comes with a public key too self . _solders = solders . keypair . Keypair () else : self . _solders = keypair from_secret_key ( secret_key ) classmethod Create a keypair from the 64-byte secret key. This method should only be used to recreate a keypair from a previously generated secret key. Generating keypairs from a random seed should be done with the .from_seed method. Parameters: Name Type Description Default secret_key bytes secret key in bytes. required Returns: Type Description Keypair The generated keypair. Source code in solana/keypair.py @classmethod def from_secret_key ( cls , secret_key : bytes ) -> Keypair : \"\"\"Create a keypair from the 64-byte secret key. This method should only be used to recreate a keypair from a previously generated secret key. Generating keypairs from a random seed should be done with the `.from_seed` method. Args: secret_key: secret key in bytes. Returns: The generated keypair. \"\"\" seed = secret_key [: 32 ] return cls . from_seed ( seed ) from_seed ( seed ) classmethod Generate a keypair from a 32 byte seed. Parameters: Name Type Description Default seed bytes 32-byte seed. required Returns: Type Description Keypair The generated keypair. Source code in solana/keypair.py @classmethod def from_seed ( cls , seed : bytes ) -> Keypair : \"\"\"Generate a keypair from a 32 byte seed. Args: seed: 32-byte seed. Returns: The generated keypair. \"\"\" return cls ( solders . keypair . Keypair . from_seed ( seed )) from_solders ( keypair ) classmethod Convert from the corresponding solders type. Parameters: Name Type Description Default keypair solders.keypair.Keypair A solders keypair. required Returns: Type Description Keypair A solana-py keypair. Source code in solana/keypair.py @classmethod def from_solders ( cls , keypair : solders . keypair . Keypair ) -> Keypair : \"\"\"Convert from the corresponding `solders` type. Args: keypair: A `solders` keypair. Returns: A `solana-py` keypair. \"\"\" return cls ( keypair ) generate () classmethod Generate a new random keypair. This method exists to provide familiarity for web3.js users. There isn't much reason to use it instead of just instantiating Keypair() . Returns: Type Description Keypair The generated keypair. Source code in solana/keypair.py @classmethod def generate ( cls ) -> Keypair : \"\"\"Generate a new random keypair. This method exists to provide familiarity for web3.js users. There isn't much reason to use it instead of just instantiating `Keypair()`. Returns: The generated keypair. \"\"\" return cls () sign ( self , msg ) Sign a message with this keypair. Parameters: Name Type Description Default msg bytes message to sign. required Returns: Type Description Signature A signed messeged object. Examples: >>> seed = bytes ([ 1 ] * 32 ) >>> keypair = Keypair . from_seed ( seed ) >>> msg = b \"hello\" >>> signature = keypair . sign ( msg ) >>> bytes ( signature ) . hex () 'e1430c6ebd0d53573b5c803452174f8991ef5955e0906a09e8fdc7310459e9c82a402526748c3431fe7f0e5faafbf7e703234789734063ee42be17af16438d08' Source code in solana/keypair.py def sign ( self , msg : bytes ) -> Signature : \"\"\"Sign a message with this keypair. Args: msg: message to sign. Returns: A signed messeged object. Example: >>> seed = bytes([1] * 32) >>> keypair = Keypair.from_seed(seed) >>> msg = b\"hello\" >>> signature = keypair.sign(msg) >>> bytes(signature).hex() 'e1430c6ebd0d53573b5c803452174f8991ef5955e0906a09e8fdc7310459e9c82a402526748c3431fe7f0e5faafbf7e703234789734063ee42be17af16438d08' \"\"\" # pylint: disable=line-too-long return self . _solders . sign_message ( msg ) to_solders ( self ) Convert to the corresponding solders type. Returns: Type Description solders.keypair.Keypair A solders keypair. Source code in solana/keypair.py def to_solders ( self ) -> solders . keypair . Keypair : \"\"\"Convert to the corresponding `solders` type. Returns: A `solders` keypair. \"\"\" return self . _solders","title":"Keypair"},{"location":"core/keypair/#keypair","text":"","title":"Keypair"},{"location":"core/keypair/#solana.keypair","text":"Keypair module to manage public-private key pair.","title":"keypair"},{"location":"core/keypair/#solana.keypair.Keypair","text":"An account keypair used for signing transactions. Parameters: Name Type Description Default keypair Optional[solders.keypair.Keypair] a solders.keypair.Keypair instance. Optional, defaults to None. None Examples: >>> # Init with random keypair: >>> keypair = Keypair () >>> # Init with existing keypair: >>> underlying = solders . keypair . Keypair () >>> keypair = Keypair ( underlying ) Source code in solana/keypair.py class Keypair : \"\"\"An account keypair used for signing transactions. Args: keypair: a `solders.keypair.Keypair` instance. Optional, defaults to None. Example: >>> # Init with random keypair: >>> keypair = Keypair() >>> # Init with existing keypair: >>> underlying = solders.keypair.Keypair() >>> keypair = Keypair(underlying) \"\"\" def __init__ ( self , keypair : Optional [ solders . keypair . Keypair ] = None ) -> None : \"\"\"Create a new keypair instance. Generate random keypair if no keypair is provided. Initialize class variables. \"\"\" if keypair is None : # the PrivateKey object comes with a public key too self . _solders = solders . keypair . Keypair () else : self . _solders = keypair @classmethod def from_solders ( cls , keypair : solders . keypair . Keypair ) -> Keypair : \"\"\"Convert from the corresponding `solders` type. Args: keypair: A `solders` keypair. Returns: A `solana-py` keypair. \"\"\" return cls ( keypair ) def to_solders ( self ) -> solders . keypair . Keypair : \"\"\"Convert to the corresponding `solders` type. Returns: A `solders` keypair. \"\"\" return self . _solders @classmethod def generate ( cls ) -> Keypair : \"\"\"Generate a new random keypair. This method exists to provide familiarity for web3.js users. There isn't much reason to use it instead of just instantiating `Keypair()`. Returns: The generated keypair. \"\"\" return cls () @classmethod def from_secret_key ( cls , secret_key : bytes ) -> Keypair : \"\"\"Create a keypair from the 64-byte secret key. This method should only be used to recreate a keypair from a previously generated secret key. Generating keypairs from a random seed should be done with the `.from_seed` method. Args: secret_key: secret key in bytes. Returns: The generated keypair. \"\"\" seed = secret_key [: 32 ] return cls . from_seed ( seed ) @classmethod def from_seed ( cls , seed : bytes ) -> Keypair : \"\"\"Generate a keypair from a 32 byte seed. Args: seed: 32-byte seed. Returns: The generated keypair. \"\"\" return cls ( solders . keypair . Keypair . from_seed ( seed )) def sign ( self , msg : bytes ) -> Signature : \"\"\"Sign a message with this keypair. Args: msg: message to sign. Returns: A signed messeged object. Example: >>> seed = bytes([1] * 32) >>> keypair = Keypair.from_seed(seed) >>> msg = b\"hello\" >>> signature = keypair.sign(msg) >>> bytes(signature).hex() 'e1430c6ebd0d53573b5c803452174f8991ef5955e0906a09e8fdc7310459e9c82a402526748c3431fe7f0e5faafbf7e703234789734063ee42be17af16438d08' \"\"\" # pylint: disable=line-too-long return self . _solders . sign_message ( msg ) @property def seed ( self ) -> bytes : \"\"\"The 32-byte secret seed.\"\"\" return bytes ( self . _solders . secret ()) @property def public_key ( self ) -> solana . publickey . PublicKey : \"\"\"The public key for this keypair.\"\"\" underlying = self . _solders . pubkey () return solana . publickey . PublicKey . from_solders ( underlying ) @property def secret_key ( self ) -> bytes : \"\"\"The raw 64-byte secret key for this keypair.\"\"\" return self . seed + bytes ( self . public_key ) def __eq__ ( self , other ) -> bool : \"\"\"Checks for equality by comparing public keys.\"\"\" if not isinstance ( other , self . __class__ ): return False return self . secret_key == other . secret_key def __ne__ ( self , other ) -> bool : \"\"\"Implemented by negating __eq__.\"\"\" return not ( self == other ) # pylint: disable=superfluous-parens def __hash__ ( self ) -> int : \"\"\"Returns a unique hash for set operations.\"\"\" return hash ( self . _solders )","title":"Keypair"},{"location":"core/keypair/#solana.keypair.Keypair.public_key","text":"The public key for this keypair.","title":"public_key"},{"location":"core/keypair/#solana.keypair.Keypair.secret_key","text":"The raw 64-byte secret key for this keypair.","title":"secret_key"},{"location":"core/keypair/#solana.keypair.Keypair.seed","text":"The 32-byte secret seed.","title":"seed"},{"location":"core/keypair/#solana.keypair.Keypair.__init__","text":"Create a new keypair instance. Generate random keypair if no keypair is provided. Initialize class variables. Source code in solana/keypair.py def __init__ ( self , keypair : Optional [ solders . keypair . Keypair ] = None ) -> None : \"\"\"Create a new keypair instance. Generate random keypair if no keypair is provided. Initialize class variables. \"\"\" if keypair is None : # the PrivateKey object comes with a public key too self . _solders = solders . keypair . Keypair () else : self . _solders = keypair","title":"__init__()"},{"location":"core/keypair/#solana.keypair.Keypair.from_secret_key","text":"Create a keypair from the 64-byte secret key. This method should only be used to recreate a keypair from a previously generated secret key. Generating keypairs from a random seed should be done with the .from_seed method. Parameters: Name Type Description Default secret_key bytes secret key in bytes. required Returns: Type Description Keypair The generated keypair. Source code in solana/keypair.py @classmethod def from_secret_key ( cls , secret_key : bytes ) -> Keypair : \"\"\"Create a keypair from the 64-byte secret key. This method should only be used to recreate a keypair from a previously generated secret key. Generating keypairs from a random seed should be done with the `.from_seed` method. Args: secret_key: secret key in bytes. Returns: The generated keypair. \"\"\" seed = secret_key [: 32 ] return cls . from_seed ( seed )","title":"from_secret_key()"},{"location":"core/keypair/#solana.keypair.Keypair.from_seed","text":"Generate a keypair from a 32 byte seed. Parameters: Name Type Description Default seed bytes 32-byte seed. required Returns: Type Description Keypair The generated keypair. Source code in solana/keypair.py @classmethod def from_seed ( cls , seed : bytes ) -> Keypair : \"\"\"Generate a keypair from a 32 byte seed. Args: seed: 32-byte seed. Returns: The generated keypair. \"\"\" return cls ( solders . keypair . Keypair . from_seed ( seed ))","title":"from_seed()"},{"location":"core/keypair/#solana.keypair.Keypair.from_solders","text":"Convert from the corresponding solders type. Parameters: Name Type Description Default keypair solders.keypair.Keypair A solders keypair. required Returns: Type Description Keypair A solana-py keypair. Source code in solana/keypair.py @classmethod def from_solders ( cls , keypair : solders . keypair . Keypair ) -> Keypair : \"\"\"Convert from the corresponding `solders` type. Args: keypair: A `solders` keypair. Returns: A `solana-py` keypair. \"\"\" return cls ( keypair )","title":"from_solders()"},{"location":"core/keypair/#solana.keypair.Keypair.generate","text":"Generate a new random keypair. This method exists to provide familiarity for web3.js users. There isn't much reason to use it instead of just instantiating Keypair() . Returns: Type Description Keypair The generated keypair. Source code in solana/keypair.py @classmethod def generate ( cls ) -> Keypair : \"\"\"Generate a new random keypair. This method exists to provide familiarity for web3.js users. There isn't much reason to use it instead of just instantiating `Keypair()`. Returns: The generated keypair. \"\"\" return cls ()","title":"generate()"},{"location":"core/keypair/#solana.keypair.Keypair.sign","text":"Sign a message with this keypair. Parameters: Name Type Description Default msg bytes message to sign. required Returns: Type Description Signature A signed messeged object. Examples: >>> seed = bytes ([ 1 ] * 32 ) >>> keypair = Keypair . from_seed ( seed ) >>> msg = b \"hello\" >>> signature = keypair . sign ( msg ) >>> bytes ( signature ) . hex () 'e1430c6ebd0d53573b5c803452174f8991ef5955e0906a09e8fdc7310459e9c82a402526748c3431fe7f0e5faafbf7e703234789734063ee42be17af16438d08' Source code in solana/keypair.py def sign ( self , msg : bytes ) -> Signature : \"\"\"Sign a message with this keypair. Args: msg: message to sign. Returns: A signed messeged object. Example: >>> seed = bytes([1] * 32) >>> keypair = Keypair.from_seed(seed) >>> msg = b\"hello\" >>> signature = keypair.sign(msg) >>> bytes(signature).hex() 'e1430c6ebd0d53573b5c803452174f8991ef5955e0906a09e8fdc7310459e9c82a402526748c3431fe7f0e5faafbf7e703234789734063ee42be17af16438d08' \"\"\" # pylint: disable=line-too-long return self . _solders . sign_message ( msg )","title":"sign()"},{"location":"core/keypair/#solana.keypair.Keypair.to_solders","text":"Convert to the corresponding solders type. Returns: Type Description solders.keypair.Keypair A solders keypair. Source code in solana/keypair.py def to_solders ( self ) -> solders . keypair . Keypair : \"\"\"Convert to the corresponding `solders` type. Returns: A `solders` keypair. \"\"\" return self . _solders","title":"to_solders()"},{"location":"core/message/","text":"Message solana.message Library for generating a message from a sequence of instructions. Message Message object to be used to to build a transaction. A message contains a header, followed by a compact-array of account addresses, followed by a recent blockhash, followed by a compact-array of instructions. Source code in solana/message.py class Message : \"\"\"Message object to be used to to build a transaction. A message contains a header, followed by a compact-array of account addresses, followed by a recent blockhash, followed by a compact-array of instructions. \"\"\" def __init__ ( self , args : MessageArgs ) -> None : \"\"\"Init message object.\"\"\" header = args . header blockhash = Hash . from_string ( args . recent_blockhash ) account_keys = [ Pubkey . from_string ( key ) for key in args . account_keys ] self . _solders = SoldersMessage . new_with_compiled_instructions ( num_required_signatures = header . num_required_signatures , num_readonly_signed_accounts = header . num_readonly_signed_accounts , num_readonly_unsigned_accounts = header . num_readonly_unsigned_accounts , account_keys = account_keys , recent_blockhash = blockhash , instructions = args . instructions , ) @classmethod def from_solders ( cls , msg : SoldersMessage ) -> Message : \"\"\"Convert from a `solders` message. Args: msg: The `solders` message. Returns: A `solana-py` message. \"\"\" args = MessageArgs ( header = msg . header , account_keys = [ str ( key ) for key in msg . account_keys ], recent_blockhash = Blockhash ( str ( msg . recent_blockhash )), instructions = msg . instructions , ) return cls ( args ) def to_solders ( self ) -> SoldersMessage : \"\"\"Convert to a `solders` message. Returns: A `solders` message. \"\"\" return self . _solders @property def header ( self ) -> MessageHeader : \"\"\"Get the message header, identifying signed and read-only `account_keys`. Returns: The message header. \"\"\" return self . _solders . header @property def account_keys ( self ) -> List [ PublicKey ]: \"\"\"All the account keys used by this transaction. Returns: The account keys. \"\"\" return [ PublicKey . from_solders ( pubkey ) for pubkey in self . _solders . account_keys ] @property def recent_blockhash ( self ) -> Blockhash : \"\"\"The hash of a recent ledger block. Returns: The blockhash. \"\"\" return Blockhash ( str ( self . _solders . recent_blockhash )) @property def instructions ( self ) -> List [ CompiledInstruction ]: \"\"\"Instructions that will be executed in sequence and committed in one atomic transaction if all succeed. Returns: The message instructions. \"\"\" return self . _solders . instructions def is_account_writable ( self , index : int ) -> bool : \"\"\"Check if account is write eligble.\"\"\" return self . _solders . is_writable ( index ) def serialize ( self ) -> bytes : \"\"\"Serialize message to bytes. Example: >>> from solana.blockhash import Blockhash >>> account_keys = [str(PublicKey(i + 1)) for i in range(5)] >>> msg = Message( ... MessageArgs( ... account_keys=account_keys, ... header=MessageHeader( ... num_readonly_signed_accounts=0, num_readonly_unsigned_accounts=3, num_required_signatures=2 ... ), ... instructions=[ ... CompiledInstruction(accounts=bytes([1, 2, 3]), data=bytes([9] * 5), program_id_index=4)], ... recent_blockhash=Blockhash(\"EETubP5AKHgjPAhzPAFcb8BAY1hMH639CWCFTqi3hq1k\"), ... ) ... ) >>> msg.serialize().hex() '0200030500000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000005c49ae77603782054f17a9decea43b444eba0edb12c6f1d31c6e0e4a84bf052eb010403010203050909090909' Returns: The serialized message. \"\"\" # pylint: disable=line-too-long # noqa: E501 return bytes ( self . _solders ) @classmethod def deserialize ( cls , raw_message : bytes ) -> Message : # pylint: disable=too-many-locals \"\"\"Deserialize raw message bytes. Example: >>> raw_message = bytes.fromhex( ... '0200030500000000000000000000000000000000000000000000' ... '0000000000000000000100000000000000000000000000000000' ... '0000000000000000000000000000000200000000000000000000' ... '0000000000000000000000000000000000000000000300000000' ... '0000000000000000000000000000000000000000000000000000' ... '0004000000000000000000000000000000000000000000000000' ... '0000000000000005c49ae77603782054f17a9decea43b444eba0' ... 'edb12c6f1d31c6e0e4a84bf052eb010403010203050909090909' ... ) >>> type(Message.deserialize(raw_message)) <class 'solana.message.Message'> Returns: The deserialized message. \"\"\" msg = SoldersMessage . from_bytes ( raw_message ) return cls . from_solders ( msg ) account_keys : List [ PublicKey ] property readonly All the account keys used by this transaction. Returns: Type Description List[PublicKey] The account keys. header : MessageHeader property readonly Get the message header, identifying signed and read-only account_keys . Returns: Type Description MessageHeader The message header. instructions : List [ CompiledInstruction ] property readonly Instructions that will be executed in sequence and committed in one atomic transaction if all succeed. Returns: Type Description List[CompiledInstruction] The message instructions. recent_blockhash : Blockhash property readonly The hash of a recent ledger block. Returns: Type Description Blockhash The blockhash. __init__ ( self , args ) special Init message object. Source code in solana/message.py def __init__ ( self , args : MessageArgs ) -> None : \"\"\"Init message object.\"\"\" header = args . header blockhash = Hash . from_string ( args . recent_blockhash ) account_keys = [ Pubkey . from_string ( key ) for key in args . account_keys ] self . _solders = SoldersMessage . new_with_compiled_instructions ( num_required_signatures = header . num_required_signatures , num_readonly_signed_accounts = header . num_readonly_signed_accounts , num_readonly_unsigned_accounts = header . num_readonly_unsigned_accounts , account_keys = account_keys , recent_blockhash = blockhash , instructions = args . instructions , ) deserialize ( raw_message ) classmethod Deserialize raw message bytes. Examples: >>> raw_message = bytes . fromhex ( ... '0200030500000000000000000000000000000000000000000000' ... '0000000000000000000100000000000000000000000000000000' ... '0000000000000000000000000000000200000000000000000000' ... '0000000000000000000000000000000000000000000300000000' ... '0000000000000000000000000000000000000000000000000000' ... '0004000000000000000000000000000000000000000000000000' ... '0000000000000005c49ae77603782054f17a9decea43b444eba0' ... 'edb12c6f1d31c6e0e4a84bf052eb010403010203050909090909' ... ) >>> type ( Message . deserialize ( raw_message )) < class ' solana . message . Message '> Returns: Type Description Message The deserialized message. Source code in solana/message.py @classmethod def deserialize ( cls , raw_message : bytes ) -> Message : # pylint: disable=too-many-locals \"\"\"Deserialize raw message bytes. Example: >>> raw_message = bytes.fromhex( ... '0200030500000000000000000000000000000000000000000000' ... '0000000000000000000100000000000000000000000000000000' ... '0000000000000000000000000000000200000000000000000000' ... '0000000000000000000000000000000000000000000300000000' ... '0000000000000000000000000000000000000000000000000000' ... '0004000000000000000000000000000000000000000000000000' ... '0000000000000005c49ae77603782054f17a9decea43b444eba0' ... 'edb12c6f1d31c6e0e4a84bf052eb010403010203050909090909' ... ) >>> type(Message.deserialize(raw_message)) <class 'solana.message.Message'> Returns: The deserialized message. \"\"\" msg = SoldersMessage . from_bytes ( raw_message ) return cls . from_solders ( msg ) from_solders ( msg ) classmethod Convert from a solders message. Parameters: Name Type Description Default msg SoldersMessage The solders message. required Returns: Type Description Message A solana-py message. Source code in solana/message.py @classmethod def from_solders ( cls , msg : SoldersMessage ) -> Message : \"\"\"Convert from a `solders` message. Args: msg: The `solders` message. Returns: A `solana-py` message. \"\"\" args = MessageArgs ( header = msg . header , account_keys = [ str ( key ) for key in msg . account_keys ], recent_blockhash = Blockhash ( str ( msg . recent_blockhash )), instructions = msg . instructions , ) return cls ( args ) is_account_writable ( self , index ) Check if account is write eligble. Source code in solana/message.py def is_account_writable ( self , index : int ) -> bool : \"\"\"Check if account is write eligble.\"\"\" return self . _solders . is_writable ( index ) serialize ( self ) Serialize message to bytes. Examples: >>> from solana.blockhash import Blockhash >>> account_keys = [ str ( PublicKey ( i + 1 )) for i in range ( 5 )] >>> msg = Message ( ... MessageArgs ( ... account_keys = account_keys , ... header = MessageHeader ( ... num_readonly_signed_accounts = 0 , num_readonly_unsigned_accounts = 3 , num_required_signatures = 2 ... ), ... instructions = [ ... CompiledInstruction ( accounts = bytes ([ 1 , 2 , 3 ]), data = bytes ([ 9 ] * 5 ), program_id_index = 4 )], ... recent_blockhash = Blockhash ( \"EETubP5AKHgjPAhzPAFcb8BAY1hMH639CWCFTqi3hq1k\" ), ... ) ... ) >>> msg . serialize () . hex () '0200030500000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000005c49ae77603782054f17a9decea43b444eba0edb12c6f1d31c6e0e4a84bf052eb010403010203050909090909' Returns: Type Description bytes The serialized message. Source code in solana/message.py def serialize ( self ) -> bytes : \"\"\"Serialize message to bytes. Example: >>> from solana.blockhash import Blockhash >>> account_keys = [str(PublicKey(i + 1)) for i in range(5)] >>> msg = Message( ... MessageArgs( ... account_keys=account_keys, ... header=MessageHeader( ... num_readonly_signed_accounts=0, num_readonly_unsigned_accounts=3, num_required_signatures=2 ... ), ... instructions=[ ... CompiledInstruction(accounts=bytes([1, 2, 3]), data=bytes([9] * 5), program_id_index=4)], ... recent_blockhash=Blockhash(\"EETubP5AKHgjPAhzPAFcb8BAY1hMH639CWCFTqi3hq1k\"), ... ) ... ) >>> msg.serialize().hex() '0200030500000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000005c49ae77603782054f17a9decea43b444eba0edb12c6f1d31c6e0e4a84bf052eb010403010203050909090909' Returns: The serialized message. \"\"\" # pylint: disable=line-too-long # noqa: E501 return bytes ( self . _solders ) to_solders ( self ) Convert to a solders message. Returns: Type Description SoldersMessage A solders message. Source code in solana/message.py def to_solders ( self ) -> SoldersMessage : \"\"\"Convert to a `solders` message. Returns: A `solders` message. \"\"\" return self . _solders MessageArgs Message constructor arguments. Source code in solana/message.py class MessageArgs ( NamedTuple ): \"\"\"Message constructor arguments.\"\"\" header : MessageHeader \"\"\"The message header, identifying signed and read-only `account_keys`.\"\"\" account_keys : List [ str ] \"\"\"All the account keys used by this transaction.\"\"\" recent_blockhash : Blockhash \"\"\"The hash of a recent ledger block.\"\"\" instructions : List [ CompiledInstruction ] \"\"\"Instructions that will be executed in sequence and committed in one atomic transaction if all succeed.\"\"\" account_keys : List [ str ] All the account keys used by this transaction. header : MessageHeader The message header, identifying signed and read-only account_keys . instructions : List [ solders . instruction . CompiledInstruction ] Instructions that will be executed in sequence and committed in one atomic transaction if all succeed. recent_blockhash : < function NewType .< locals >. new_type at 0x7f7a958658b0 > The hash of a recent ledger block.","title":"Message"},{"location":"core/message/#message","text":"","title":"Message"},{"location":"core/message/#solana.message","text":"Library for generating a message from a sequence of instructions.","title":"message"},{"location":"core/message/#solana.message.Message","text":"Message object to be used to to build a transaction. A message contains a header, followed by a compact-array of account addresses, followed by a recent blockhash, followed by a compact-array of instructions. Source code in solana/message.py class Message : \"\"\"Message object to be used to to build a transaction. A message contains a header, followed by a compact-array of account addresses, followed by a recent blockhash, followed by a compact-array of instructions. \"\"\" def __init__ ( self , args : MessageArgs ) -> None : \"\"\"Init message object.\"\"\" header = args . header blockhash = Hash . from_string ( args . recent_blockhash ) account_keys = [ Pubkey . from_string ( key ) for key in args . account_keys ] self . _solders = SoldersMessage . new_with_compiled_instructions ( num_required_signatures = header . num_required_signatures , num_readonly_signed_accounts = header . num_readonly_signed_accounts , num_readonly_unsigned_accounts = header . num_readonly_unsigned_accounts , account_keys = account_keys , recent_blockhash = blockhash , instructions = args . instructions , ) @classmethod def from_solders ( cls , msg : SoldersMessage ) -> Message : \"\"\"Convert from a `solders` message. Args: msg: The `solders` message. Returns: A `solana-py` message. \"\"\" args = MessageArgs ( header = msg . header , account_keys = [ str ( key ) for key in msg . account_keys ], recent_blockhash = Blockhash ( str ( msg . recent_blockhash )), instructions = msg . instructions , ) return cls ( args ) def to_solders ( self ) -> SoldersMessage : \"\"\"Convert to a `solders` message. Returns: A `solders` message. \"\"\" return self . _solders @property def header ( self ) -> MessageHeader : \"\"\"Get the message header, identifying signed and read-only `account_keys`. Returns: The message header. \"\"\" return self . _solders . header @property def account_keys ( self ) -> List [ PublicKey ]: \"\"\"All the account keys used by this transaction. Returns: The account keys. \"\"\" return [ PublicKey . from_solders ( pubkey ) for pubkey in self . _solders . account_keys ] @property def recent_blockhash ( self ) -> Blockhash : \"\"\"The hash of a recent ledger block. Returns: The blockhash. \"\"\" return Blockhash ( str ( self . _solders . recent_blockhash )) @property def instructions ( self ) -> List [ CompiledInstruction ]: \"\"\"Instructions that will be executed in sequence and committed in one atomic transaction if all succeed. Returns: The message instructions. \"\"\" return self . _solders . instructions def is_account_writable ( self , index : int ) -> bool : \"\"\"Check if account is write eligble.\"\"\" return self . _solders . is_writable ( index ) def serialize ( self ) -> bytes : \"\"\"Serialize message to bytes. Example: >>> from solana.blockhash import Blockhash >>> account_keys = [str(PublicKey(i + 1)) for i in range(5)] >>> msg = Message( ... MessageArgs( ... account_keys=account_keys, ... header=MessageHeader( ... num_readonly_signed_accounts=0, num_readonly_unsigned_accounts=3, num_required_signatures=2 ... ), ... instructions=[ ... CompiledInstruction(accounts=bytes([1, 2, 3]), data=bytes([9] * 5), program_id_index=4)], ... recent_blockhash=Blockhash(\"EETubP5AKHgjPAhzPAFcb8BAY1hMH639CWCFTqi3hq1k\"), ... ) ... ) >>> msg.serialize().hex() '0200030500000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000005c49ae77603782054f17a9decea43b444eba0edb12c6f1d31c6e0e4a84bf052eb010403010203050909090909' Returns: The serialized message. \"\"\" # pylint: disable=line-too-long # noqa: E501 return bytes ( self . _solders ) @classmethod def deserialize ( cls , raw_message : bytes ) -> Message : # pylint: disable=too-many-locals \"\"\"Deserialize raw message bytes. Example: >>> raw_message = bytes.fromhex( ... '0200030500000000000000000000000000000000000000000000' ... '0000000000000000000100000000000000000000000000000000' ... '0000000000000000000000000000000200000000000000000000' ... '0000000000000000000000000000000000000000000300000000' ... '0000000000000000000000000000000000000000000000000000' ... '0004000000000000000000000000000000000000000000000000' ... '0000000000000005c49ae77603782054f17a9decea43b444eba0' ... 'edb12c6f1d31c6e0e4a84bf052eb010403010203050909090909' ... ) >>> type(Message.deserialize(raw_message)) <class 'solana.message.Message'> Returns: The deserialized message. \"\"\" msg = SoldersMessage . from_bytes ( raw_message ) return cls . from_solders ( msg )","title":"Message"},{"location":"core/message/#solana.message.Message.account_keys","text":"All the account keys used by this transaction. Returns: Type Description List[PublicKey] The account keys.","title":"account_keys"},{"location":"core/message/#solana.message.Message.header","text":"Get the message header, identifying signed and read-only account_keys . Returns: Type Description MessageHeader The message header.","title":"header"},{"location":"core/message/#solana.message.Message.instructions","text":"Instructions that will be executed in sequence and committed in one atomic transaction if all succeed. Returns: Type Description List[CompiledInstruction] The message instructions.","title":"instructions"},{"location":"core/message/#solana.message.Message.recent_blockhash","text":"The hash of a recent ledger block. Returns: Type Description Blockhash The blockhash.","title":"recent_blockhash"},{"location":"core/message/#solana.message.Message.__init__","text":"Init message object. Source code in solana/message.py def __init__ ( self , args : MessageArgs ) -> None : \"\"\"Init message object.\"\"\" header = args . header blockhash = Hash . from_string ( args . recent_blockhash ) account_keys = [ Pubkey . from_string ( key ) for key in args . account_keys ] self . _solders = SoldersMessage . new_with_compiled_instructions ( num_required_signatures = header . num_required_signatures , num_readonly_signed_accounts = header . num_readonly_signed_accounts , num_readonly_unsigned_accounts = header . num_readonly_unsigned_accounts , account_keys = account_keys , recent_blockhash = blockhash , instructions = args . instructions , )","title":"__init__()"},{"location":"core/message/#solana.message.Message.deserialize","text":"Deserialize raw message bytes. Examples: >>> raw_message = bytes . fromhex ( ... '0200030500000000000000000000000000000000000000000000' ... '0000000000000000000100000000000000000000000000000000' ... '0000000000000000000000000000000200000000000000000000' ... '0000000000000000000000000000000000000000000300000000' ... '0000000000000000000000000000000000000000000000000000' ... '0004000000000000000000000000000000000000000000000000' ... '0000000000000005c49ae77603782054f17a9decea43b444eba0' ... 'edb12c6f1d31c6e0e4a84bf052eb010403010203050909090909' ... ) >>> type ( Message . deserialize ( raw_message )) < class ' solana . message . Message '> Returns: Type Description Message The deserialized message. Source code in solana/message.py @classmethod def deserialize ( cls , raw_message : bytes ) -> Message : # pylint: disable=too-many-locals \"\"\"Deserialize raw message bytes. Example: >>> raw_message = bytes.fromhex( ... '0200030500000000000000000000000000000000000000000000' ... '0000000000000000000100000000000000000000000000000000' ... '0000000000000000000000000000000200000000000000000000' ... '0000000000000000000000000000000000000000000300000000' ... '0000000000000000000000000000000000000000000000000000' ... '0004000000000000000000000000000000000000000000000000' ... '0000000000000005c49ae77603782054f17a9decea43b444eba0' ... 'edb12c6f1d31c6e0e4a84bf052eb010403010203050909090909' ... ) >>> type(Message.deserialize(raw_message)) <class 'solana.message.Message'> Returns: The deserialized message. \"\"\" msg = SoldersMessage . from_bytes ( raw_message ) return cls . from_solders ( msg )","title":"deserialize()"},{"location":"core/message/#solana.message.Message.from_solders","text":"Convert from a solders message. Parameters: Name Type Description Default msg SoldersMessage The solders message. required Returns: Type Description Message A solana-py message. Source code in solana/message.py @classmethod def from_solders ( cls , msg : SoldersMessage ) -> Message : \"\"\"Convert from a `solders` message. Args: msg: The `solders` message. Returns: A `solana-py` message. \"\"\" args = MessageArgs ( header = msg . header , account_keys = [ str ( key ) for key in msg . account_keys ], recent_blockhash = Blockhash ( str ( msg . recent_blockhash )), instructions = msg . instructions , ) return cls ( args )","title":"from_solders()"},{"location":"core/message/#solana.message.Message.is_account_writable","text":"Check if account is write eligble. Source code in solana/message.py def is_account_writable ( self , index : int ) -> bool : \"\"\"Check if account is write eligble.\"\"\" return self . _solders . is_writable ( index )","title":"is_account_writable()"},{"location":"core/message/#solana.message.Message.serialize","text":"Serialize message to bytes. Examples: >>> from solana.blockhash import Blockhash >>> account_keys = [ str ( PublicKey ( i + 1 )) for i in range ( 5 )] >>> msg = Message ( ... MessageArgs ( ... account_keys = account_keys , ... header = MessageHeader ( ... num_readonly_signed_accounts = 0 , num_readonly_unsigned_accounts = 3 , num_required_signatures = 2 ... ), ... instructions = [ ... CompiledInstruction ( accounts = bytes ([ 1 , 2 , 3 ]), data = bytes ([ 9 ] * 5 ), program_id_index = 4 )], ... recent_blockhash = Blockhash ( \"EETubP5AKHgjPAhzPAFcb8BAY1hMH639CWCFTqi3hq1k\" ), ... ) ... ) >>> msg . serialize () . hex () '0200030500000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000005c49ae77603782054f17a9decea43b444eba0edb12c6f1d31c6e0e4a84bf052eb010403010203050909090909' Returns: Type Description bytes The serialized message. Source code in solana/message.py def serialize ( self ) -> bytes : \"\"\"Serialize message to bytes. Example: >>> from solana.blockhash import Blockhash >>> account_keys = [str(PublicKey(i + 1)) for i in range(5)] >>> msg = Message( ... MessageArgs( ... account_keys=account_keys, ... header=MessageHeader( ... num_readonly_signed_accounts=0, num_readonly_unsigned_accounts=3, num_required_signatures=2 ... ), ... instructions=[ ... CompiledInstruction(accounts=bytes([1, 2, 3]), data=bytes([9] * 5), program_id_index=4)], ... recent_blockhash=Blockhash(\"EETubP5AKHgjPAhzPAFcb8BAY1hMH639CWCFTqi3hq1k\"), ... ) ... ) >>> msg.serialize().hex() '0200030500000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000005c49ae77603782054f17a9decea43b444eba0edb12c6f1d31c6e0e4a84bf052eb010403010203050909090909' Returns: The serialized message. \"\"\" # pylint: disable=line-too-long # noqa: E501 return bytes ( self . _solders )","title":"serialize()"},{"location":"core/message/#solana.message.Message.to_solders","text":"Convert to a solders message. Returns: Type Description SoldersMessage A solders message. Source code in solana/message.py def to_solders ( self ) -> SoldersMessage : \"\"\"Convert to a `solders` message. Returns: A `solders` message. \"\"\" return self . _solders","title":"to_solders()"},{"location":"core/message/#solana.message.MessageArgs","text":"Message constructor arguments. Source code in solana/message.py class MessageArgs ( NamedTuple ): \"\"\"Message constructor arguments.\"\"\" header : MessageHeader \"\"\"The message header, identifying signed and read-only `account_keys`.\"\"\" account_keys : List [ str ] \"\"\"All the account keys used by this transaction.\"\"\" recent_blockhash : Blockhash \"\"\"The hash of a recent ledger block.\"\"\" instructions : List [ CompiledInstruction ] \"\"\"Instructions that will be executed in sequence and committed in one atomic transaction if all succeed.\"\"\"","title":"MessageArgs"},{"location":"core/message/#solana.message.MessageArgs.account_keys","text":"All the account keys used by this transaction.","title":"account_keys"},{"location":"core/message/#solana.message.MessageArgs.header","text":"The message header, identifying signed and read-only account_keys .","title":"header"},{"location":"core/message/#solana.message.MessageArgs.instructions","text":"Instructions that will be executed in sequence and committed in one atomic transaction if all succeed.","title":"instructions"},{"location":"core/message/#solana.message.MessageArgs.recent_blockhash","text":"The hash of a recent ledger block.","title":"recent_blockhash"},{"location":"core/publickey/","text":"Public Key solana.publickey Library to interface with Solana public keys. PublicKey The public key of a keypair. Examples: >>> # An arbitary public key: >>> pubkey = PublicKey ( 1 ) >>> str ( pubkey ) # String representation in base58 form. '11111111111111111111111111111112' >>> bytes ( pubkey ) . hex () '0000000000000000000000000000000000000000000000000000000000000001' Source code in solana/publickey.py class PublicKey : \"\"\"The public key of a keypair. Example: >>> # An arbitary public key: >>> pubkey = PublicKey(1) >>> str(pubkey) # String representation in base58 form. '11111111111111111111111111111112' >>> bytes(pubkey).hex() '0000000000000000000000000000000000000000000000000000000000000001' \"\"\" LENGTH = Pubkey . LENGTH \"\"\"Constant for standard length of a public key.\"\"\" def __init__ ( self , value : Union [ bytearray , bytes , int , str , List [ int ], Pubkey ]): \"\"\"Init PublicKey object.\"\"\" if isinstance ( value , Pubkey ): self . _solders = value elif isinstance ( value , str ): try : self . _solders = Pubkey . from_string ( value ) except ValueError as err : raise ValueError ( \"invalid public key input:\" , value ) from err elif isinstance ( value , int ): self . _solders = Pubkey ( _rjust_pubkey ( bytes ([ value ]))) else : self . _solders = Pubkey ( _rjust_pubkey ( bytes ( value ))) @classmethod def from_solders ( cls , pubkey : Pubkey ) -> PublicKey : \"\"\"Convert from the corresponding `solders` type. Args: pubkey: A `solders` pubkey. Returns: A `solana-py` public key. \"\"\" return cls ( pubkey ) def to_solders ( self ) -> Pubkey : \"\"\"Convert to the corresponding `solders` type. Returns: A `solders` pubkey. \"\"\" return self . _solders def __bytes__ ( self ) -> bytes : \"\"\"Public key in bytes.\"\"\" return bytes ( self . _solders ) def __eq__ ( self , other : Any ) -> bool : \"\"\"Equality definition for PublicKeys.\"\"\" return False if not isinstance ( other , PublicKey ) else bytes ( self ) == bytes ( other ) def __hash__ ( self ) -> int : \"\"\"Returns a unique hash for set operations.\"\"\" return hash ( self . __bytes__ ()) def __repr__ ( self ) -> str : \"\"\"Representation of a PublicKey.\"\"\" return str ( self ) def __str__ ( self ) -> str : \"\"\"String definition for PublicKey.\"\"\" return self . to_base58 () . decode ( \"utf-8\" ) def to_base58 ( self ) -> bytes : \"\"\"Public key in base58. Returns: The base58-encoded public key. \"\"\" return str ( self . _solders ) . encode () @classmethod def create_with_seed ( cls , from_public_key : PublicKey , seed : str , program_id : PublicKey ) -> PublicKey : \"\"\"Derive a public key from another key, a seed, and a program ID. Returns: The derived public key. \"\"\" underlying = Pubkey . create_with_seed ( from_public_key . to_solders (), seed , program_id . to_solders ()) return PublicKey . from_solders ( underlying ) @classmethod def create_program_address ( cls , seeds : List [ bytes ], program_id : PublicKey ) -> PublicKey : \"\"\"Derive a program address from seeds and a program ID. Returns: The derived program address. \"\"\" underlying = Pubkey . create_program_address ( seeds , program_id . to_solders ()) return cls . from_solders ( underlying ) @classmethod def find_program_address ( cls , seeds : List [ bytes ], program_id : PublicKey ) -> Tuple [ PublicKey , int ]: \"\"\"Find a valid program address. Valid program addresses must fall off the ed25519 curve. This function iterates a nonce until it finds one that when combined with the seeds results in a valid program address. Returns: The program address and nonce used. \"\"\" underlying_pubkey , nonce = Pubkey . find_program_address ( seeds , program_id . to_solders ()) return cls . from_solders ( underlying_pubkey ), nonce LENGTH Constant for standard length of a public key. __init__ ( self , value ) special Init PublicKey object. Source code in solana/publickey.py def __init__ ( self , value : Union [ bytearray , bytes , int , str , List [ int ], Pubkey ]): \"\"\"Init PublicKey object.\"\"\" if isinstance ( value , Pubkey ): self . _solders = value elif isinstance ( value , str ): try : self . _solders = Pubkey . from_string ( value ) except ValueError as err : raise ValueError ( \"invalid public key input:\" , value ) from err elif isinstance ( value , int ): self . _solders = Pubkey ( _rjust_pubkey ( bytes ([ value ]))) else : self . _solders = Pubkey ( _rjust_pubkey ( bytes ( value ))) create_program_address ( seeds , program_id ) classmethod Derive a program address from seeds and a program ID. Returns: Type Description PublicKey The derived program address. Source code in solana/publickey.py @classmethod def create_program_address ( cls , seeds : List [ bytes ], program_id : PublicKey ) -> PublicKey : \"\"\"Derive a program address from seeds and a program ID. Returns: The derived program address. \"\"\" underlying = Pubkey . create_program_address ( seeds , program_id . to_solders ()) return cls . from_solders ( underlying ) create_with_seed ( from_public_key , seed , program_id ) classmethod Derive a public key from another key, a seed, and a program ID. Returns: Type Description PublicKey The derived public key. Source code in solana/publickey.py @classmethod def create_with_seed ( cls , from_public_key : PublicKey , seed : str , program_id : PublicKey ) -> PublicKey : \"\"\"Derive a public key from another key, a seed, and a program ID. Returns: The derived public key. \"\"\" underlying = Pubkey . create_with_seed ( from_public_key . to_solders (), seed , program_id . to_solders ()) return PublicKey . from_solders ( underlying ) find_program_address ( seeds , program_id ) classmethod Find a valid program address. Valid program addresses must fall off the ed25519 curve. This function iterates a nonce until it finds one that when combined with the seeds results in a valid program address. Returns: Type Description Tuple[PublicKey, int] The program address and nonce used. Source code in solana/publickey.py @classmethod def find_program_address ( cls , seeds : List [ bytes ], program_id : PublicKey ) -> Tuple [ PublicKey , int ]: \"\"\"Find a valid program address. Valid program addresses must fall off the ed25519 curve. This function iterates a nonce until it finds one that when combined with the seeds results in a valid program address. Returns: The program address and nonce used. \"\"\" underlying_pubkey , nonce = Pubkey . find_program_address ( seeds , program_id . to_solders ()) return cls . from_solders ( underlying_pubkey ), nonce from_solders ( pubkey ) classmethod Convert from the corresponding solders type. Parameters: Name Type Description Default pubkey Pubkey A solders pubkey. required Returns: Type Description PublicKey A solana-py public key. Source code in solana/publickey.py @classmethod def from_solders ( cls , pubkey : Pubkey ) -> PublicKey : \"\"\"Convert from the corresponding `solders` type. Args: pubkey: A `solders` pubkey. Returns: A `solana-py` public key. \"\"\" return cls ( pubkey ) to_base58 ( self ) Public key in base58. Returns: Type Description bytes The base58-encoded public key. Source code in solana/publickey.py def to_base58 ( self ) -> bytes : \"\"\"Public key in base58. Returns: The base58-encoded public key. \"\"\" return str ( self . _solders ) . encode () to_solders ( self ) Convert to the corresponding solders type. Returns: Type Description Pubkey A solders pubkey. Source code in solana/publickey.py def to_solders ( self ) -> Pubkey : \"\"\"Convert to the corresponding `solders` type. Returns: A `solders` pubkey. \"\"\" return self . _solders","title":"Public Key"},{"location":"core/publickey/#public-key","text":"","title":"Public Key"},{"location":"core/publickey/#solana.publickey","text":"Library to interface with Solana public keys.","title":"publickey"},{"location":"core/publickey/#solana.publickey.PublicKey","text":"The public key of a keypair. Examples: >>> # An arbitary public key: >>> pubkey = PublicKey ( 1 ) >>> str ( pubkey ) # String representation in base58 form. '11111111111111111111111111111112' >>> bytes ( pubkey ) . hex () '0000000000000000000000000000000000000000000000000000000000000001' Source code in solana/publickey.py class PublicKey : \"\"\"The public key of a keypair. Example: >>> # An arbitary public key: >>> pubkey = PublicKey(1) >>> str(pubkey) # String representation in base58 form. '11111111111111111111111111111112' >>> bytes(pubkey).hex() '0000000000000000000000000000000000000000000000000000000000000001' \"\"\" LENGTH = Pubkey . LENGTH \"\"\"Constant for standard length of a public key.\"\"\" def __init__ ( self , value : Union [ bytearray , bytes , int , str , List [ int ], Pubkey ]): \"\"\"Init PublicKey object.\"\"\" if isinstance ( value , Pubkey ): self . _solders = value elif isinstance ( value , str ): try : self . _solders = Pubkey . from_string ( value ) except ValueError as err : raise ValueError ( \"invalid public key input:\" , value ) from err elif isinstance ( value , int ): self . _solders = Pubkey ( _rjust_pubkey ( bytes ([ value ]))) else : self . _solders = Pubkey ( _rjust_pubkey ( bytes ( value ))) @classmethod def from_solders ( cls , pubkey : Pubkey ) -> PublicKey : \"\"\"Convert from the corresponding `solders` type. Args: pubkey: A `solders` pubkey. Returns: A `solana-py` public key. \"\"\" return cls ( pubkey ) def to_solders ( self ) -> Pubkey : \"\"\"Convert to the corresponding `solders` type. Returns: A `solders` pubkey. \"\"\" return self . _solders def __bytes__ ( self ) -> bytes : \"\"\"Public key in bytes.\"\"\" return bytes ( self . _solders ) def __eq__ ( self , other : Any ) -> bool : \"\"\"Equality definition for PublicKeys.\"\"\" return False if not isinstance ( other , PublicKey ) else bytes ( self ) == bytes ( other ) def __hash__ ( self ) -> int : \"\"\"Returns a unique hash for set operations.\"\"\" return hash ( self . __bytes__ ()) def __repr__ ( self ) -> str : \"\"\"Representation of a PublicKey.\"\"\" return str ( self ) def __str__ ( self ) -> str : \"\"\"String definition for PublicKey.\"\"\" return self . to_base58 () . decode ( \"utf-8\" ) def to_base58 ( self ) -> bytes : \"\"\"Public key in base58. Returns: The base58-encoded public key. \"\"\" return str ( self . _solders ) . encode () @classmethod def create_with_seed ( cls , from_public_key : PublicKey , seed : str , program_id : PublicKey ) -> PublicKey : \"\"\"Derive a public key from another key, a seed, and a program ID. Returns: The derived public key. \"\"\" underlying = Pubkey . create_with_seed ( from_public_key . to_solders (), seed , program_id . to_solders ()) return PublicKey . from_solders ( underlying ) @classmethod def create_program_address ( cls , seeds : List [ bytes ], program_id : PublicKey ) -> PublicKey : \"\"\"Derive a program address from seeds and a program ID. Returns: The derived program address. \"\"\" underlying = Pubkey . create_program_address ( seeds , program_id . to_solders ()) return cls . from_solders ( underlying ) @classmethod def find_program_address ( cls , seeds : List [ bytes ], program_id : PublicKey ) -> Tuple [ PublicKey , int ]: \"\"\"Find a valid program address. Valid program addresses must fall off the ed25519 curve. This function iterates a nonce until it finds one that when combined with the seeds results in a valid program address. Returns: The program address and nonce used. \"\"\" underlying_pubkey , nonce = Pubkey . find_program_address ( seeds , program_id . to_solders ()) return cls . from_solders ( underlying_pubkey ), nonce","title":"PublicKey"},{"location":"core/publickey/#solana.publickey.PublicKey.LENGTH","text":"Constant for standard length of a public key.","title":"LENGTH"},{"location":"core/publickey/#solana.publickey.PublicKey.__init__","text":"Init PublicKey object. Source code in solana/publickey.py def __init__ ( self , value : Union [ bytearray , bytes , int , str , List [ int ], Pubkey ]): \"\"\"Init PublicKey object.\"\"\" if isinstance ( value , Pubkey ): self . _solders = value elif isinstance ( value , str ): try : self . _solders = Pubkey . from_string ( value ) except ValueError as err : raise ValueError ( \"invalid public key input:\" , value ) from err elif isinstance ( value , int ): self . _solders = Pubkey ( _rjust_pubkey ( bytes ([ value ]))) else : self . _solders = Pubkey ( _rjust_pubkey ( bytes ( value )))","title":"__init__()"},{"location":"core/publickey/#solana.publickey.PublicKey.create_program_address","text":"Derive a program address from seeds and a program ID. Returns: Type Description PublicKey The derived program address. Source code in solana/publickey.py @classmethod def create_program_address ( cls , seeds : List [ bytes ], program_id : PublicKey ) -> PublicKey : \"\"\"Derive a program address from seeds and a program ID. Returns: The derived program address. \"\"\" underlying = Pubkey . create_program_address ( seeds , program_id . to_solders ()) return cls . from_solders ( underlying )","title":"create_program_address()"},{"location":"core/publickey/#solana.publickey.PublicKey.create_with_seed","text":"Derive a public key from another key, a seed, and a program ID. Returns: Type Description PublicKey The derived public key. Source code in solana/publickey.py @classmethod def create_with_seed ( cls , from_public_key : PublicKey , seed : str , program_id : PublicKey ) -> PublicKey : \"\"\"Derive a public key from another key, a seed, and a program ID. Returns: The derived public key. \"\"\" underlying = Pubkey . create_with_seed ( from_public_key . to_solders (), seed , program_id . to_solders ()) return PublicKey . from_solders ( underlying )","title":"create_with_seed()"},{"location":"core/publickey/#solana.publickey.PublicKey.find_program_address","text":"Find a valid program address. Valid program addresses must fall off the ed25519 curve. This function iterates a nonce until it finds one that when combined with the seeds results in a valid program address. Returns: Type Description Tuple[PublicKey, int] The program address and nonce used. Source code in solana/publickey.py @classmethod def find_program_address ( cls , seeds : List [ bytes ], program_id : PublicKey ) -> Tuple [ PublicKey , int ]: \"\"\"Find a valid program address. Valid program addresses must fall off the ed25519 curve. This function iterates a nonce until it finds one that when combined with the seeds results in a valid program address. Returns: The program address and nonce used. \"\"\" underlying_pubkey , nonce = Pubkey . find_program_address ( seeds , program_id . to_solders ()) return cls . from_solders ( underlying_pubkey ), nonce","title":"find_program_address()"},{"location":"core/publickey/#solana.publickey.PublicKey.from_solders","text":"Convert from the corresponding solders type. Parameters: Name Type Description Default pubkey Pubkey A solders pubkey. required Returns: Type Description PublicKey A solana-py public key. Source code in solana/publickey.py @classmethod def from_solders ( cls , pubkey : Pubkey ) -> PublicKey : \"\"\"Convert from the corresponding `solders` type. Args: pubkey: A `solders` pubkey. Returns: A `solana-py` public key. \"\"\" return cls ( pubkey )","title":"from_solders()"},{"location":"core/publickey/#solana.publickey.PublicKey.to_base58","text":"Public key in base58. Returns: Type Description bytes The base58-encoded public key. Source code in solana/publickey.py def to_base58 ( self ) -> bytes : \"\"\"Public key in base58. Returns: The base58-encoded public key. \"\"\" return str ( self . _solders ) . encode ()","title":"to_base58()"},{"location":"core/publickey/#solana.publickey.PublicKey.to_solders","text":"Convert to the corresponding solders type. Returns: Type Description Pubkey A solders pubkey. Source code in solana/publickey.py def to_solders ( self ) -> Pubkey : \"\"\"Convert to the corresponding `solders` type. Returns: A `solders` pubkey. \"\"\" return self . _solders","title":"to_solders()"},{"location":"core/system_program/","text":"System Program solana.system_program Library to interface with the system program. SYS_PROGRAM_ID : PublicKey Public key that identifies the System program. AdvanceNonceParams Advance nonce account system instruction params. Source code in solana/system_program.py class AdvanceNonceParams ( NamedTuple ): \"\"\"Advance nonce account system instruction params.\"\"\" nonce_pubkey : PublicKey \"\"\"\"\"\" authorized_pubkey : PublicKey \"\"\"\"\"\" @classmethod def from_solders ( cls , params : ssp . AdvanceNonceAccountParams ) -> AdvanceNonceParams : \"\"\"Convert from `solders` AdvanceNonceParams. Args: params: `solders` AdvanceNonceParams Returns: `solana-py` AdvanceNonceParams \"\"\" return cls ( nonce_pubkey = PublicKey . from_solders ( params [ \"nonce_pubkey\" ]), authorized_pubkey = PublicKey . from_solders ( params [ \"authorized_pubkey\" ]), ) def to_solders ( self ) -> ssp . AdvanceNonceAccountParams : \"\"\"Convert to `solders` AdvanceNonceParams. Returns: `solders` AdvanceNonceParams \"\"\" return ssp . AdvanceNonceAccountParams ( nonce_pubkey = self . nonce_pubkey . to_solders (), authorized_pubkey = self . authorized_pubkey . to_solders (), ) from_solders ( params ) classmethod Convert from solders AdvanceNonceParams. Parameters: Name Type Description Default params ssp.AdvanceNonceAccountParams solders AdvanceNonceParams required Returns: Type Description AdvanceNonceParams solana-py AdvanceNonceParams Source code in solana/system_program.py @classmethod def from_solders ( cls , params : ssp . AdvanceNonceAccountParams ) -> AdvanceNonceParams : \"\"\"Convert from `solders` AdvanceNonceParams. Args: params: `solders` AdvanceNonceParams Returns: `solana-py` AdvanceNonceParams \"\"\" return cls ( nonce_pubkey = PublicKey . from_solders ( params [ \"nonce_pubkey\" ]), authorized_pubkey = PublicKey . from_solders ( params [ \"authorized_pubkey\" ]), ) to_solders ( self ) Convert to solders AdvanceNonceParams. Returns: Type Description ssp.AdvanceNonceAccountParams solders AdvanceNonceParams Source code in solana/system_program.py def to_solders ( self ) -> ssp . AdvanceNonceAccountParams : \"\"\"Convert to `solders` AdvanceNonceParams. Returns: `solders` AdvanceNonceParams \"\"\" return ssp . AdvanceNonceAccountParams ( nonce_pubkey = self . nonce_pubkey . to_solders (), authorized_pubkey = self . authorized_pubkey . to_solders (), ) AllocateParams Allocate account with seed system transaction params. Source code in solana/system_program.py class AllocateParams ( NamedTuple ): \"\"\"Allocate account with seed system transaction params.\"\"\" account_pubkey : PublicKey \"\"\"\"\"\" space : int \"\"\"\"\"\" @classmethod def from_solders ( cls , params : ssp . AllocateParams ) -> AllocateParams : \"\"\"Convert from `solders` AllocateParams. Args: params: `solders` AllocateParams Returns: `solana-py` AllocateParams \"\"\" return cls ( account_pubkey = PublicKey . from_solders ( params [ \"pubkey\" ]), space = params [ \"space\" ], ) def to_solders ( self ) -> ssp . AllocateParams : \"\"\"Convert to `solders` AllocateParams. Returns: `solders` AllocateParams \"\"\" return ssp . AllocateParams ( pubkey = self . account_pubkey . to_solders (), space = self . space , ) from_solders ( params ) classmethod Convert from solders AllocateParams. Parameters: Name Type Description Default params ssp.AllocateParams solders AllocateParams required Returns: Type Description AllocateParams solana-py AllocateParams Source code in solana/system_program.py @classmethod def from_solders ( cls , params : ssp . AllocateParams ) -> AllocateParams : \"\"\"Convert from `solders` AllocateParams. Args: params: `solders` AllocateParams Returns: `solana-py` AllocateParams \"\"\" return cls ( account_pubkey = PublicKey . from_solders ( params [ \"pubkey\" ]), space = params [ \"space\" ], ) to_solders ( self ) Convert to solders AllocateParams. Returns: Type Description ssp.AllocateParams solders AllocateParams Source code in solana/system_program.py def to_solders ( self ) -> ssp . AllocateParams : \"\"\"Convert to `solders` AllocateParams. Returns: `solders` AllocateParams \"\"\" return ssp . AllocateParams ( pubkey = self . account_pubkey . to_solders (), space = self . space , ) AllocateWithSeedParams Allocate account with seed system transaction params. Source code in solana/system_program.py class AllocateWithSeedParams ( NamedTuple ): \"\"\"Allocate account with seed system transaction params.\"\"\" account_pubkey : PublicKey \"\"\"\"\"\" base_pubkey : PublicKey \"\"\"\"\"\" seed : str \"\"\"\"\"\" space : int \"\"\"\"\"\" program_id : PublicKey \"\"\"\"\"\" @classmethod def from_solders ( cls , params : ssp . AllocateWithSeedParams ) -> AllocateWithSeedParams : \"\"\"Convert from `solders` AllocateWithSeedParams. Args: params: `solders` AllocateWithSeedParams Returns: `solana-py` AllocateWithSeedParams \"\"\" return cls ( account_pubkey = PublicKey . from_solders ( params [ \"address\" ]), base_pubkey = PublicKey . from_solders ( params [ \"base\" ]), seed = params [ \"seed\" ], space = params [ \"space\" ], program_id = PublicKey . from_solders ( params [ \"owner\" ]), ) def to_solders ( self ) -> ssp . AllocateWithSeedParams : \"\"\"Convert to `solders` AllocateWithSeedParams. Returns: `solders` AllocateWithSeedParams \"\"\" return ssp . AllocateWithSeedParams ( address = self . account_pubkey . to_solders (), base = self . base_pubkey . to_solders (), seed = self . seed , space = self . space , owner = self . program_id . to_solders (), ) from_solders ( params ) classmethod Convert from solders AllocateWithSeedParams. Parameters: Name Type Description Default params ssp.AllocateWithSeedParams solders AllocateWithSeedParams required Returns: Type Description AllocateWithSeedParams solana-py AllocateWithSeedParams Source code in solana/system_program.py @classmethod def from_solders ( cls , params : ssp . AllocateWithSeedParams ) -> AllocateWithSeedParams : \"\"\"Convert from `solders` AllocateWithSeedParams. Args: params: `solders` AllocateWithSeedParams Returns: `solana-py` AllocateWithSeedParams \"\"\" return cls ( account_pubkey = PublicKey . from_solders ( params [ \"address\" ]), base_pubkey = PublicKey . from_solders ( params [ \"base\" ]), seed = params [ \"seed\" ], space = params [ \"space\" ], program_id = PublicKey . from_solders ( params [ \"owner\" ]), ) to_solders ( self ) Convert to solders AllocateWithSeedParams. Returns: Type Description ssp.AllocateWithSeedParams solders AllocateWithSeedParams Source code in solana/system_program.py def to_solders ( self ) -> ssp . AllocateWithSeedParams : \"\"\"Convert to `solders` AllocateWithSeedParams. Returns: `solders` AllocateWithSeedParams \"\"\" return ssp . AllocateWithSeedParams ( address = self . account_pubkey . to_solders (), base = self . base_pubkey . to_solders (), seed = self . seed , space = self . space , owner = self . program_id . to_solders (), ) AssignParams Assign system transaction params. Source code in solana/system_program.py class AssignParams ( NamedTuple ): \"\"\"Assign system transaction params.\"\"\" account_pubkey : PublicKey \"\"\"\"\"\" program_id : PublicKey \"\"\"\"\"\" @classmethod def from_solders ( cls , params : ssp . AssignParams ) -> AssignParams : \"\"\"Convert from `solders` AssignParams. Args: params: `solders` AssignParams Returns: `solana-py` AssignParams \"\"\" return cls ( account_pubkey = PublicKey . from_solders ( params [ \"pubkey\" ]), program_id = PublicKey . from_solders ( params [ \"owner\" ]), ) def to_solders ( self ) -> ssp . AssignParams : \"\"\"Convert to `solders` AssignParams. Returns: `solders` AssignParams \"\"\" return ssp . AssignParams ( pubkey = self . account_pubkey . to_solders (), owner = self . program_id . to_solders (), ) from_solders ( params ) classmethod Convert from solders AssignParams. Parameters: Name Type Description Default params ssp.AssignParams solders AssignParams required Returns: Type Description AssignParams solana-py AssignParams Source code in solana/system_program.py @classmethod def from_solders ( cls , params : ssp . AssignParams ) -> AssignParams : \"\"\"Convert from `solders` AssignParams. Args: params: `solders` AssignParams Returns: `solana-py` AssignParams \"\"\" return cls ( account_pubkey = PublicKey . from_solders ( params [ \"pubkey\" ]), program_id = PublicKey . from_solders ( params [ \"owner\" ]), ) to_solders ( self ) Convert to solders AssignParams. Returns: Type Description ssp.AssignParams solders AssignParams Source code in solana/system_program.py def to_solders ( self ) -> ssp . AssignParams : \"\"\"Convert to `solders` AssignParams. Returns: `solders` AssignParams \"\"\" return ssp . AssignParams ( pubkey = self . account_pubkey . to_solders (), owner = self . program_id . to_solders (), ) AssignWithSeedParams Assign account with seed system transaction params. Source code in solana/system_program.py class AssignWithSeedParams ( NamedTuple ): \"\"\"Assign account with seed system transaction params.\"\"\" account_pubkey : PublicKey \"\"\"\"\"\" base_pubkey : PublicKey \"\"\"\"\"\" seed : str \"\"\"\"\"\" program_id : PublicKey \"\"\"\"\"\" @classmethod def from_solders ( cls , params : ssp . AssignWithSeedParams ) -> AssignWithSeedParams : \"\"\"Convert from `solders` AssignWithSeedParams. Args: params: `solders` AssignWithSeedParams Returns: `solana-py` AssignWithSeedParams \"\"\" return cls ( account_pubkey = PublicKey . from_solders ( params [ \"address\" ]), base_pubkey = PublicKey . from_solders ( params [ \"base\" ]), seed = params [ \"seed\" ], program_id = PublicKey . from_solders ( params [ \"owner\" ]), ) def to_solders ( self ) -> ssp . AssignWithSeedParams : \"\"\"Convert to `solders` AssignWithSeedParams. Returns: `solders` AssignWithSeedParams \"\"\" return ssp . AssignWithSeedParams ( address = self . account_pubkey . to_solders (), base = self . base_pubkey . to_solders (), seed = self . seed , owner = self . program_id . to_solders (), ) from_solders ( params ) classmethod Convert from solders AssignWithSeedParams. Parameters: Name Type Description Default params ssp.AssignWithSeedParams solders AssignWithSeedParams required Returns: Type Description AssignWithSeedParams solana-py AssignWithSeedParams Source code in solana/system_program.py @classmethod def from_solders ( cls , params : ssp . AssignWithSeedParams ) -> AssignWithSeedParams : \"\"\"Convert from `solders` AssignWithSeedParams. Args: params: `solders` AssignWithSeedParams Returns: `solana-py` AssignWithSeedParams \"\"\" return cls ( account_pubkey = PublicKey . from_solders ( params [ \"address\" ]), base_pubkey = PublicKey . from_solders ( params [ \"base\" ]), seed = params [ \"seed\" ], program_id = PublicKey . from_solders ( params [ \"owner\" ]), ) to_solders ( self ) Convert to solders AssignWithSeedParams. Returns: Type Description ssp.AssignWithSeedParams solders AssignWithSeedParams Source code in solana/system_program.py def to_solders ( self ) -> ssp . AssignWithSeedParams : \"\"\"Convert to `solders` AssignWithSeedParams. Returns: `solders` AssignWithSeedParams \"\"\" return ssp . AssignWithSeedParams ( address = self . account_pubkey . to_solders (), base = self . base_pubkey . to_solders (), seed = self . seed , owner = self . program_id . to_solders (), ) AuthorizeNonceParams Authorize nonce account system transaction params. Source code in solana/system_program.py class AuthorizeNonceParams ( NamedTuple ): \"\"\"Authorize nonce account system transaction params.\"\"\" nonce_pubkey : PublicKey \"\"\"\"\"\" authorized_pubkey : PublicKey \"\"\"\"\"\" new_authorized_pubkey : PublicKey \"\"\"\"\"\" @classmethod def from_solders ( cls , params : ssp . AuthorizeNonceAccountParams ) -> AuthorizeNonceParams : \"\"\"Convert from `solders` AuthorizeNonceParams. Args: params: `solders` AuthorizeNonceParams Returns: `solana-py` AuthorizeNonceParams \"\"\" return cls ( nonce_pubkey = PublicKey . from_solders ( params [ \"nonce_pubkey\" ]), authorized_pubkey = PublicKey . from_solders ( params [ \"authorized_pubkey\" ]), new_authorized_pubkey = PublicKey . from_solders ( params [ \"new_authority\" ]), ) def to_solders ( self ) -> ssp . AuthorizeNonceAccountParams : \"\"\"Convert to `solders` AuthorizeNonceParams. Returns: `solders` AuthorizeNonceParams \"\"\" return ssp . AuthorizeNonceAccountParams ( nonce_pubkey = self . nonce_pubkey . to_solders (), authorized_pubkey = self . authorized_pubkey . to_solders (), new_authority = self . new_authorized_pubkey . to_solders (), ) from_solders ( params ) classmethod Convert from solders AuthorizeNonceParams. Parameters: Name Type Description Default params ssp.AuthorizeNonceAccountParams solders AuthorizeNonceParams required Returns: Type Description AuthorizeNonceParams solana-py AuthorizeNonceParams Source code in solana/system_program.py @classmethod def from_solders ( cls , params : ssp . AuthorizeNonceAccountParams ) -> AuthorizeNonceParams : \"\"\"Convert from `solders` AuthorizeNonceParams. Args: params: `solders` AuthorizeNonceParams Returns: `solana-py` AuthorizeNonceParams \"\"\" return cls ( nonce_pubkey = PublicKey . from_solders ( params [ \"nonce_pubkey\" ]), authorized_pubkey = PublicKey . from_solders ( params [ \"authorized_pubkey\" ]), new_authorized_pubkey = PublicKey . from_solders ( params [ \"new_authority\" ]), ) to_solders ( self ) Convert to solders AuthorizeNonceParams. Returns: Type Description ssp.AuthorizeNonceAccountParams solders AuthorizeNonceParams Source code in solana/system_program.py def to_solders ( self ) -> ssp . AuthorizeNonceAccountParams : \"\"\"Convert to `solders` AuthorizeNonceParams. Returns: `solders` AuthorizeNonceParams \"\"\" return ssp . AuthorizeNonceAccountParams ( nonce_pubkey = self . nonce_pubkey . to_solders (), authorized_pubkey = self . authorized_pubkey . to_solders (), new_authority = self . new_authorized_pubkey . to_solders (), ) CreateAccountParams Create account system transaction params. Source code in solana/system_program.py class CreateAccountParams ( NamedTuple ): \"\"\"Create account system transaction params.\"\"\" from_pubkey : PublicKey \"\"\"\"\"\" new_account_pubkey : PublicKey \"\"\"\"\"\" lamports : int \"\"\"\"\"\" space : int \"\"\"\"\"\" program_id : PublicKey \"\"\"\"\"\" @classmethod def from_solders ( cls , params : ssp . CreateAccountParams ) -> CreateAccountParams : \"\"\"Convert from `solders` CreateAccountParams. Args: params: `solders` CreateAccountParams Returns: `solana-py` CreateAccountParams \"\"\" return cls ( from_pubkey = PublicKey . from_solders ( params [ \"from_pubkey\" ]), new_account_pubkey = PublicKey . from_solders ( params [ \"to_pubkey\" ]), lamports = params [ \"lamports\" ], space = params [ \"space\" ], program_id = PublicKey . from_solders ( params [ \"owner\" ]), ) def to_solders ( self ) -> ssp . CreateAccountParams : \"\"\"Convert to `solders` CreateAccountParams. Returns: `solders` CreateAccountParams \"\"\" return ssp . CreateAccountParams ( from_pubkey = self . from_pubkey . to_solders (), to_pubkey = self . new_account_pubkey . to_solders (), lamports = self . lamports , space = self . space , owner = self . program_id . to_solders (), ) from_solders ( params ) classmethod Convert from solders CreateAccountParams. Parameters: Name Type Description Default params ssp.CreateAccountParams solders CreateAccountParams required Returns: Type Description CreateAccountParams solana-py CreateAccountParams Source code in solana/system_program.py @classmethod def from_solders ( cls , params : ssp . CreateAccountParams ) -> CreateAccountParams : \"\"\"Convert from `solders` CreateAccountParams. Args: params: `solders` CreateAccountParams Returns: `solana-py` CreateAccountParams \"\"\" return cls ( from_pubkey = PublicKey . from_solders ( params [ \"from_pubkey\" ]), new_account_pubkey = PublicKey . from_solders ( params [ \"to_pubkey\" ]), lamports = params [ \"lamports\" ], space = params [ \"space\" ], program_id = PublicKey . from_solders ( params [ \"owner\" ]), ) to_solders ( self ) Convert to solders CreateAccountParams. Returns: Type Description ssp.CreateAccountParams solders CreateAccountParams Source code in solana/system_program.py def to_solders ( self ) -> ssp . CreateAccountParams : \"\"\"Convert to `solders` CreateAccountParams. Returns: `solders` CreateAccountParams \"\"\" return ssp . CreateAccountParams ( from_pubkey = self . from_pubkey . to_solders (), to_pubkey = self . new_account_pubkey . to_solders (), lamports = self . lamports , space = self . space , owner = self . program_id . to_solders (), ) CreateAccountWithSeedParams Create account with seed system transaction params. Source code in solana/system_program.py class CreateAccountWithSeedParams ( NamedTuple ): \"\"\"Create account with seed system transaction params.\"\"\" from_pubkey : PublicKey \"\"\"\"\"\" new_account_pubkey : PublicKey \"\"\"\"\"\" base_pubkey : PublicKey \"\"\"\"\"\" seed : str \"\"\"\"\"\" lamports : int \"\"\"\"\"\" space : int \"\"\"\"\"\" program_id : PublicKey \"\"\"\"\"\" @classmethod def from_solders ( cls , params : ssp . CreateAccountWithSeedParams ) -> CreateAccountWithSeedParams : \"\"\"Convert from `solders` CreateAccountWithSeedParams. Args: params: `solders` CreateAccountWithSeedParams Returns: `solana-py` CreateAccountWithSeedParams \"\"\" return cls ( from_pubkey = PublicKey . from_solders ( params [ \"from_pubkey\" ]), new_account_pubkey = PublicKey . from_solders ( params [ \"to_pubkey\" ]), base_pubkey = PublicKey . from_solders ( params [ \"base\" ]), seed = params [ \"seed\" ], lamports = params [ \"lamports\" ], space = params [ \"space\" ], program_id = PublicKey . from_solders ( params [ \"owner\" ]), ) def to_solders ( self ) -> ssp . CreateAccountWithSeedParams : \"\"\"Convert to `solders` CreateAccountWithSeedParams. Returns: `solders` CreateAccountWithSeedParams \"\"\" return ssp . CreateAccountWithSeedParams ( from_pubkey = self . from_pubkey . to_solders (), to_pubkey = self . new_account_pubkey . to_solders (), base = self . base_pubkey . to_solders (), seed = self . seed , lamports = self . lamports , space = self . space , owner = self . program_id . to_solders (), ) from_solders ( params ) classmethod Convert from solders CreateAccountWithSeedParams. Parameters: Name Type Description Default params ssp.CreateAccountWithSeedParams solders CreateAccountWithSeedParams required Returns: Type Description CreateAccountWithSeedParams solana-py CreateAccountWithSeedParams Source code in solana/system_program.py @classmethod def from_solders ( cls , params : ssp . CreateAccountWithSeedParams ) -> CreateAccountWithSeedParams : \"\"\"Convert from `solders` CreateAccountWithSeedParams. Args: params: `solders` CreateAccountWithSeedParams Returns: `solana-py` CreateAccountWithSeedParams \"\"\" return cls ( from_pubkey = PublicKey . from_solders ( params [ \"from_pubkey\" ]), new_account_pubkey = PublicKey . from_solders ( params [ \"to_pubkey\" ]), base_pubkey = PublicKey . from_solders ( params [ \"base\" ]), seed = params [ \"seed\" ], lamports = params [ \"lamports\" ], space = params [ \"space\" ], program_id = PublicKey . from_solders ( params [ \"owner\" ]), ) to_solders ( self ) Convert to solders CreateAccountWithSeedParams. Returns: Type Description ssp.CreateAccountWithSeedParams solders CreateAccountWithSeedParams Source code in solana/system_program.py def to_solders ( self ) -> ssp . CreateAccountWithSeedParams : \"\"\"Convert to `solders` CreateAccountWithSeedParams. Returns: `solders` CreateAccountWithSeedParams \"\"\" return ssp . CreateAccountWithSeedParams ( from_pubkey = self . from_pubkey . to_solders (), to_pubkey = self . new_account_pubkey . to_solders (), base = self . base_pubkey . to_solders (), seed = self . seed , lamports = self . lamports , space = self . space , owner = self . program_id . to_solders (), ) CreateNonceAccountParams Create nonce account system transaction params. Source code in solana/system_program.py class CreateNonceAccountParams ( NamedTuple ): \"\"\"Create nonce account system transaction params.\"\"\" from_pubkey : PublicKey \"\"\"\"\"\" nonce_pubkey : PublicKey \"\"\"\"\"\" authorized_pubkey : PublicKey \"\"\"\"\"\" lamports : int \"\"\"\"\"\" CreateNonceAccountWithSeedParams Create nonce account with seed system transaction params. Source code in solana/system_program.py class CreateNonceAccountWithSeedParams ( NamedTuple ): \"\"\"Create nonce account with seed system transaction params.\"\"\" from_pubkey : PublicKey \"\"\"\"\"\" nonce_pubkey : PublicKey \"\"\"\"\"\" authorized_pubkey : PublicKey \"\"\"\"\"\" lamports : int \"\"\"\"\"\" base_pubkey : PublicKey \"\"\"\"\"\" seed : str \"\"\"\"\"\" InitializeNonceParams Initialize nonce account system instruction params. Source code in solana/system_program.py class InitializeNonceParams ( NamedTuple ): \"\"\"Initialize nonce account system instruction params.\"\"\" nonce_pubkey : PublicKey \"\"\"\"\"\" authorized_pubkey : PublicKey \"\"\"\"\"\" @classmethod def from_solders ( cls , params : ssp . InitializeNonceAccountParams ) -> InitializeNonceParams : \"\"\"Convert from `solders` InitializeNonceParams. Args: params: `solders` InitializeNonceParams Returns: `solana-py` InitializeNonceParams \"\"\" return cls ( nonce_pubkey = PublicKey . from_solders ( params [ \"nonce_pubkey\" ]), authorized_pubkey = PublicKey . from_solders ( params [ \"authority\" ]), ) def to_solders ( self ) -> ssp . InitializeNonceAccountParams : \"\"\"Convert to `solders` InitializeNonceParams. Returns: `solders` InitializeNonceParams \"\"\" return ssp . InitializeNonceAccountParams ( nonce_pubkey = self . nonce_pubkey . to_solders (), authority = self . authorized_pubkey . to_solders (), ) from_solders ( params ) classmethod Convert from solders InitializeNonceParams. Parameters: Name Type Description Default params ssp.InitializeNonceAccountParams solders InitializeNonceParams required Returns: Type Description InitializeNonceParams solana-py InitializeNonceParams Source code in solana/system_program.py @classmethod def from_solders ( cls , params : ssp . InitializeNonceAccountParams ) -> InitializeNonceParams : \"\"\"Convert from `solders` InitializeNonceParams. Args: params: `solders` InitializeNonceParams Returns: `solana-py` InitializeNonceParams \"\"\" return cls ( nonce_pubkey = PublicKey . from_solders ( params [ \"nonce_pubkey\" ]), authorized_pubkey = PublicKey . from_solders ( params [ \"authority\" ]), ) to_solders ( self ) Convert to solders InitializeNonceParams. Returns: Type Description ssp.InitializeNonceAccountParams solders InitializeNonceParams Source code in solana/system_program.py def to_solders ( self ) -> ssp . InitializeNonceAccountParams : \"\"\"Convert to `solders` InitializeNonceParams. Returns: `solders` InitializeNonceParams \"\"\" return ssp . InitializeNonceAccountParams ( nonce_pubkey = self . nonce_pubkey . to_solders (), authority = self . authorized_pubkey . to_solders (), ) TransferParams Transfer system transaction params. Source code in solana/system_program.py class TransferParams ( NamedTuple ): \"\"\"Transfer system transaction params.\"\"\" from_pubkey : PublicKey \"\"\"\"\"\" to_pubkey : PublicKey \"\"\"\"\"\" lamports : int \"\"\"\"\"\" @classmethod def from_solders ( cls , params : ssp . TransferParams ) -> TransferParams : \"\"\"Convert from `solders` TransferParams. Args: params: `solders` TransferParams Returns: `solana-py` TransferParams \"\"\" return cls ( from_pubkey = PublicKey . from_solders ( params [ \"from_pubkey\" ]), to_pubkey = PublicKey . from_solders ( params [ \"to_pubkey\" ]), lamports = params [ \"lamports\" ], ) def to_solders ( self ) -> ssp . TransferParams : \"\"\"Convert to `solders` TransferParams. Returns: `solders` TransferParams \"\"\" return ssp . TransferParams ( from_pubkey = self . from_pubkey . to_solders (), to_pubkey = self . to_pubkey . to_solders (), lamports = self . lamports , ) from_solders ( params ) classmethod Convert from solders TransferParams. Parameters: Name Type Description Default params ssp.TransferParams solders TransferParams required Returns: Type Description TransferParams solana-py TransferParams Source code in solana/system_program.py @classmethod def from_solders ( cls , params : ssp . TransferParams ) -> TransferParams : \"\"\"Convert from `solders` TransferParams. Args: params: `solders` TransferParams Returns: `solana-py` TransferParams \"\"\" return cls ( from_pubkey = PublicKey . from_solders ( params [ \"from_pubkey\" ]), to_pubkey = PublicKey . from_solders ( params [ \"to_pubkey\" ]), lamports = params [ \"lamports\" ], ) to_solders ( self ) Convert to solders TransferParams. Returns: Type Description ssp.TransferParams solders TransferParams Source code in solana/system_program.py def to_solders ( self ) -> ssp . TransferParams : \"\"\"Convert to `solders` TransferParams. Returns: `solders` TransferParams \"\"\" return ssp . TransferParams ( from_pubkey = self . from_pubkey . to_solders (), to_pubkey = self . to_pubkey . to_solders (), lamports = self . lamports , ) WithdrawNonceParams Withdraw nonce account system transaction params. Source code in solana/system_program.py class WithdrawNonceParams ( NamedTuple ): \"\"\"Withdraw nonce account system transaction params.\"\"\" nonce_pubkey : PublicKey \"\"\"\"\"\" authorized_pubkey : PublicKey \"\"\"\"\"\" to_pubkey : PublicKey \"\"\"\"\"\" lamports : int \"\"\"\"\"\" @classmethod def from_solders ( cls , params : ssp . WithdrawNonceAccountParams ) -> WithdrawNonceParams : \"\"\"Convert from `solders` WithdrawNonceParams. Args: params: `solders` WithdrawNonceParams Returns: `solana-py` WithdrawNonceParams \"\"\" return cls ( nonce_pubkey = PublicKey . from_solders ( params [ \"nonce_pubkey\" ]), authorized_pubkey = PublicKey . from_solders ( params [ \"authorized_pubkey\" ]), to_pubkey = PublicKey . from_solders ( params [ \"to_pubkey\" ]), lamports = params [ \"lamports\" ], ) def to_solders ( self ) -> ssp . WithdrawNonceAccountParams : \"\"\"Convert to `solders` WithdrawNonceParams. Returns: `solders` WithdrawNonceParams \"\"\" return ssp . WithdrawNonceAccountParams ( nonce_pubkey = self . nonce_pubkey . to_solders (), authorized_pubkey = self . authorized_pubkey . to_solders (), to_pubkey = self . to_pubkey . to_solders (), lamports = self . lamports , ) from_solders ( params ) classmethod Convert from solders WithdrawNonceParams. Parameters: Name Type Description Default params ssp.WithdrawNonceAccountParams solders WithdrawNonceParams required Returns: Type Description WithdrawNonceParams solana-py WithdrawNonceParams Source code in solana/system_program.py @classmethod def from_solders ( cls , params : ssp . WithdrawNonceAccountParams ) -> WithdrawNonceParams : \"\"\"Convert from `solders` WithdrawNonceParams. Args: params: `solders` WithdrawNonceParams Returns: `solana-py` WithdrawNonceParams \"\"\" return cls ( nonce_pubkey = PublicKey . from_solders ( params [ \"nonce_pubkey\" ]), authorized_pubkey = PublicKey . from_solders ( params [ \"authorized_pubkey\" ]), to_pubkey = PublicKey . from_solders ( params [ \"to_pubkey\" ]), lamports = params [ \"lamports\" ], ) to_solders ( self ) Convert to solders WithdrawNonceParams. Returns: Type Description ssp.WithdrawNonceAccountParams solders WithdrawNonceParams Source code in solana/system_program.py def to_solders ( self ) -> ssp . WithdrawNonceAccountParams : \"\"\"Convert to `solders` WithdrawNonceParams. Returns: `solders` WithdrawNonceParams \"\"\" return ssp . WithdrawNonceAccountParams ( nonce_pubkey = self . nonce_pubkey . to_solders (), authorized_pubkey = self . authorized_pubkey . to_solders (), to_pubkey = self . to_pubkey . to_solders (), lamports = self . lamports , ) allocate ( params ) Generate an instruction that allocates space in an account without funding. Parameters: Name Type Description Default params Union[AllocateParams, AllocateWithSeedParams] The allocate params. required Examples: >>> from solana.publickey import PublicKey >>> allocator = PublicKey ( 1 ) >>> instruction = allocate ( ... AllocateParams ( account_pubkey = allocator , space = 65537 ) ... ) >>> type ( instruction ) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The allocate instruction. Source code in solana/system_program.py def allocate ( params : Union [ AllocateParams , AllocateWithSeedParams ]) -> TransactionInstruction : \"\"\"Generate an instruction that allocates space in an account without funding. Args: params: The allocate params. Example: >>> from solana.publickey import PublicKey >>> allocator = PublicKey(1) >>> instruction = allocate( ... AllocateParams(account_pubkey=allocator, space=65537) ... ) >>> type(instruction) <class 'solana.transaction.TransactionInstruction'> Returns: The allocate instruction. \"\"\" if isinstance ( params , AllocateWithSeedParams ): solders_ix = ssp . allocate_with_seed ( params . to_solders ()) else : solders_ix = ssp . allocate ( params . to_solders ()) return TransactionInstruction . from_solders ( solders_ix ) assign ( params ) Generate an instruction that assigns an account to a program. Parameters: Name Type Description Default params Union[AssignParams, AssignWithSeedParams] The assign params. required Examples: >>> from solana.publickey import PublicKey >>> account , program_id = PublicKey ( 1 ), PublicKey ( 2 ) >>> instruction = assign ( ... AssignParams ( account_pubkey = account , program_id = program_id ) ... ) >>> type ( instruction ) < class ' solana . transaction . TransactionInstruction '> Source code in solana/system_program.py def assign ( params : Union [ AssignParams , AssignWithSeedParams ]) -> TransactionInstruction : \"\"\"Generate an instruction that assigns an account to a program. Args: params: The assign params. Example: >>> from solana.publickey import PublicKey >>> account, program_id = PublicKey(1), PublicKey(2) >>> instruction = assign( ... AssignParams(account_pubkey=account, program_id=program_id) ... ) >>> type(instruction) <class 'solana.transaction.TransactionInstruction'> \"\"\" solders_ix = ( ssp . assign ( params . to_solders ()) if isinstance ( params , AssignParams ) else ssp . assign_with_seed ( params . to_solders ()) ) return TransactionInstruction . from_solders ( solders_ix ) create_account ( params ) Generate an instruction that creates a new account. Parameters: Name Type Description Default params CreateAccountParams The create account params. required Examples: >>> from solana.publickey import PublicKey >>> from_account , new_account , program_id = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ) >>> instruction = create_account ( ... CreateAccountParams ( ... from_pubkey = from_account , new_account_pubkey = new_account , ... lamports = 1 , space = 1 , program_id = program_id ) ... ) >>> type ( instruction ) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The instruction to create the account. Source code in solana/system_program.py def create_account ( params : CreateAccountParams ) -> TransactionInstruction : \"\"\"Generate an instruction that creates a new account. Args: params: The create account params. Example: >>> from solana.publickey import PublicKey >>> from_account, new_account, program_id = PublicKey(1), PublicKey(2), PublicKey(3) >>> instruction = create_account( ... CreateAccountParams( ... from_pubkey=from_account, new_account_pubkey=new_account, ... lamports=1, space=1, program_id=program_id) ... ) >>> type(instruction) <class 'solana.transaction.TransactionInstruction'> Returns: The instruction to create the account. \"\"\" return TransactionInstruction . from_solders ( ssp . create_account ( params . to_solders ())) create_account_with_seed ( params ) Generate a instruction that creates a new account at an address generated with from , a seed, and programId. Parameters: Name Type Description Default params CreateAccountWithSeedParams account creation params. required Returns: Type Description TransactionInstruction The instruction to create the account. Source code in solana/system_program.py def create_account_with_seed ( params : CreateAccountWithSeedParams , ) -> TransactionInstruction : \"\"\"Generate a instruction that creates a new account at an address generated with `from`, a seed, and programId. Args: params: account creation params. Returns: The instruction to create the account. \"\"\" return TransactionInstruction . from_solders ( ssp . create_account_with_seed ( params . to_solders ())) create_nonce_account ( params ) Generate a Transaction that creates a new Nonce account. Parameters: Name Type Description Default params Union[CreateNonceAccountParams, CreateNonceAccountWithSeedParams] The create nonce params. required Returns: Type Description Transaction The transaction to create the new nonce account. Source code in solana/system_program.py def create_nonce_account ( params : Union [ CreateNonceAccountParams , CreateNonceAccountWithSeedParams ]) -> Transaction : \"\"\"Generate a Transaction that creates a new Nonce account. Args: params: The create nonce params. Returns: The transaction to create the new nonce account. \"\"\" if isinstance ( params , CreateNonceAccountParams ): solders_ixs = ssp . create_nonce_account ( from_pubkey = params . from_pubkey . to_solders (), nonce_pubkey = params . nonce_pubkey . to_solders (), authority = params . authorized_pubkey . to_solders (), lamports = params . lamports , ) else : solders_ixs = ssp . create_nonce_account_with_seed ( from_pubkey = params . from_pubkey . to_solders (), nonce_pubkey = params . nonce_pubkey . to_solders (), base = params . base_pubkey . to_solders (), seed = params . seed , authority = params . authorized_pubkey . to_solders (), lamports = params . lamports , ) create_account_instruction = TransactionInstruction . from_solders ( solders_ixs [ 0 ]) initialize_nonce_instruction = TransactionInstruction . from_solders ( solders_ixs [ 1 ]) return Transaction ( fee_payer = params . from_pubkey ) . add ( create_account_instruction , initialize_nonce_instruction ) decode_allocate ( instruction ) Decode an allocate system instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Examples: >>> from solana.publickey import PublicKey >>> allocator = PublicKey ( 1 ) >>> instruction = allocate ( ... AllocateParams ( account_pubkey = allocator , space = 65537 ) ... ) >>> decode_allocate ( instruction ) AllocateParams ( account_pubkey = 11111111111111111111111111111112 , space = 65537 ) Returns: Type Description AllocateParams The decoded instruction params. Source code in solana/system_program.py def decode_allocate ( instruction : TransactionInstruction ) -> AllocateParams : \"\"\"Decode an allocate system instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Example: >>> from solana.publickey import PublicKey >>> allocator = PublicKey(1) >>> instruction = allocate( ... AllocateParams(account_pubkey=allocator,space=65537) ... ) >>> decode_allocate(instruction) AllocateParams(account_pubkey=11111111111111111111111111111112, space=65537) Returns: The decoded instruction params. \"\"\" # pylint: disable=line-too-long # noqa: E501 return AllocateParams . from_solders ( ssp . decode_allocate ( instruction . to_solders ())) decode_allocate_with_seed ( instruction ) Decode an allocate with seed system instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Examples: >>> from solana.publickey import PublicKey >>> allocator , base , program_id = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ) >>> instruction = allocate ( ... AllocateWithSeedParams ( ... account_pubkey = allocator , ... base_pubkey = base , ... seed = \"gqln\" , ... space = 65537 , ... program_id = program_id ... ) ... ) >>> decode_allocate_with_seed ( instruction ) AllocateWithSeedParams ( account_pubkey = 11111111111111111111111111111112 , base_pubkey = 11111111111111111111111111111113 , seed = 'gqln' , space = 65537 , program_id = 11111111111111111111111111111114 ) Returns: Type Description AllocateWithSeedParams The decoded instruction params. Source code in solana/system_program.py def decode_allocate_with_seed ( instruction : TransactionInstruction ) -> AllocateWithSeedParams : \"\"\"Decode an allocate with seed system instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Example: >>> from solana.publickey import PublicKey >>> allocator, base, program_id = PublicKey(1), PublicKey(2), PublicKey(3) >>> instruction = allocate( ... AllocateWithSeedParams( ... account_pubkey=allocator, ... base_pubkey=base, ... seed=\"gqln\", ... space=65537, ... program_id=program_id ... ) ... ) >>> decode_allocate_with_seed(instruction) AllocateWithSeedParams(account_pubkey=11111111111111111111111111111112, base_pubkey=11111111111111111111111111111113, seed='gqln', space=65537, program_id=11111111111111111111111111111114) Returns: The decoded instruction params. \"\"\" # pylint: disable=line-too-long # noqa: E501 return AllocateWithSeedParams . from_solders ( ssp . decode_allocate_with_seed ( instruction . to_solders ())) decode_assign ( instruction ) Decode an assign system instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Examples: >>> from solana.publickey import PublicKey >>> account , program_id = PublicKey ( 1 ), PublicKey ( 2 ) >>> instruction = assign ( ... AssignParams ( account_pubkey = account , program_id = program_id ) ... ) >>> decode_assign ( instruction ) AssignParams ( account_pubkey = 11111111111111111111111111111112 , program_id = 11111111111111111111111111111113 ) Returns: Type Description AssignParams The decoded instruction params. Source code in solana/system_program.py def decode_assign ( instruction : TransactionInstruction ) -> AssignParams : \"\"\"Decode an assign system instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Example: >>> from solana.publickey import PublicKey >>> account, program_id = PublicKey(1), PublicKey(2) >>> instruction = assign( ... AssignParams(account_pubkey=account, program_id=program_id) ... ) >>> decode_assign(instruction) AssignParams(account_pubkey=11111111111111111111111111111112, program_id=11111111111111111111111111111113) Returns: The decoded instruction params. \"\"\" return AssignParams . from_solders ( ssp . decode_assign ( instruction . to_solders ())) decode_assign_with_seed ( instruction ) Decode an assign system with seed instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description AssignWithSeedParams The decoded instruction params. Source code in solana/system_program.py def decode_assign_with_seed ( instruction : TransactionInstruction ) -> AssignWithSeedParams : \"\"\"Decode an assign system with seed instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction params. \"\"\" return AssignWithSeedParams . from_solders ( ssp . decode_assign_with_seed ( instruction . to_solders ())) decode_create_account ( instruction ) Decode a create account system instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Examples: >>> from solana.publickey import PublicKey >>> from_account , new_account , program_id = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ) >>> instruction = create_account ( ... CreateAccountParams ( ... from_pubkey = from_account , new_account_pubkey = new_account , ... lamports = 1 , space = 1 , program_id = program_id ) ... ) >>> decode_create_account ( instruction ) CreateAccountParams ( from_pubkey = 11111111111111111111111111111112 , new_account_pubkey = 11111111111111111111111111111113 , lamports = 1 , space = 1 , program_id = 11111111111111111111111111111114 ) Returns: Type Description CreateAccountParams The decoded instruction params. Source code in solana/system_program.py def decode_create_account ( instruction : TransactionInstruction ) -> CreateAccountParams : \"\"\"Decode a create account system instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Example: >>> from solana.publickey import PublicKey >>> from_account, new_account, program_id = PublicKey(1), PublicKey(2), PublicKey(3) >>> instruction = create_account( ... CreateAccountParams( ... from_pubkey=from_account, new_account_pubkey=new_account, ... lamports=1, space=1, program_id=program_id) ... ) >>> decode_create_account(instruction) CreateAccountParams(from_pubkey=11111111111111111111111111111112, new_account_pubkey=11111111111111111111111111111113, lamports=1, space=1, program_id=11111111111111111111111111111114) Returns: The decoded instruction params. \"\"\" # noqa: E501 # pylint: disable=line-too-long return CreateAccountParams . from_solders ( ssp . decode_create_account ( instruction . to_solders ())) decode_create_account_with_seed ( instruction ) Decode a create account with seed system instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description CreateAccountWithSeedParams The decoded instruction params. Source code in solana/system_program.py def decode_create_account_with_seed ( instruction : TransactionInstruction ) -> CreateAccountWithSeedParams : \"\"\"Decode a create account with seed system instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction params. \"\"\" return CreateAccountWithSeedParams . from_solders ( ssp . decode_create_account_with_seed ( instruction . to_solders ())) decode_nonce_advance ( instruction ) Decode a nonce advance system instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description AdvanceNonceParams The decoded instruction params. Source code in solana/system_program.py def decode_nonce_advance ( instruction : TransactionInstruction ) -> AdvanceNonceParams : \"\"\"Decode a nonce advance system instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction params. \"\"\" return AdvanceNonceParams . from_solders ( ssp . decode_advance_nonce_account ( instruction . to_solders ())) decode_nonce_authorize ( instruction ) Decode a nonce authorize system instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description AuthorizeNonceParams The decoded instruction params. Source code in solana/system_program.py def decode_nonce_authorize ( instruction : TransactionInstruction ) -> AuthorizeNonceParams : \"\"\"Decode a nonce authorize system instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction params. \"\"\" return AuthorizeNonceParams . from_solders ( ssp . decode_authorize_nonce_account ( instruction . to_solders ())) decode_nonce_initialize ( instruction ) Decode a nonce initialize system instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description InitializeNonceParams The decoded instruction params. Source code in solana/system_program.py def decode_nonce_initialize ( instruction : TransactionInstruction ) -> InitializeNonceParams : \"\"\"Decode a nonce initialize system instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction params. \"\"\" return InitializeNonceParams . from_solders ( ssp . decode_initialize_nonce_account ( instruction . to_solders ())) decode_nonce_withdraw ( instruction ) Decode a nonce withdraw system instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description WithdrawNonceParams The decoded instruction params. Source code in solana/system_program.py def decode_nonce_withdraw ( instruction : TransactionInstruction ) -> WithdrawNonceParams : \"\"\"Decode a nonce withdraw system instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction params. \"\"\" return WithdrawNonceParams . from_solders ( ssp . decode_withdraw_nonce_account ( instruction . to_solders ())) decode_transfer ( instruction ) Decode a transfer system instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Examples: >>> from solana.publickey import PublicKey >>> sender , receiver = PublicKey ( 1 ), PublicKey ( 2 ) >>> instruction = transfer ( ... TransferParams ( from_pubkey = sender , to_pubkey = receiver , lamports = 1000 ) ... ) >>> decode_transfer ( instruction ) TransferParams ( from_pubkey = 11111111111111111111111111111112 , to_pubkey = 11111111111111111111111111111113 , lamports = 1000 ) Returns: Type Description TransferParams The decoded instruction params. Source code in solana/system_program.py def decode_transfer ( instruction : TransactionInstruction ) -> TransferParams : \"\"\"Decode a transfer system instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Example: >>> from solana.publickey import PublicKey >>> sender, receiver = PublicKey(1), PublicKey(2) >>> instruction = transfer( ... TransferParams(from_pubkey=sender, to_pubkey=receiver, lamports=1000) ... ) >>> decode_transfer(instruction) TransferParams(from_pubkey=11111111111111111111111111111112, to_pubkey=11111111111111111111111111111113, lamports=1000) Returns: The decoded instruction params. \"\"\" # pylint: disable=line-too-long # noqa: E501 return TransferParams . from_solders ( ssp . decode_transfer ( instruction . to_solders ())) nonce_advance ( params ) Generate an instruction to advance the nonce in a Nonce account. Parameters: Name Type Description Default params AdvanceNonceParams The advance nonce params required Returns: Type Description TransactionInstruction The instruction to advance the nonce. Source code in solana/system_program.py def nonce_advance ( params : AdvanceNonceParams ) -> TransactionInstruction : \"\"\"Generate an instruction to advance the nonce in a Nonce account. Args: params: The advance nonce params Returns: The instruction to advance the nonce. \"\"\" return TransactionInstruction . from_solders ( ssp . advance_nonce_account ( params . to_solders ())) nonce_authorize ( params ) Generate an instruction that authorizes a new PublicKey as the authority on a Nonce account. Parameters: Name Type Description Default params AuthorizeNonceParams The authorize nonce params required Returns: Type Description TransactionInstruction The instruction to grant the new nonce authority. Source code in solana/system_program.py def nonce_authorize ( params : AuthorizeNonceParams ) -> TransactionInstruction : \"\"\"Generate an instruction that authorizes a new PublicKey as the authority on a Nonce account. Args: params: The authorize nonce params Returns: The instruction to grant the new nonce authority. \"\"\" return TransactionInstruction . from_solders ( ssp . authorize_nonce_account ( params . to_solders ())) nonce_initialization ( params ) Generate an instruction to initialize a Nonce account. Parameters: Name Type Description Default params InitializeNonceParams The nonce initialization params. required Returns: Type Description TransactionInstruction The instruction to initialize the nonce account. Source code in solana/system_program.py def nonce_initialization ( params : InitializeNonceParams ) -> TransactionInstruction : \"\"\"Generate an instruction to initialize a Nonce account. Args: params: The nonce initialization params. Returns: The instruction to initialize the nonce account. \"\"\" return TransactionInstruction . from_solders ( ssp . initialize_nonce_account ( params . to_solders ())) nonce_withdraw ( params ) Generate an instruction that withdraws lamports from a Nonce account. Parameters: Name Type Description Default params WithdrawNonceParams The withdraw nonce params required Returns: Type Description TransactionInstruction The instruction to withdraw from the nonce account. Source code in solana/system_program.py def nonce_withdraw ( params : WithdrawNonceParams ) -> TransactionInstruction : \"\"\"Generate an instruction that withdraws lamports from a Nonce account. Args: params: The withdraw nonce params Returns: The instruction to withdraw from the nonce account. \"\"\" return TransactionInstruction . from_solders ( ssp . withdraw_nonce_account ( params . to_solders ())) transfer ( params ) Generate an instruction that transfers lamports from one account to another. Parameters: Name Type Description Default params TransferParams The transfer params. required Examples: >>> from solana.publickey import PublicKey >>> sender , receiver = PublicKey ( 1 ), PublicKey ( 2 ) >>> instruction = transfer ( ... TransferParams ( from_pubkey = sender , to_pubkey = receiver , lamports = 1000 ) ... ) >>> type ( instruction ) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The transfer instruction. Source code in solana/system_program.py def transfer ( params : TransferParams ) -> TransactionInstruction : \"\"\"Generate an instruction that transfers lamports from one account to another. Args: params: The transfer params. Example: >>> from solana.publickey import PublicKey >>> sender, receiver = PublicKey(1), PublicKey(2) >>> instruction = transfer( ... TransferParams(from_pubkey=sender, to_pubkey=receiver, lamports=1000) ... ) >>> type(instruction) <class 'solana.transaction.TransactionInstruction'> Returns: The transfer instruction. \"\"\" return TransactionInstruction . from_solders ( ssp . transfer ( params . to_solders ()))","title":"System Program"},{"location":"core/system_program/#system-program","text":"","title":"System Program"},{"location":"core/system_program/#solana.system_program","text":"Library to interface with the system program.","title":"system_program"},{"location":"core/system_program/#solana.system_program.SYS_PROGRAM_ID","text":"Public key that identifies the System program.","title":"SYS_PROGRAM_ID"},{"location":"core/system_program/#solana.system_program.AdvanceNonceParams","text":"Advance nonce account system instruction params. Source code in solana/system_program.py class AdvanceNonceParams ( NamedTuple ): \"\"\"Advance nonce account system instruction params.\"\"\" nonce_pubkey : PublicKey \"\"\"\"\"\" authorized_pubkey : PublicKey \"\"\"\"\"\" @classmethod def from_solders ( cls , params : ssp . AdvanceNonceAccountParams ) -> AdvanceNonceParams : \"\"\"Convert from `solders` AdvanceNonceParams. Args: params: `solders` AdvanceNonceParams Returns: `solana-py` AdvanceNonceParams \"\"\" return cls ( nonce_pubkey = PublicKey . from_solders ( params [ \"nonce_pubkey\" ]), authorized_pubkey = PublicKey . from_solders ( params [ \"authorized_pubkey\" ]), ) def to_solders ( self ) -> ssp . AdvanceNonceAccountParams : \"\"\"Convert to `solders` AdvanceNonceParams. Returns: `solders` AdvanceNonceParams \"\"\" return ssp . AdvanceNonceAccountParams ( nonce_pubkey = self . nonce_pubkey . to_solders (), authorized_pubkey = self . authorized_pubkey . to_solders (), )","title":"AdvanceNonceParams"},{"location":"core/system_program/#solana.system_program.AdvanceNonceParams.from_solders","text":"Convert from solders AdvanceNonceParams. Parameters: Name Type Description Default params ssp.AdvanceNonceAccountParams solders AdvanceNonceParams required Returns: Type Description AdvanceNonceParams solana-py AdvanceNonceParams Source code in solana/system_program.py @classmethod def from_solders ( cls , params : ssp . AdvanceNonceAccountParams ) -> AdvanceNonceParams : \"\"\"Convert from `solders` AdvanceNonceParams. Args: params: `solders` AdvanceNonceParams Returns: `solana-py` AdvanceNonceParams \"\"\" return cls ( nonce_pubkey = PublicKey . from_solders ( params [ \"nonce_pubkey\" ]), authorized_pubkey = PublicKey . from_solders ( params [ \"authorized_pubkey\" ]), )","title":"from_solders()"},{"location":"core/system_program/#solana.system_program.AdvanceNonceParams.to_solders","text":"Convert to solders AdvanceNonceParams. Returns: Type Description ssp.AdvanceNonceAccountParams solders AdvanceNonceParams Source code in solana/system_program.py def to_solders ( self ) -> ssp . AdvanceNonceAccountParams : \"\"\"Convert to `solders` AdvanceNonceParams. Returns: `solders` AdvanceNonceParams \"\"\" return ssp . AdvanceNonceAccountParams ( nonce_pubkey = self . nonce_pubkey . to_solders (), authorized_pubkey = self . authorized_pubkey . to_solders (), )","title":"to_solders()"},{"location":"core/system_program/#solana.system_program.AllocateParams","text":"Allocate account with seed system transaction params. Source code in solana/system_program.py class AllocateParams ( NamedTuple ): \"\"\"Allocate account with seed system transaction params.\"\"\" account_pubkey : PublicKey \"\"\"\"\"\" space : int \"\"\"\"\"\" @classmethod def from_solders ( cls , params : ssp . AllocateParams ) -> AllocateParams : \"\"\"Convert from `solders` AllocateParams. Args: params: `solders` AllocateParams Returns: `solana-py` AllocateParams \"\"\" return cls ( account_pubkey = PublicKey . from_solders ( params [ \"pubkey\" ]), space = params [ \"space\" ], ) def to_solders ( self ) -> ssp . AllocateParams : \"\"\"Convert to `solders` AllocateParams. Returns: `solders` AllocateParams \"\"\" return ssp . AllocateParams ( pubkey = self . account_pubkey . to_solders (), space = self . space , )","title":"AllocateParams"},{"location":"core/system_program/#solana.system_program.AllocateParams.from_solders","text":"Convert from solders AllocateParams. Parameters: Name Type Description Default params ssp.AllocateParams solders AllocateParams required Returns: Type Description AllocateParams solana-py AllocateParams Source code in solana/system_program.py @classmethod def from_solders ( cls , params : ssp . AllocateParams ) -> AllocateParams : \"\"\"Convert from `solders` AllocateParams. Args: params: `solders` AllocateParams Returns: `solana-py` AllocateParams \"\"\" return cls ( account_pubkey = PublicKey . from_solders ( params [ \"pubkey\" ]), space = params [ \"space\" ], )","title":"from_solders()"},{"location":"core/system_program/#solana.system_program.AllocateParams.to_solders","text":"Convert to solders AllocateParams. Returns: Type Description ssp.AllocateParams solders AllocateParams Source code in solana/system_program.py def to_solders ( self ) -> ssp . AllocateParams : \"\"\"Convert to `solders` AllocateParams. Returns: `solders` AllocateParams \"\"\" return ssp . AllocateParams ( pubkey = self . account_pubkey . to_solders (), space = self . space , )","title":"to_solders()"},{"location":"core/system_program/#solana.system_program.AllocateWithSeedParams","text":"Allocate account with seed system transaction params. Source code in solana/system_program.py class AllocateWithSeedParams ( NamedTuple ): \"\"\"Allocate account with seed system transaction params.\"\"\" account_pubkey : PublicKey \"\"\"\"\"\" base_pubkey : PublicKey \"\"\"\"\"\" seed : str \"\"\"\"\"\" space : int \"\"\"\"\"\" program_id : PublicKey \"\"\"\"\"\" @classmethod def from_solders ( cls , params : ssp . AllocateWithSeedParams ) -> AllocateWithSeedParams : \"\"\"Convert from `solders` AllocateWithSeedParams. Args: params: `solders` AllocateWithSeedParams Returns: `solana-py` AllocateWithSeedParams \"\"\" return cls ( account_pubkey = PublicKey . from_solders ( params [ \"address\" ]), base_pubkey = PublicKey . from_solders ( params [ \"base\" ]), seed = params [ \"seed\" ], space = params [ \"space\" ], program_id = PublicKey . from_solders ( params [ \"owner\" ]), ) def to_solders ( self ) -> ssp . AllocateWithSeedParams : \"\"\"Convert to `solders` AllocateWithSeedParams. Returns: `solders` AllocateWithSeedParams \"\"\" return ssp . AllocateWithSeedParams ( address = self . account_pubkey . to_solders (), base = self . base_pubkey . to_solders (), seed = self . seed , space = self . space , owner = self . program_id . to_solders (), )","title":"AllocateWithSeedParams"},{"location":"core/system_program/#solana.system_program.AllocateWithSeedParams.from_solders","text":"Convert from solders AllocateWithSeedParams. Parameters: Name Type Description Default params ssp.AllocateWithSeedParams solders AllocateWithSeedParams required Returns: Type Description AllocateWithSeedParams solana-py AllocateWithSeedParams Source code in solana/system_program.py @classmethod def from_solders ( cls , params : ssp . AllocateWithSeedParams ) -> AllocateWithSeedParams : \"\"\"Convert from `solders` AllocateWithSeedParams. Args: params: `solders` AllocateWithSeedParams Returns: `solana-py` AllocateWithSeedParams \"\"\" return cls ( account_pubkey = PublicKey . from_solders ( params [ \"address\" ]), base_pubkey = PublicKey . from_solders ( params [ \"base\" ]), seed = params [ \"seed\" ], space = params [ \"space\" ], program_id = PublicKey . from_solders ( params [ \"owner\" ]), )","title":"from_solders()"},{"location":"core/system_program/#solana.system_program.AllocateWithSeedParams.to_solders","text":"Convert to solders AllocateWithSeedParams. Returns: Type Description ssp.AllocateWithSeedParams solders AllocateWithSeedParams Source code in solana/system_program.py def to_solders ( self ) -> ssp . AllocateWithSeedParams : \"\"\"Convert to `solders` AllocateWithSeedParams. Returns: `solders` AllocateWithSeedParams \"\"\" return ssp . AllocateWithSeedParams ( address = self . account_pubkey . to_solders (), base = self . base_pubkey . to_solders (), seed = self . seed , space = self . space , owner = self . program_id . to_solders (), )","title":"to_solders()"},{"location":"core/system_program/#solana.system_program.AssignParams","text":"Assign system transaction params. Source code in solana/system_program.py class AssignParams ( NamedTuple ): \"\"\"Assign system transaction params.\"\"\" account_pubkey : PublicKey \"\"\"\"\"\" program_id : PublicKey \"\"\"\"\"\" @classmethod def from_solders ( cls , params : ssp . AssignParams ) -> AssignParams : \"\"\"Convert from `solders` AssignParams. Args: params: `solders` AssignParams Returns: `solana-py` AssignParams \"\"\" return cls ( account_pubkey = PublicKey . from_solders ( params [ \"pubkey\" ]), program_id = PublicKey . from_solders ( params [ \"owner\" ]), ) def to_solders ( self ) -> ssp . AssignParams : \"\"\"Convert to `solders` AssignParams. Returns: `solders` AssignParams \"\"\" return ssp . AssignParams ( pubkey = self . account_pubkey . to_solders (), owner = self . program_id . to_solders (), )","title":"AssignParams"},{"location":"core/system_program/#solana.system_program.AssignParams.from_solders","text":"Convert from solders AssignParams. Parameters: Name Type Description Default params ssp.AssignParams solders AssignParams required Returns: Type Description AssignParams solana-py AssignParams Source code in solana/system_program.py @classmethod def from_solders ( cls , params : ssp . AssignParams ) -> AssignParams : \"\"\"Convert from `solders` AssignParams. Args: params: `solders` AssignParams Returns: `solana-py` AssignParams \"\"\" return cls ( account_pubkey = PublicKey . from_solders ( params [ \"pubkey\" ]), program_id = PublicKey . from_solders ( params [ \"owner\" ]), )","title":"from_solders()"},{"location":"core/system_program/#solana.system_program.AssignParams.to_solders","text":"Convert to solders AssignParams. Returns: Type Description ssp.AssignParams solders AssignParams Source code in solana/system_program.py def to_solders ( self ) -> ssp . AssignParams : \"\"\"Convert to `solders` AssignParams. Returns: `solders` AssignParams \"\"\" return ssp . AssignParams ( pubkey = self . account_pubkey . to_solders (), owner = self . program_id . to_solders (), )","title":"to_solders()"},{"location":"core/system_program/#solana.system_program.AssignWithSeedParams","text":"Assign account with seed system transaction params. Source code in solana/system_program.py class AssignWithSeedParams ( NamedTuple ): \"\"\"Assign account with seed system transaction params.\"\"\" account_pubkey : PublicKey \"\"\"\"\"\" base_pubkey : PublicKey \"\"\"\"\"\" seed : str \"\"\"\"\"\" program_id : PublicKey \"\"\"\"\"\" @classmethod def from_solders ( cls , params : ssp . AssignWithSeedParams ) -> AssignWithSeedParams : \"\"\"Convert from `solders` AssignWithSeedParams. Args: params: `solders` AssignWithSeedParams Returns: `solana-py` AssignWithSeedParams \"\"\" return cls ( account_pubkey = PublicKey . from_solders ( params [ \"address\" ]), base_pubkey = PublicKey . from_solders ( params [ \"base\" ]), seed = params [ \"seed\" ], program_id = PublicKey . from_solders ( params [ \"owner\" ]), ) def to_solders ( self ) -> ssp . AssignWithSeedParams : \"\"\"Convert to `solders` AssignWithSeedParams. Returns: `solders` AssignWithSeedParams \"\"\" return ssp . AssignWithSeedParams ( address = self . account_pubkey . to_solders (), base = self . base_pubkey . to_solders (), seed = self . seed , owner = self . program_id . to_solders (), )","title":"AssignWithSeedParams"},{"location":"core/system_program/#solana.system_program.AssignWithSeedParams.from_solders","text":"Convert from solders AssignWithSeedParams. Parameters: Name Type Description Default params ssp.AssignWithSeedParams solders AssignWithSeedParams required Returns: Type Description AssignWithSeedParams solana-py AssignWithSeedParams Source code in solana/system_program.py @classmethod def from_solders ( cls , params : ssp . AssignWithSeedParams ) -> AssignWithSeedParams : \"\"\"Convert from `solders` AssignWithSeedParams. Args: params: `solders` AssignWithSeedParams Returns: `solana-py` AssignWithSeedParams \"\"\" return cls ( account_pubkey = PublicKey . from_solders ( params [ \"address\" ]), base_pubkey = PublicKey . from_solders ( params [ \"base\" ]), seed = params [ \"seed\" ], program_id = PublicKey . from_solders ( params [ \"owner\" ]), )","title":"from_solders()"},{"location":"core/system_program/#solana.system_program.AssignWithSeedParams.to_solders","text":"Convert to solders AssignWithSeedParams. Returns: Type Description ssp.AssignWithSeedParams solders AssignWithSeedParams Source code in solana/system_program.py def to_solders ( self ) -> ssp . AssignWithSeedParams : \"\"\"Convert to `solders` AssignWithSeedParams. Returns: `solders` AssignWithSeedParams \"\"\" return ssp . AssignWithSeedParams ( address = self . account_pubkey . to_solders (), base = self . base_pubkey . to_solders (), seed = self . seed , owner = self . program_id . to_solders (), )","title":"to_solders()"},{"location":"core/system_program/#solana.system_program.AuthorizeNonceParams","text":"Authorize nonce account system transaction params. Source code in solana/system_program.py class AuthorizeNonceParams ( NamedTuple ): \"\"\"Authorize nonce account system transaction params.\"\"\" nonce_pubkey : PublicKey \"\"\"\"\"\" authorized_pubkey : PublicKey \"\"\"\"\"\" new_authorized_pubkey : PublicKey \"\"\"\"\"\" @classmethod def from_solders ( cls , params : ssp . AuthorizeNonceAccountParams ) -> AuthorizeNonceParams : \"\"\"Convert from `solders` AuthorizeNonceParams. Args: params: `solders` AuthorizeNonceParams Returns: `solana-py` AuthorizeNonceParams \"\"\" return cls ( nonce_pubkey = PublicKey . from_solders ( params [ \"nonce_pubkey\" ]), authorized_pubkey = PublicKey . from_solders ( params [ \"authorized_pubkey\" ]), new_authorized_pubkey = PublicKey . from_solders ( params [ \"new_authority\" ]), ) def to_solders ( self ) -> ssp . AuthorizeNonceAccountParams : \"\"\"Convert to `solders` AuthorizeNonceParams. Returns: `solders` AuthorizeNonceParams \"\"\" return ssp . AuthorizeNonceAccountParams ( nonce_pubkey = self . nonce_pubkey . to_solders (), authorized_pubkey = self . authorized_pubkey . to_solders (), new_authority = self . new_authorized_pubkey . to_solders (), )","title":"AuthorizeNonceParams"},{"location":"core/system_program/#solana.system_program.AuthorizeNonceParams.from_solders","text":"Convert from solders AuthorizeNonceParams. Parameters: Name Type Description Default params ssp.AuthorizeNonceAccountParams solders AuthorizeNonceParams required Returns: Type Description AuthorizeNonceParams solana-py AuthorizeNonceParams Source code in solana/system_program.py @classmethod def from_solders ( cls , params : ssp . AuthorizeNonceAccountParams ) -> AuthorizeNonceParams : \"\"\"Convert from `solders` AuthorizeNonceParams. Args: params: `solders` AuthorizeNonceParams Returns: `solana-py` AuthorizeNonceParams \"\"\" return cls ( nonce_pubkey = PublicKey . from_solders ( params [ \"nonce_pubkey\" ]), authorized_pubkey = PublicKey . from_solders ( params [ \"authorized_pubkey\" ]), new_authorized_pubkey = PublicKey . from_solders ( params [ \"new_authority\" ]), )","title":"from_solders()"},{"location":"core/system_program/#solana.system_program.AuthorizeNonceParams.to_solders","text":"Convert to solders AuthorizeNonceParams. Returns: Type Description ssp.AuthorizeNonceAccountParams solders AuthorizeNonceParams Source code in solana/system_program.py def to_solders ( self ) -> ssp . AuthorizeNonceAccountParams : \"\"\"Convert to `solders` AuthorizeNonceParams. Returns: `solders` AuthorizeNonceParams \"\"\" return ssp . AuthorizeNonceAccountParams ( nonce_pubkey = self . nonce_pubkey . to_solders (), authorized_pubkey = self . authorized_pubkey . to_solders (), new_authority = self . new_authorized_pubkey . to_solders (), )","title":"to_solders()"},{"location":"core/system_program/#solana.system_program.CreateAccountParams","text":"Create account system transaction params. Source code in solana/system_program.py class CreateAccountParams ( NamedTuple ): \"\"\"Create account system transaction params.\"\"\" from_pubkey : PublicKey \"\"\"\"\"\" new_account_pubkey : PublicKey \"\"\"\"\"\" lamports : int \"\"\"\"\"\" space : int \"\"\"\"\"\" program_id : PublicKey \"\"\"\"\"\" @classmethod def from_solders ( cls , params : ssp . CreateAccountParams ) -> CreateAccountParams : \"\"\"Convert from `solders` CreateAccountParams. Args: params: `solders` CreateAccountParams Returns: `solana-py` CreateAccountParams \"\"\" return cls ( from_pubkey = PublicKey . from_solders ( params [ \"from_pubkey\" ]), new_account_pubkey = PublicKey . from_solders ( params [ \"to_pubkey\" ]), lamports = params [ \"lamports\" ], space = params [ \"space\" ], program_id = PublicKey . from_solders ( params [ \"owner\" ]), ) def to_solders ( self ) -> ssp . CreateAccountParams : \"\"\"Convert to `solders` CreateAccountParams. Returns: `solders` CreateAccountParams \"\"\" return ssp . CreateAccountParams ( from_pubkey = self . from_pubkey . to_solders (), to_pubkey = self . new_account_pubkey . to_solders (), lamports = self . lamports , space = self . space , owner = self . program_id . to_solders (), )","title":"CreateAccountParams"},{"location":"core/system_program/#solana.system_program.CreateAccountParams.from_solders","text":"Convert from solders CreateAccountParams. Parameters: Name Type Description Default params ssp.CreateAccountParams solders CreateAccountParams required Returns: Type Description CreateAccountParams solana-py CreateAccountParams Source code in solana/system_program.py @classmethod def from_solders ( cls , params : ssp . CreateAccountParams ) -> CreateAccountParams : \"\"\"Convert from `solders` CreateAccountParams. Args: params: `solders` CreateAccountParams Returns: `solana-py` CreateAccountParams \"\"\" return cls ( from_pubkey = PublicKey . from_solders ( params [ \"from_pubkey\" ]), new_account_pubkey = PublicKey . from_solders ( params [ \"to_pubkey\" ]), lamports = params [ \"lamports\" ], space = params [ \"space\" ], program_id = PublicKey . from_solders ( params [ \"owner\" ]), )","title":"from_solders()"},{"location":"core/system_program/#solana.system_program.CreateAccountParams.to_solders","text":"Convert to solders CreateAccountParams. Returns: Type Description ssp.CreateAccountParams solders CreateAccountParams Source code in solana/system_program.py def to_solders ( self ) -> ssp . CreateAccountParams : \"\"\"Convert to `solders` CreateAccountParams. Returns: `solders` CreateAccountParams \"\"\" return ssp . CreateAccountParams ( from_pubkey = self . from_pubkey . to_solders (), to_pubkey = self . new_account_pubkey . to_solders (), lamports = self . lamports , space = self . space , owner = self . program_id . to_solders (), )","title":"to_solders()"},{"location":"core/system_program/#solana.system_program.CreateAccountWithSeedParams","text":"Create account with seed system transaction params. Source code in solana/system_program.py class CreateAccountWithSeedParams ( NamedTuple ): \"\"\"Create account with seed system transaction params.\"\"\" from_pubkey : PublicKey \"\"\"\"\"\" new_account_pubkey : PublicKey \"\"\"\"\"\" base_pubkey : PublicKey \"\"\"\"\"\" seed : str \"\"\"\"\"\" lamports : int \"\"\"\"\"\" space : int \"\"\"\"\"\" program_id : PublicKey \"\"\"\"\"\" @classmethod def from_solders ( cls , params : ssp . CreateAccountWithSeedParams ) -> CreateAccountWithSeedParams : \"\"\"Convert from `solders` CreateAccountWithSeedParams. Args: params: `solders` CreateAccountWithSeedParams Returns: `solana-py` CreateAccountWithSeedParams \"\"\" return cls ( from_pubkey = PublicKey . from_solders ( params [ \"from_pubkey\" ]), new_account_pubkey = PublicKey . from_solders ( params [ \"to_pubkey\" ]), base_pubkey = PublicKey . from_solders ( params [ \"base\" ]), seed = params [ \"seed\" ], lamports = params [ \"lamports\" ], space = params [ \"space\" ], program_id = PublicKey . from_solders ( params [ \"owner\" ]), ) def to_solders ( self ) -> ssp . CreateAccountWithSeedParams : \"\"\"Convert to `solders` CreateAccountWithSeedParams. Returns: `solders` CreateAccountWithSeedParams \"\"\" return ssp . CreateAccountWithSeedParams ( from_pubkey = self . from_pubkey . to_solders (), to_pubkey = self . new_account_pubkey . to_solders (), base = self . base_pubkey . to_solders (), seed = self . seed , lamports = self . lamports , space = self . space , owner = self . program_id . to_solders (), )","title":"CreateAccountWithSeedParams"},{"location":"core/system_program/#solana.system_program.CreateAccountWithSeedParams.from_solders","text":"Convert from solders CreateAccountWithSeedParams. Parameters: Name Type Description Default params ssp.CreateAccountWithSeedParams solders CreateAccountWithSeedParams required Returns: Type Description CreateAccountWithSeedParams solana-py CreateAccountWithSeedParams Source code in solana/system_program.py @classmethod def from_solders ( cls , params : ssp . CreateAccountWithSeedParams ) -> CreateAccountWithSeedParams : \"\"\"Convert from `solders` CreateAccountWithSeedParams. Args: params: `solders` CreateAccountWithSeedParams Returns: `solana-py` CreateAccountWithSeedParams \"\"\" return cls ( from_pubkey = PublicKey . from_solders ( params [ \"from_pubkey\" ]), new_account_pubkey = PublicKey . from_solders ( params [ \"to_pubkey\" ]), base_pubkey = PublicKey . from_solders ( params [ \"base\" ]), seed = params [ \"seed\" ], lamports = params [ \"lamports\" ], space = params [ \"space\" ], program_id = PublicKey . from_solders ( params [ \"owner\" ]), )","title":"from_solders()"},{"location":"core/system_program/#solana.system_program.CreateAccountWithSeedParams.to_solders","text":"Convert to solders CreateAccountWithSeedParams. Returns: Type Description ssp.CreateAccountWithSeedParams solders CreateAccountWithSeedParams Source code in solana/system_program.py def to_solders ( self ) -> ssp . CreateAccountWithSeedParams : \"\"\"Convert to `solders` CreateAccountWithSeedParams. Returns: `solders` CreateAccountWithSeedParams \"\"\" return ssp . CreateAccountWithSeedParams ( from_pubkey = self . from_pubkey . to_solders (), to_pubkey = self . new_account_pubkey . to_solders (), base = self . base_pubkey . to_solders (), seed = self . seed , lamports = self . lamports , space = self . space , owner = self . program_id . to_solders (), )","title":"to_solders()"},{"location":"core/system_program/#solana.system_program.CreateNonceAccountParams","text":"Create nonce account system transaction params. Source code in solana/system_program.py class CreateNonceAccountParams ( NamedTuple ): \"\"\"Create nonce account system transaction params.\"\"\" from_pubkey : PublicKey \"\"\"\"\"\" nonce_pubkey : PublicKey \"\"\"\"\"\" authorized_pubkey : PublicKey \"\"\"\"\"\" lamports : int \"\"\"\"\"\"","title":"CreateNonceAccountParams"},{"location":"core/system_program/#solana.system_program.CreateNonceAccountWithSeedParams","text":"Create nonce account with seed system transaction params. Source code in solana/system_program.py class CreateNonceAccountWithSeedParams ( NamedTuple ): \"\"\"Create nonce account with seed system transaction params.\"\"\" from_pubkey : PublicKey \"\"\"\"\"\" nonce_pubkey : PublicKey \"\"\"\"\"\" authorized_pubkey : PublicKey \"\"\"\"\"\" lamports : int \"\"\"\"\"\" base_pubkey : PublicKey \"\"\"\"\"\" seed : str \"\"\"\"\"\"","title":"CreateNonceAccountWithSeedParams"},{"location":"core/system_program/#solana.system_program.InitializeNonceParams","text":"Initialize nonce account system instruction params. Source code in solana/system_program.py class InitializeNonceParams ( NamedTuple ): \"\"\"Initialize nonce account system instruction params.\"\"\" nonce_pubkey : PublicKey \"\"\"\"\"\" authorized_pubkey : PublicKey \"\"\"\"\"\" @classmethod def from_solders ( cls , params : ssp . InitializeNonceAccountParams ) -> InitializeNonceParams : \"\"\"Convert from `solders` InitializeNonceParams. Args: params: `solders` InitializeNonceParams Returns: `solana-py` InitializeNonceParams \"\"\" return cls ( nonce_pubkey = PublicKey . from_solders ( params [ \"nonce_pubkey\" ]), authorized_pubkey = PublicKey . from_solders ( params [ \"authority\" ]), ) def to_solders ( self ) -> ssp . InitializeNonceAccountParams : \"\"\"Convert to `solders` InitializeNonceParams. Returns: `solders` InitializeNonceParams \"\"\" return ssp . InitializeNonceAccountParams ( nonce_pubkey = self . nonce_pubkey . to_solders (), authority = self . authorized_pubkey . to_solders (), )","title":"InitializeNonceParams"},{"location":"core/system_program/#solana.system_program.InitializeNonceParams.from_solders","text":"Convert from solders InitializeNonceParams. Parameters: Name Type Description Default params ssp.InitializeNonceAccountParams solders InitializeNonceParams required Returns: Type Description InitializeNonceParams solana-py InitializeNonceParams Source code in solana/system_program.py @classmethod def from_solders ( cls , params : ssp . InitializeNonceAccountParams ) -> InitializeNonceParams : \"\"\"Convert from `solders` InitializeNonceParams. Args: params: `solders` InitializeNonceParams Returns: `solana-py` InitializeNonceParams \"\"\" return cls ( nonce_pubkey = PublicKey . from_solders ( params [ \"nonce_pubkey\" ]), authorized_pubkey = PublicKey . from_solders ( params [ \"authority\" ]), )","title":"from_solders()"},{"location":"core/system_program/#solana.system_program.InitializeNonceParams.to_solders","text":"Convert to solders InitializeNonceParams. Returns: Type Description ssp.InitializeNonceAccountParams solders InitializeNonceParams Source code in solana/system_program.py def to_solders ( self ) -> ssp . InitializeNonceAccountParams : \"\"\"Convert to `solders` InitializeNonceParams. Returns: `solders` InitializeNonceParams \"\"\" return ssp . InitializeNonceAccountParams ( nonce_pubkey = self . nonce_pubkey . to_solders (), authority = self . authorized_pubkey . to_solders (), )","title":"to_solders()"},{"location":"core/system_program/#solana.system_program.TransferParams","text":"Transfer system transaction params. Source code in solana/system_program.py class TransferParams ( NamedTuple ): \"\"\"Transfer system transaction params.\"\"\" from_pubkey : PublicKey \"\"\"\"\"\" to_pubkey : PublicKey \"\"\"\"\"\" lamports : int \"\"\"\"\"\" @classmethod def from_solders ( cls , params : ssp . TransferParams ) -> TransferParams : \"\"\"Convert from `solders` TransferParams. Args: params: `solders` TransferParams Returns: `solana-py` TransferParams \"\"\" return cls ( from_pubkey = PublicKey . from_solders ( params [ \"from_pubkey\" ]), to_pubkey = PublicKey . from_solders ( params [ \"to_pubkey\" ]), lamports = params [ \"lamports\" ], ) def to_solders ( self ) -> ssp . TransferParams : \"\"\"Convert to `solders` TransferParams. Returns: `solders` TransferParams \"\"\" return ssp . TransferParams ( from_pubkey = self . from_pubkey . to_solders (), to_pubkey = self . to_pubkey . to_solders (), lamports = self . lamports , )","title":"TransferParams"},{"location":"core/system_program/#solana.system_program.TransferParams.from_solders","text":"Convert from solders TransferParams. Parameters: Name Type Description Default params ssp.TransferParams solders TransferParams required Returns: Type Description TransferParams solana-py TransferParams Source code in solana/system_program.py @classmethod def from_solders ( cls , params : ssp . TransferParams ) -> TransferParams : \"\"\"Convert from `solders` TransferParams. Args: params: `solders` TransferParams Returns: `solana-py` TransferParams \"\"\" return cls ( from_pubkey = PublicKey . from_solders ( params [ \"from_pubkey\" ]), to_pubkey = PublicKey . from_solders ( params [ \"to_pubkey\" ]), lamports = params [ \"lamports\" ], )","title":"from_solders()"},{"location":"core/system_program/#solana.system_program.TransferParams.to_solders","text":"Convert to solders TransferParams. Returns: Type Description ssp.TransferParams solders TransferParams Source code in solana/system_program.py def to_solders ( self ) -> ssp . TransferParams : \"\"\"Convert to `solders` TransferParams. Returns: `solders` TransferParams \"\"\" return ssp . TransferParams ( from_pubkey = self . from_pubkey . to_solders (), to_pubkey = self . to_pubkey . to_solders (), lamports = self . lamports , )","title":"to_solders()"},{"location":"core/system_program/#solana.system_program.WithdrawNonceParams","text":"Withdraw nonce account system transaction params. Source code in solana/system_program.py class WithdrawNonceParams ( NamedTuple ): \"\"\"Withdraw nonce account system transaction params.\"\"\" nonce_pubkey : PublicKey \"\"\"\"\"\" authorized_pubkey : PublicKey \"\"\"\"\"\" to_pubkey : PublicKey \"\"\"\"\"\" lamports : int \"\"\"\"\"\" @classmethod def from_solders ( cls , params : ssp . WithdrawNonceAccountParams ) -> WithdrawNonceParams : \"\"\"Convert from `solders` WithdrawNonceParams. Args: params: `solders` WithdrawNonceParams Returns: `solana-py` WithdrawNonceParams \"\"\" return cls ( nonce_pubkey = PublicKey . from_solders ( params [ \"nonce_pubkey\" ]), authorized_pubkey = PublicKey . from_solders ( params [ \"authorized_pubkey\" ]), to_pubkey = PublicKey . from_solders ( params [ \"to_pubkey\" ]), lamports = params [ \"lamports\" ], ) def to_solders ( self ) -> ssp . WithdrawNonceAccountParams : \"\"\"Convert to `solders` WithdrawNonceParams. Returns: `solders` WithdrawNonceParams \"\"\" return ssp . WithdrawNonceAccountParams ( nonce_pubkey = self . nonce_pubkey . to_solders (), authorized_pubkey = self . authorized_pubkey . to_solders (), to_pubkey = self . to_pubkey . to_solders (), lamports = self . lamports , )","title":"WithdrawNonceParams"},{"location":"core/system_program/#solana.system_program.WithdrawNonceParams.from_solders","text":"Convert from solders WithdrawNonceParams. Parameters: Name Type Description Default params ssp.WithdrawNonceAccountParams solders WithdrawNonceParams required Returns: Type Description WithdrawNonceParams solana-py WithdrawNonceParams Source code in solana/system_program.py @classmethod def from_solders ( cls , params : ssp . WithdrawNonceAccountParams ) -> WithdrawNonceParams : \"\"\"Convert from `solders` WithdrawNonceParams. Args: params: `solders` WithdrawNonceParams Returns: `solana-py` WithdrawNonceParams \"\"\" return cls ( nonce_pubkey = PublicKey . from_solders ( params [ \"nonce_pubkey\" ]), authorized_pubkey = PublicKey . from_solders ( params [ \"authorized_pubkey\" ]), to_pubkey = PublicKey . from_solders ( params [ \"to_pubkey\" ]), lamports = params [ \"lamports\" ], )","title":"from_solders()"},{"location":"core/system_program/#solana.system_program.WithdrawNonceParams.to_solders","text":"Convert to solders WithdrawNonceParams. Returns: Type Description ssp.WithdrawNonceAccountParams solders WithdrawNonceParams Source code in solana/system_program.py def to_solders ( self ) -> ssp . WithdrawNonceAccountParams : \"\"\"Convert to `solders` WithdrawNonceParams. Returns: `solders` WithdrawNonceParams \"\"\" return ssp . WithdrawNonceAccountParams ( nonce_pubkey = self . nonce_pubkey . to_solders (), authorized_pubkey = self . authorized_pubkey . to_solders (), to_pubkey = self . to_pubkey . to_solders (), lamports = self . lamports , )","title":"to_solders()"},{"location":"core/system_program/#solana.system_program.allocate","text":"Generate an instruction that allocates space in an account without funding. Parameters: Name Type Description Default params Union[AllocateParams, AllocateWithSeedParams] The allocate params. required Examples: >>> from solana.publickey import PublicKey >>> allocator = PublicKey ( 1 ) >>> instruction = allocate ( ... AllocateParams ( account_pubkey = allocator , space = 65537 ) ... ) >>> type ( instruction ) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The allocate instruction. Source code in solana/system_program.py def allocate ( params : Union [ AllocateParams , AllocateWithSeedParams ]) -> TransactionInstruction : \"\"\"Generate an instruction that allocates space in an account without funding. Args: params: The allocate params. Example: >>> from solana.publickey import PublicKey >>> allocator = PublicKey(1) >>> instruction = allocate( ... AllocateParams(account_pubkey=allocator, space=65537) ... ) >>> type(instruction) <class 'solana.transaction.TransactionInstruction'> Returns: The allocate instruction. \"\"\" if isinstance ( params , AllocateWithSeedParams ): solders_ix = ssp . allocate_with_seed ( params . to_solders ()) else : solders_ix = ssp . allocate ( params . to_solders ()) return TransactionInstruction . from_solders ( solders_ix )","title":"allocate()"},{"location":"core/system_program/#solana.system_program.assign","text":"Generate an instruction that assigns an account to a program. Parameters: Name Type Description Default params Union[AssignParams, AssignWithSeedParams] The assign params. required Examples: >>> from solana.publickey import PublicKey >>> account , program_id = PublicKey ( 1 ), PublicKey ( 2 ) >>> instruction = assign ( ... AssignParams ( account_pubkey = account , program_id = program_id ) ... ) >>> type ( instruction ) < class ' solana . transaction . TransactionInstruction '> Source code in solana/system_program.py def assign ( params : Union [ AssignParams , AssignWithSeedParams ]) -> TransactionInstruction : \"\"\"Generate an instruction that assigns an account to a program. Args: params: The assign params. Example: >>> from solana.publickey import PublicKey >>> account, program_id = PublicKey(1), PublicKey(2) >>> instruction = assign( ... AssignParams(account_pubkey=account, program_id=program_id) ... ) >>> type(instruction) <class 'solana.transaction.TransactionInstruction'> \"\"\" solders_ix = ( ssp . assign ( params . to_solders ()) if isinstance ( params , AssignParams ) else ssp . assign_with_seed ( params . to_solders ()) ) return TransactionInstruction . from_solders ( solders_ix )","title":"assign()"},{"location":"core/system_program/#solana.system_program.create_account","text":"Generate an instruction that creates a new account. Parameters: Name Type Description Default params CreateAccountParams The create account params. required Examples: >>> from solana.publickey import PublicKey >>> from_account , new_account , program_id = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ) >>> instruction = create_account ( ... CreateAccountParams ( ... from_pubkey = from_account , new_account_pubkey = new_account , ... lamports = 1 , space = 1 , program_id = program_id ) ... ) >>> type ( instruction ) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The instruction to create the account. Source code in solana/system_program.py def create_account ( params : CreateAccountParams ) -> TransactionInstruction : \"\"\"Generate an instruction that creates a new account. Args: params: The create account params. Example: >>> from solana.publickey import PublicKey >>> from_account, new_account, program_id = PublicKey(1), PublicKey(2), PublicKey(3) >>> instruction = create_account( ... CreateAccountParams( ... from_pubkey=from_account, new_account_pubkey=new_account, ... lamports=1, space=1, program_id=program_id) ... ) >>> type(instruction) <class 'solana.transaction.TransactionInstruction'> Returns: The instruction to create the account. \"\"\" return TransactionInstruction . from_solders ( ssp . create_account ( params . to_solders ()))","title":"create_account()"},{"location":"core/system_program/#solana.system_program.create_account_with_seed","text":"Generate a instruction that creates a new account at an address generated with from , a seed, and programId. Parameters: Name Type Description Default params CreateAccountWithSeedParams account creation params. required Returns: Type Description TransactionInstruction The instruction to create the account. Source code in solana/system_program.py def create_account_with_seed ( params : CreateAccountWithSeedParams , ) -> TransactionInstruction : \"\"\"Generate a instruction that creates a new account at an address generated with `from`, a seed, and programId. Args: params: account creation params. Returns: The instruction to create the account. \"\"\" return TransactionInstruction . from_solders ( ssp . create_account_with_seed ( params . to_solders ()))","title":"create_account_with_seed()"},{"location":"core/system_program/#solana.system_program.create_nonce_account","text":"Generate a Transaction that creates a new Nonce account. Parameters: Name Type Description Default params Union[CreateNonceAccountParams, CreateNonceAccountWithSeedParams] The create nonce params. required Returns: Type Description Transaction The transaction to create the new nonce account. Source code in solana/system_program.py def create_nonce_account ( params : Union [ CreateNonceAccountParams , CreateNonceAccountWithSeedParams ]) -> Transaction : \"\"\"Generate a Transaction that creates a new Nonce account. Args: params: The create nonce params. Returns: The transaction to create the new nonce account. \"\"\" if isinstance ( params , CreateNonceAccountParams ): solders_ixs = ssp . create_nonce_account ( from_pubkey = params . from_pubkey . to_solders (), nonce_pubkey = params . nonce_pubkey . to_solders (), authority = params . authorized_pubkey . to_solders (), lamports = params . lamports , ) else : solders_ixs = ssp . create_nonce_account_with_seed ( from_pubkey = params . from_pubkey . to_solders (), nonce_pubkey = params . nonce_pubkey . to_solders (), base = params . base_pubkey . to_solders (), seed = params . seed , authority = params . authorized_pubkey . to_solders (), lamports = params . lamports , ) create_account_instruction = TransactionInstruction . from_solders ( solders_ixs [ 0 ]) initialize_nonce_instruction = TransactionInstruction . from_solders ( solders_ixs [ 1 ]) return Transaction ( fee_payer = params . from_pubkey ) . add ( create_account_instruction , initialize_nonce_instruction )","title":"create_nonce_account()"},{"location":"core/system_program/#solana.system_program.decode_allocate","text":"Decode an allocate system instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Examples: >>> from solana.publickey import PublicKey >>> allocator = PublicKey ( 1 ) >>> instruction = allocate ( ... AllocateParams ( account_pubkey = allocator , space = 65537 ) ... ) >>> decode_allocate ( instruction ) AllocateParams ( account_pubkey = 11111111111111111111111111111112 , space = 65537 ) Returns: Type Description AllocateParams The decoded instruction params. Source code in solana/system_program.py def decode_allocate ( instruction : TransactionInstruction ) -> AllocateParams : \"\"\"Decode an allocate system instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Example: >>> from solana.publickey import PublicKey >>> allocator = PublicKey(1) >>> instruction = allocate( ... AllocateParams(account_pubkey=allocator,space=65537) ... ) >>> decode_allocate(instruction) AllocateParams(account_pubkey=11111111111111111111111111111112, space=65537) Returns: The decoded instruction params. \"\"\" # pylint: disable=line-too-long # noqa: E501 return AllocateParams . from_solders ( ssp . decode_allocate ( instruction . to_solders ()))","title":"decode_allocate()"},{"location":"core/system_program/#solana.system_program.decode_allocate_with_seed","text":"Decode an allocate with seed system instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Examples: >>> from solana.publickey import PublicKey >>> allocator , base , program_id = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ) >>> instruction = allocate ( ... AllocateWithSeedParams ( ... account_pubkey = allocator , ... base_pubkey = base , ... seed = \"gqln\" , ... space = 65537 , ... program_id = program_id ... ) ... ) >>> decode_allocate_with_seed ( instruction ) AllocateWithSeedParams ( account_pubkey = 11111111111111111111111111111112 , base_pubkey = 11111111111111111111111111111113 , seed = 'gqln' , space = 65537 , program_id = 11111111111111111111111111111114 ) Returns: Type Description AllocateWithSeedParams The decoded instruction params. Source code in solana/system_program.py def decode_allocate_with_seed ( instruction : TransactionInstruction ) -> AllocateWithSeedParams : \"\"\"Decode an allocate with seed system instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Example: >>> from solana.publickey import PublicKey >>> allocator, base, program_id = PublicKey(1), PublicKey(2), PublicKey(3) >>> instruction = allocate( ... AllocateWithSeedParams( ... account_pubkey=allocator, ... base_pubkey=base, ... seed=\"gqln\", ... space=65537, ... program_id=program_id ... ) ... ) >>> decode_allocate_with_seed(instruction) AllocateWithSeedParams(account_pubkey=11111111111111111111111111111112, base_pubkey=11111111111111111111111111111113, seed='gqln', space=65537, program_id=11111111111111111111111111111114) Returns: The decoded instruction params. \"\"\" # pylint: disable=line-too-long # noqa: E501 return AllocateWithSeedParams . from_solders ( ssp . decode_allocate_with_seed ( instruction . to_solders ()))","title":"decode_allocate_with_seed()"},{"location":"core/system_program/#solana.system_program.decode_assign","text":"Decode an assign system instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Examples: >>> from solana.publickey import PublicKey >>> account , program_id = PublicKey ( 1 ), PublicKey ( 2 ) >>> instruction = assign ( ... AssignParams ( account_pubkey = account , program_id = program_id ) ... ) >>> decode_assign ( instruction ) AssignParams ( account_pubkey = 11111111111111111111111111111112 , program_id = 11111111111111111111111111111113 ) Returns: Type Description AssignParams The decoded instruction params. Source code in solana/system_program.py def decode_assign ( instruction : TransactionInstruction ) -> AssignParams : \"\"\"Decode an assign system instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Example: >>> from solana.publickey import PublicKey >>> account, program_id = PublicKey(1), PublicKey(2) >>> instruction = assign( ... AssignParams(account_pubkey=account, program_id=program_id) ... ) >>> decode_assign(instruction) AssignParams(account_pubkey=11111111111111111111111111111112, program_id=11111111111111111111111111111113) Returns: The decoded instruction params. \"\"\" return AssignParams . from_solders ( ssp . decode_assign ( instruction . to_solders ()))","title":"decode_assign()"},{"location":"core/system_program/#solana.system_program.decode_assign_with_seed","text":"Decode an assign system with seed instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description AssignWithSeedParams The decoded instruction params. Source code in solana/system_program.py def decode_assign_with_seed ( instruction : TransactionInstruction ) -> AssignWithSeedParams : \"\"\"Decode an assign system with seed instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction params. \"\"\" return AssignWithSeedParams . from_solders ( ssp . decode_assign_with_seed ( instruction . to_solders ()))","title":"decode_assign_with_seed()"},{"location":"core/system_program/#solana.system_program.decode_create_account","text":"Decode a create account system instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Examples: >>> from solana.publickey import PublicKey >>> from_account , new_account , program_id = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ) >>> instruction = create_account ( ... CreateAccountParams ( ... from_pubkey = from_account , new_account_pubkey = new_account , ... lamports = 1 , space = 1 , program_id = program_id ) ... ) >>> decode_create_account ( instruction ) CreateAccountParams ( from_pubkey = 11111111111111111111111111111112 , new_account_pubkey = 11111111111111111111111111111113 , lamports = 1 , space = 1 , program_id = 11111111111111111111111111111114 ) Returns: Type Description CreateAccountParams The decoded instruction params. Source code in solana/system_program.py def decode_create_account ( instruction : TransactionInstruction ) -> CreateAccountParams : \"\"\"Decode a create account system instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Example: >>> from solana.publickey import PublicKey >>> from_account, new_account, program_id = PublicKey(1), PublicKey(2), PublicKey(3) >>> instruction = create_account( ... CreateAccountParams( ... from_pubkey=from_account, new_account_pubkey=new_account, ... lamports=1, space=1, program_id=program_id) ... ) >>> decode_create_account(instruction) CreateAccountParams(from_pubkey=11111111111111111111111111111112, new_account_pubkey=11111111111111111111111111111113, lamports=1, space=1, program_id=11111111111111111111111111111114) Returns: The decoded instruction params. \"\"\" # noqa: E501 # pylint: disable=line-too-long return CreateAccountParams . from_solders ( ssp . decode_create_account ( instruction . to_solders ()))","title":"decode_create_account()"},{"location":"core/system_program/#solana.system_program.decode_create_account_with_seed","text":"Decode a create account with seed system instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description CreateAccountWithSeedParams The decoded instruction params. Source code in solana/system_program.py def decode_create_account_with_seed ( instruction : TransactionInstruction ) -> CreateAccountWithSeedParams : \"\"\"Decode a create account with seed system instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction params. \"\"\" return CreateAccountWithSeedParams . from_solders ( ssp . decode_create_account_with_seed ( instruction . to_solders ()))","title":"decode_create_account_with_seed()"},{"location":"core/system_program/#solana.system_program.decode_nonce_advance","text":"Decode a nonce advance system instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description AdvanceNonceParams The decoded instruction params. Source code in solana/system_program.py def decode_nonce_advance ( instruction : TransactionInstruction ) -> AdvanceNonceParams : \"\"\"Decode a nonce advance system instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction params. \"\"\" return AdvanceNonceParams . from_solders ( ssp . decode_advance_nonce_account ( instruction . to_solders ()))","title":"decode_nonce_advance()"},{"location":"core/system_program/#solana.system_program.decode_nonce_authorize","text":"Decode a nonce authorize system instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description AuthorizeNonceParams The decoded instruction params. Source code in solana/system_program.py def decode_nonce_authorize ( instruction : TransactionInstruction ) -> AuthorizeNonceParams : \"\"\"Decode a nonce authorize system instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction params. \"\"\" return AuthorizeNonceParams . from_solders ( ssp . decode_authorize_nonce_account ( instruction . to_solders ()))","title":"decode_nonce_authorize()"},{"location":"core/system_program/#solana.system_program.decode_nonce_initialize","text":"Decode a nonce initialize system instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description InitializeNonceParams The decoded instruction params. Source code in solana/system_program.py def decode_nonce_initialize ( instruction : TransactionInstruction ) -> InitializeNonceParams : \"\"\"Decode a nonce initialize system instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction params. \"\"\" return InitializeNonceParams . from_solders ( ssp . decode_initialize_nonce_account ( instruction . to_solders ()))","title":"decode_nonce_initialize()"},{"location":"core/system_program/#solana.system_program.decode_nonce_withdraw","text":"Decode a nonce withdraw system instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description WithdrawNonceParams The decoded instruction params. Source code in solana/system_program.py def decode_nonce_withdraw ( instruction : TransactionInstruction ) -> WithdrawNonceParams : \"\"\"Decode a nonce withdraw system instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction params. \"\"\" return WithdrawNonceParams . from_solders ( ssp . decode_withdraw_nonce_account ( instruction . to_solders ()))","title":"decode_nonce_withdraw()"},{"location":"core/system_program/#solana.system_program.decode_transfer","text":"Decode a transfer system instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Examples: >>> from solana.publickey import PublicKey >>> sender , receiver = PublicKey ( 1 ), PublicKey ( 2 ) >>> instruction = transfer ( ... TransferParams ( from_pubkey = sender , to_pubkey = receiver , lamports = 1000 ) ... ) >>> decode_transfer ( instruction ) TransferParams ( from_pubkey = 11111111111111111111111111111112 , to_pubkey = 11111111111111111111111111111113 , lamports = 1000 ) Returns: Type Description TransferParams The decoded instruction params. Source code in solana/system_program.py def decode_transfer ( instruction : TransactionInstruction ) -> TransferParams : \"\"\"Decode a transfer system instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Example: >>> from solana.publickey import PublicKey >>> sender, receiver = PublicKey(1), PublicKey(2) >>> instruction = transfer( ... TransferParams(from_pubkey=sender, to_pubkey=receiver, lamports=1000) ... ) >>> decode_transfer(instruction) TransferParams(from_pubkey=11111111111111111111111111111112, to_pubkey=11111111111111111111111111111113, lamports=1000) Returns: The decoded instruction params. \"\"\" # pylint: disable=line-too-long # noqa: E501 return TransferParams . from_solders ( ssp . decode_transfer ( instruction . to_solders ()))","title":"decode_transfer()"},{"location":"core/system_program/#solana.system_program.nonce_advance","text":"Generate an instruction to advance the nonce in a Nonce account. Parameters: Name Type Description Default params AdvanceNonceParams The advance nonce params required Returns: Type Description TransactionInstruction The instruction to advance the nonce. Source code in solana/system_program.py def nonce_advance ( params : AdvanceNonceParams ) -> TransactionInstruction : \"\"\"Generate an instruction to advance the nonce in a Nonce account. Args: params: The advance nonce params Returns: The instruction to advance the nonce. \"\"\" return TransactionInstruction . from_solders ( ssp . advance_nonce_account ( params . to_solders ()))","title":"nonce_advance()"},{"location":"core/system_program/#solana.system_program.nonce_authorize","text":"Generate an instruction that authorizes a new PublicKey as the authority on a Nonce account. Parameters: Name Type Description Default params AuthorizeNonceParams The authorize nonce params required Returns: Type Description TransactionInstruction The instruction to grant the new nonce authority. Source code in solana/system_program.py def nonce_authorize ( params : AuthorizeNonceParams ) -> TransactionInstruction : \"\"\"Generate an instruction that authorizes a new PublicKey as the authority on a Nonce account. Args: params: The authorize nonce params Returns: The instruction to grant the new nonce authority. \"\"\" return TransactionInstruction . from_solders ( ssp . authorize_nonce_account ( params . to_solders ()))","title":"nonce_authorize()"},{"location":"core/system_program/#solana.system_program.nonce_initialization","text":"Generate an instruction to initialize a Nonce account. Parameters: Name Type Description Default params InitializeNonceParams The nonce initialization params. required Returns: Type Description TransactionInstruction The instruction to initialize the nonce account. Source code in solana/system_program.py def nonce_initialization ( params : InitializeNonceParams ) -> TransactionInstruction : \"\"\"Generate an instruction to initialize a Nonce account. Args: params: The nonce initialization params. Returns: The instruction to initialize the nonce account. \"\"\" return TransactionInstruction . from_solders ( ssp . initialize_nonce_account ( params . to_solders ()))","title":"nonce_initialization()"},{"location":"core/system_program/#solana.system_program.nonce_withdraw","text":"Generate an instruction that withdraws lamports from a Nonce account. Parameters: Name Type Description Default params WithdrawNonceParams The withdraw nonce params required Returns: Type Description TransactionInstruction The instruction to withdraw from the nonce account. Source code in solana/system_program.py def nonce_withdraw ( params : WithdrawNonceParams ) -> TransactionInstruction : \"\"\"Generate an instruction that withdraws lamports from a Nonce account. Args: params: The withdraw nonce params Returns: The instruction to withdraw from the nonce account. \"\"\" return TransactionInstruction . from_solders ( ssp . withdraw_nonce_account ( params . to_solders ()))","title":"nonce_withdraw()"},{"location":"core/system_program/#solana.system_program.transfer","text":"Generate an instruction that transfers lamports from one account to another. Parameters: Name Type Description Default params TransferParams The transfer params. required Examples: >>> from solana.publickey import PublicKey >>> sender , receiver = PublicKey ( 1 ), PublicKey ( 2 ) >>> instruction = transfer ( ... TransferParams ( from_pubkey = sender , to_pubkey = receiver , lamports = 1000 ) ... ) >>> type ( instruction ) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The transfer instruction. Source code in solana/system_program.py def transfer ( params : TransferParams ) -> TransactionInstruction : \"\"\"Generate an instruction that transfers lamports from one account to another. Args: params: The transfer params. Example: >>> from solana.publickey import PublicKey >>> sender, receiver = PublicKey(1), PublicKey(2) >>> instruction = transfer( ... TransferParams(from_pubkey=sender, to_pubkey=receiver, lamports=1000) ... ) >>> type(instruction) <class 'solana.transaction.TransactionInstruction'> Returns: The transfer instruction. \"\"\" return TransactionInstruction . from_solders ( ssp . transfer ( params . to_solders ()))","title":"transfer()"},{"location":"core/sysvar/","text":"Sysvar solana.sysvar Synthetic accounts that allow programs to access certain network states. SYSVAR_CLOCK_PUBKEY : PublicKey Public key of the synthetic account that serves the current network time. SYSVAR_EPOCH_SCHEDULE_PUBKEY : PublicKey The EpochSchedule sysvar contains epoch scheduling constants that are set in genesis, and enables calculating the number of slots in a given epoch, the epoch for a given slot, etc. (Note: the epoch schedule is distinct from the leader schedule <https://docs.solana.com/terminology#leader-schedule> _). SYSVAR_INSTRUCTIONS_PUBKEY : PublicKey The Instructions sysvar contains the serialized instructions in a Message while that Message is being processed. This allows program instructions to reference other instructions in the same transaction. Read more information on instruction introspection <https://docs.solana.com/implemented-proposals/instruction_introspection> _. SYSVAR_RECENT_BLOCKHASHES_PUBKEY : PublicKey Public key of the synthetic account that serves recent blockhashes. SYSVAR_RENT_PUBKEY : PublicKey Public key of the synthetic account that serves the network fee resource consumption. SYSVAR_REWARDS_PUBKEY : PublicKey Public key of the synthetic account that serves the network rewards. SYSVAR_SLOT_HASHES_PUBKEY : PublicKey The SlotHashes sysvar contains the most recent hashes of the slot's parent banks. It is updated every slot. SYSVAR_STAKE_HISTORY_PUBKEY : PublicKey Public key of the synthetic account that serves the stake history.","title":"Sysvar"},{"location":"core/sysvar/#sysvar","text":"","title":"Sysvar"},{"location":"core/sysvar/#solana.sysvar","text":"Synthetic accounts that allow programs to access certain network states.","title":"sysvar"},{"location":"core/sysvar/#solana.sysvar.SYSVAR_CLOCK_PUBKEY","text":"Public key of the synthetic account that serves the current network time.","title":"SYSVAR_CLOCK_PUBKEY"},{"location":"core/sysvar/#solana.sysvar.SYSVAR_EPOCH_SCHEDULE_PUBKEY","text":"The EpochSchedule sysvar contains epoch scheduling constants that are set in genesis, and enables calculating the number of slots in a given epoch, the epoch for a given slot, etc. (Note: the epoch schedule is distinct from the leader schedule <https://docs.solana.com/terminology#leader-schedule> _).","title":"SYSVAR_EPOCH_SCHEDULE_PUBKEY"},{"location":"core/sysvar/#solana.sysvar.SYSVAR_INSTRUCTIONS_PUBKEY","text":"The Instructions sysvar contains the serialized instructions in a Message while that Message is being processed. This allows program instructions to reference other instructions in the same transaction. Read more information on instruction introspection <https://docs.solana.com/implemented-proposals/instruction_introspection> _.","title":"SYSVAR_INSTRUCTIONS_PUBKEY"},{"location":"core/sysvar/#solana.sysvar.SYSVAR_RECENT_BLOCKHASHES_PUBKEY","text":"Public key of the synthetic account that serves recent blockhashes.","title":"SYSVAR_RECENT_BLOCKHASHES_PUBKEY"},{"location":"core/sysvar/#solana.sysvar.SYSVAR_RENT_PUBKEY","text":"Public key of the synthetic account that serves the network fee resource consumption.","title":"SYSVAR_RENT_PUBKEY"},{"location":"core/sysvar/#solana.sysvar.SYSVAR_REWARDS_PUBKEY","text":"Public key of the synthetic account that serves the network rewards.","title":"SYSVAR_REWARDS_PUBKEY"},{"location":"core/sysvar/#solana.sysvar.SYSVAR_SLOT_HASHES_PUBKEY","text":"The SlotHashes sysvar contains the most recent hashes of the slot's parent banks. It is updated every slot.","title":"SYSVAR_SLOT_HASHES_PUBKEY"},{"location":"core/sysvar/#solana.sysvar.SYSVAR_STAKE_HISTORY_PUBKEY","text":"Public key of the synthetic account that serves the stake history.","title":"SYSVAR_STAKE_HISTORY_PUBKEY"},{"location":"core/transaction/","text":"Transaction solana.transaction Library to package an atomic sequence of instructions to a transaction. PACKET_DATA_SIZE Constant for maximum over-the-wire size of a Transaction. SIG_LENGTH Constant for standard length of a signature. TransactionSignature Type for TransactionSignature. AccountMeta dataclass Account metadata dataclass. Source code in solana/transaction.py @dataclass class AccountMeta : \"\"\"Account metadata dataclass.\"\"\" pubkey : PublicKey \"\"\"An account's public key.\"\"\" is_signer : bool \"\"\"True if an instruction requires a transaction signature matching `pubkey`\"\"\" is_writable : bool \"\"\"True if the `pubkey` can be loaded as a read-write account.\"\"\" @classmethod def from_solders ( cls , meta : instruction . AccountMeta ) -> AccountMeta : \"\"\"Convert from a `solders` AccountMeta. Args: meta: The `solders` AccountMeta. Returns: The `solana-py` AccountMeta. \"\"\" return cls ( pubkey = PublicKey . from_solders ( meta . pubkey ), is_signer = meta . is_signer , is_writable = meta . is_writable ) def to_solders ( self ) -> instruction . AccountMeta : \"\"\"Convert to a `solders` AccountMeta. Returns: The `solders` AccountMeta. \"\"\" return instruction . AccountMeta ( pubkey = self . pubkey . to_solders (), is_signer = self . is_signer , is_writable = self . is_writable ) is_signer : bool dataclass-field True if an instruction requires a transaction signature matching pubkey is_writable : bool dataclass-field True if the pubkey can be loaded as a read-write account. pubkey : PublicKey dataclass-field An account's public key. from_solders ( meta ) classmethod Convert from a solders AccountMeta. Parameters: Name Type Description Default meta instruction.AccountMeta The solders AccountMeta. required Returns: Type Description AccountMeta The solana-py AccountMeta. Source code in solana/transaction.py @classmethod def from_solders ( cls , meta : instruction . AccountMeta ) -> AccountMeta : \"\"\"Convert from a `solders` AccountMeta. Args: meta: The `solders` AccountMeta. Returns: The `solana-py` AccountMeta. \"\"\" return cls ( pubkey = PublicKey . from_solders ( meta . pubkey ), is_signer = meta . is_signer , is_writable = meta . is_writable ) to_solders ( self ) Convert to a solders AccountMeta. Returns: Type Description instruction.AccountMeta The solders AccountMeta. Source code in solana/transaction.py def to_solders ( self ) -> instruction . AccountMeta : \"\"\"Convert to a `solders` AccountMeta. Returns: The `solders` AccountMeta. \"\"\" return instruction . AccountMeta ( pubkey = self . pubkey . to_solders (), is_signer = self . is_signer , is_writable = self . is_writable ) NonceInformation NonceInformation to be used to build a Transaction. Source code in solana/transaction.py class NonceInformation ( NamedTuple ): \"\"\"NonceInformation to be used to build a Transaction.\"\"\" nonce : Blockhash \"\"\"The current Nonce blockhash.\"\"\" nonce_instruction : TransactionInstruction \"\"\"AdvanceNonceAccount Instruction.\"\"\" nonce : < function NewType .< locals >. new_type at 0x7f7a958658b0 > The current Nonce blockhash. nonce_instruction : TransactionInstruction AdvanceNonceAccount Instruction. SigPubkeyPair dataclass Pair of signature and corresponding public key. Source code in solana/transaction.py @dataclass class SigPubkeyPair : \"\"\"Pair of signature and corresponding public key.\"\"\" pubkey : PublicKey signature : Optional [ bytes ] = None Transaction Transaction class to represent an atomic transaction. Parameters: Name Type Description Default recent_blockhash Optional[Blockhash] A recent transaction id. None nonce_info Optional[NonceInformation] Nonce information. If populated, transaction will use a durable Nonce hash instead of a recent_blockhash . None fee_payer Optional[PublicKey] The transaction fee payer. None instructions Optional[Sequence[TransactionInstruction]] The instructions to be executed in this transaction. None Source code in solana/transaction.py class Transaction : \"\"\"Transaction class to represent an atomic transaction. Args: recent_blockhash: A recent transaction id. nonce_info: Nonce information. If populated, transaction will use a durable Nonce hash instead of a `recent_blockhash`. fee_payer: The transaction fee payer. instructions: The instructions to be executed in this transaction. \"\"\" # Default (empty) signature __DEFAULT_SIG = bytes ( 64 ) def __init__ ( self , recent_blockhash : Optional [ Blockhash ] = None , nonce_info : Optional [ NonceInformation ] = None , fee_payer : Optional [ PublicKey ] = None , instructions : Optional [ Sequence [ TransactionInstruction ]] = None , ) -> None : \"\"\"Init transaction object.\"\"\" self . _solders = _build_solders_tx ( recent_blockhash = recent_blockhash , nonce_info = nonce_info , fee_payer = fee_payer , instructions = instructions ) @classmethod def from_solders ( cls , txn : SoldersTx ) -> Transaction : \"\"\"Convert from a `solders` transaction. Args: txn: The `solders` transaction. Returns: The `solana-py` transaction. \"\"\" new_tx = cls () new_tx . _solders = txn return new_tx def to_solders ( self ) -> SoldersTx : \"\"\"Convert to a `solders` transaction. Returns: The `solders` transaction. \"\"\" return self . _solders def __eq__ ( self , other : Any ) -> bool : \"\"\"Equality defintion for Transactions.\"\"\" if not isinstance ( other , Transaction ): return False return self . to_solders () == other . to_solders () @property def recent_blockhash ( self ) -> Optional [ Blockhash ]: \"\"\"Optional[Blockhash]: The blockhash assigned to this transaction.\"\"\" return Blockhash ( str ( self . _solders . message . recent_blockhash )) @recent_blockhash . setter def recent_blockhash ( self , blockhash : Optional [ Blockhash ]) -> None : self . _solders = _build_solders_tx ( recent_blockhash = blockhash , nonce_info = None , fee_payer = self . fee_payer , instructions = self . instructions ) @property def fee_payer ( self ) -> Optional [ PublicKey ]: \"\"\"Optional[PublicKey]: The transaction fee payer.\"\"\" account_keys = self . _solders . message . account_keys return PublicKey . from_solders ( account_keys [ 0 ]) if account_keys else None @fee_payer . setter def fee_payer ( self , payer : Optional [ PublicKey ]) -> None : self . _solders = _build_solders_tx ( recent_blockhash = self . recent_blockhash , nonce_info = None , fee_payer = payer , instructions = self . instructions ) @property def instructions ( self ) -> Tuple [ TransactionInstruction , ... ]: \"\"\"Tuple[TransactionInstruction]: The instructions contained in this transaction.\"\"\" msg = self . _solders . message return tuple ( _decompile_instructions ( msg )) @instructions . setter def instructions ( self , ixns : Sequence [ TransactionInstruction ]) -> None : self . _solders = _build_solders_tx ( recent_blockhash = self . recent_blockhash , nonce_info = None , fee_payer = self . fee_payer , instructions = ixns ) @property def signatures ( self ) -> Tuple [ Signature , ... ]: \"\"\"Tuple[Signature]: Signatures for the transaction.\"\"\" return tuple ( self . _solders . signatures ) def signature ( self ) -> Signature : \"\"\"The first (payer) Transaction signature. Returns: The payer signature. \"\"\" return self . _solders . signatures [ 0 ] def add ( self , * args : Union [ Transaction , TransactionInstruction ]) -> Transaction : \"\"\"Add one or more instructions to this Transaction. Args: *args: The instructions to add to this Transaction. If a `Transaction` is passsed, the instructions will be extracted from it. Returns: The transaction with the added instructions. \"\"\" for arg in args : if isinstance ( arg , Transaction ): self . instructions = self . instructions + arg . instructions elif isinstance ( arg , TransactionInstruction ): self . instructions = ( * self . instructions , arg ) else : raise ValueError ( \"invalid instruction:\" , arg ) return self def compile_message ( self ) -> Message : # pylint: disable=too-many-locals \"\"\"Compile transaction data. Returns: The compiled message. \"\"\" return Message . from_solders ( self . _solders . message ) def serialize_message ( self ) -> bytes : \"\"\"Get raw transaction data that need to be covered by signatures. Returns: The serialized message. \"\"\" return self . compile_message () . serialize () def sign_partial ( self , * partial_signers : Keypair ) -> None : \"\"\"Partially sign a Transaction with the specified keypairs. All the caveats from the `sign` method apply to `sign_partial` \"\"\" underlying_signers = [ signer . to_solders () for signer in partial_signers ] self . _solders . partial_sign ( underlying_signers , self . _solders . message . recent_blockhash ) def sign ( self , * signers : Keypair ) -> None : \"\"\"Sign the Transaction with the specified accounts. Multiple signatures may be applied to a Transaction. The first signature is considered \"primary\" and is used when testing for Transaction confirmation. Transaction fields should not be modified after the first call to `sign`, as doing so may invalidate the signature and cause the Transaction to be rejected. The Transaction must be assigned a valid `recent_blockhash` before invoking this method. \"\"\" underlying_signers = [ signer . to_solders () for signer in signers ] self . _solders . sign ( underlying_signers , self . _solders . message . recent_blockhash ) def add_signature ( self , pubkey : PublicKey , signature : Signature ) -> None : \"\"\"Add an externally created signature to a transaction. Args: pubkey: The public key that created the signature. signature: The signature to add. \"\"\" presigner = Presigner ( pubkey . to_solders (), signature ) self . _solders . partial_sign ([ presigner ], self . _solders . message . recent_blockhash ) def verify_signatures ( self ) -> bool : \"\"\"Verify signatures of a complete, signed Transaction. Returns: a bool indicating if the signatures are correct or not. \"\"\" try : self . _solders . verify () except TransactionError : return False return True def serialize ( self , verify_signatures : bool = True ) -> bytes : \"\"\"Serialize the Transaction in the wire format. The Transaction must have a valid `signature` before invoking this method. verify_signatures can be added if the signature does not require to be verified. Args: verify_signatures: a bool indicating to verify the signature or not. Defaults to True Example: >>> from solana.keypair import Keypair >>> from solana.blockhash import Blockhash >>> from solana.publickey import PublicKey >>> from solana.system_program import transfer, TransferParams >>> seed = bytes(PublicKey(1)) >>> sender, receiver = Keypair.from_seed(seed), PublicKey(2) >>> transfer_tx = Transaction().add(transfer(TransferParams(from_pubkey=sender.public_key, to_pubkey=receiver, lamports=1000))) >>> transfer_tx.recent_blockhash = Blockhash(str(PublicKey(3))) >>> transfer_tx.sign(sender) >>> transfer_tx.serialize().hex() '019d53be8af3a7c30f86c1092d2c3ea61d270c0cfa275a23ba504674c8fbbb724827b23b42dc8e08019e23120f1b6f40f9799355ce54185b4415be37ca2cee6e0e010001034cb5abf6ad79fbf5abbccafcc269d85cd2651ed4b885b5869f241aedf0a5ba2900000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000301020200010c02000000e803000000000000' Returns: The serialized transaction. \"\"\" # noqa: E501 pylint: disable=line-too-long if self . signatures == [ Signature . default () for sig in self . signatures ]: raise AttributeError ( \"transaction has not been signed\" ) if verify_signatures : if not self . verify_signatures (): raise AttributeError ( \"transaction has not been signed correctly\" ) return bytes ( self . _solders ) @classmethod def deserialize ( cls , raw_transaction : bytes ) -> Transaction : \"\"\"Parse a wire transaction into a Transaction object. Example: >>> raw_transaction = bytes.fromhex( ... '019d53be8af3a7c30f86c1092d2c3ea61d270c0cfa2' ... '75a23ba504674c8fbbb724827b23b42dc8e08019e23' ... '120f1b6f40f9799355ce54185b4415be37ca2cee6e0' ... 'e010001034cb5abf6ad79fbf5abbccafcc269d85cd2' ... '651ed4b885b5869f241aedf0a5ba290000000000000' ... '0000000000000000000000000000000000000000000' ... '0000000200000000000000000000000000000000000' ... '0000000000000000000000000000000000000000000' ... '0000000000000000000000000000000000000000000' ... '000000301020200010c02000000e803000000000000' ... ) >>> type(Transaction.deserialize(raw_transaction)) <class 'solana.transaction.Transaction'> Returns: The deserialized transaction. \"\"\" return cls . from_solders ( SoldersTx . from_bytes ( raw_transaction )) @classmethod def populate ( cls , message : Message , signatures : List [ Signature ]) -> Transaction : \"\"\"Populate Transaction object from message and signatures. Example: >>> raw_message = bytes.fromhex( ... '0200030500000000000000000000000000000000000000000000' ... '0000000000000000000100000000000000000000000000000000' ... '0000000000000000000000000000000200000000000000000000' ... '0000000000000000000000000000000000000000000300000000' ... '0000000000000000000000000000000000000000000000000000' ... '0004000000000000000000000000000000000000000000000000' ... '0000000000000005c49ae77603782054f17a9decea43b444eba0' ... 'edb12c6f1d31c6e0e4a84bf052eb010403010203050909090909' ... ) >>> from solana.message import Message >>> from solders.signature import Signature >>> msg = Message.deserialize(raw_message) >>> signatures = [Signature(bytes([1] * SIG_LENGTH)), Signature(bytes([2] * SIG_LENGTH))] >>> type(Transaction.populate(msg, signatures)) <class 'solana.transaction.Transaction'> Returns: The populated transaction. \"\"\" message_underlying = message . to_solders () return cls . from_solders ( SoldersTx . populate ( message_underlying , signatures )) fee_payer : Optional [ PublicKey ] property writable Optional[PublicKey]: The transaction fee payer. instructions : Tuple [ TransactionInstruction , ... ] property writable Tuple[TransactionInstruction]: The instructions contained in this transaction. recent_blockhash : Optional [ Blockhash ] property writable Optional[Blockhash]: The blockhash assigned to this transaction. signatures : Tuple [ Signature , ... ] property readonly Tuple[Signature]: Signatures for the transaction. __init__ ( self , recent_blockhash = None , nonce_info = None , fee_payer = None , instructions = None ) special Init transaction object. Source code in solana/transaction.py def __init__ ( self , recent_blockhash : Optional [ Blockhash ] = None , nonce_info : Optional [ NonceInformation ] = None , fee_payer : Optional [ PublicKey ] = None , instructions : Optional [ Sequence [ TransactionInstruction ]] = None , ) -> None : \"\"\"Init transaction object.\"\"\" self . _solders = _build_solders_tx ( recent_blockhash = recent_blockhash , nonce_info = nonce_info , fee_payer = fee_payer , instructions = instructions ) add ( self , * args ) Add one or more instructions to this Transaction. Parameters: Name Type Description Default *args Union[Transaction, TransactionInstruction] The instructions to add to this Transaction. If a Transaction is passsed, the instructions will be extracted from it. () Returns: Type Description Transaction The transaction with the added instructions. Source code in solana/transaction.py def add ( self , * args : Union [ Transaction , TransactionInstruction ]) -> Transaction : \"\"\"Add one or more instructions to this Transaction. Args: *args: The instructions to add to this Transaction. If a `Transaction` is passsed, the instructions will be extracted from it. Returns: The transaction with the added instructions. \"\"\" for arg in args : if isinstance ( arg , Transaction ): self . instructions = self . instructions + arg . instructions elif isinstance ( arg , TransactionInstruction ): self . instructions = ( * self . instructions , arg ) else : raise ValueError ( \"invalid instruction:\" , arg ) return self add_signature ( self , pubkey , signature ) Add an externally created signature to a transaction. Parameters: Name Type Description Default pubkey PublicKey The public key that created the signature. required signature Signature The signature to add. required Source code in solana/transaction.py def add_signature ( self , pubkey : PublicKey , signature : Signature ) -> None : \"\"\"Add an externally created signature to a transaction. Args: pubkey: The public key that created the signature. signature: The signature to add. \"\"\" presigner = Presigner ( pubkey . to_solders (), signature ) self . _solders . partial_sign ([ presigner ], self . _solders . message . recent_blockhash ) compile_message ( self ) Compile transaction data. Returns: Type Description Message The compiled message. Source code in solana/transaction.py def compile_message ( self ) -> Message : # pylint: disable=too-many-locals \"\"\"Compile transaction data. Returns: The compiled message. \"\"\" return Message . from_solders ( self . _solders . message ) deserialize ( raw_transaction ) classmethod Parse a wire transaction into a Transaction object. Examples: >>> raw_transaction = bytes . fromhex ( ... '019d53be8af3a7c30f86c1092d2c3ea61d270c0cfa2' ... '75a23ba504674c8fbbb724827b23b42dc8e08019e23' ... '120f1b6f40f9799355ce54185b4415be37ca2cee6e0' ... 'e010001034cb5abf6ad79fbf5abbccafcc269d85cd2' ... '651ed4b885b5869f241aedf0a5ba290000000000000' ... '0000000000000000000000000000000000000000000' ... '0000000200000000000000000000000000000000000' ... '0000000000000000000000000000000000000000000' ... '0000000000000000000000000000000000000000000' ... '000000301020200010c02000000e803000000000000' ... ) >>> type ( Transaction . deserialize ( raw_transaction )) < class ' solana . transaction . Transaction '> Returns: Type Description Transaction The deserialized transaction. Source code in solana/transaction.py @classmethod def deserialize ( cls , raw_transaction : bytes ) -> Transaction : \"\"\"Parse a wire transaction into a Transaction object. Example: >>> raw_transaction = bytes.fromhex( ... '019d53be8af3a7c30f86c1092d2c3ea61d270c0cfa2' ... '75a23ba504674c8fbbb724827b23b42dc8e08019e23' ... '120f1b6f40f9799355ce54185b4415be37ca2cee6e0' ... 'e010001034cb5abf6ad79fbf5abbccafcc269d85cd2' ... '651ed4b885b5869f241aedf0a5ba290000000000000' ... '0000000000000000000000000000000000000000000' ... '0000000200000000000000000000000000000000000' ... '0000000000000000000000000000000000000000000' ... '0000000000000000000000000000000000000000000' ... '000000301020200010c02000000e803000000000000' ... ) >>> type(Transaction.deserialize(raw_transaction)) <class 'solana.transaction.Transaction'> Returns: The deserialized transaction. \"\"\" return cls . from_solders ( SoldersTx . from_bytes ( raw_transaction )) from_solders ( txn ) classmethod Convert from a solders transaction. Parameters: Name Type Description Default txn SoldersTx The solders transaction. required Returns: Type Description Transaction The solana-py transaction. Source code in solana/transaction.py @classmethod def from_solders ( cls , txn : SoldersTx ) -> Transaction : \"\"\"Convert from a `solders` transaction. Args: txn: The `solders` transaction. Returns: The `solana-py` transaction. \"\"\" new_tx = cls () new_tx . _solders = txn return new_tx populate ( message , signatures ) classmethod Populate Transaction object from message and signatures. Examples: >>> raw_message = bytes . fromhex ( ... '0200030500000000000000000000000000000000000000000000' ... '0000000000000000000100000000000000000000000000000000' ... '0000000000000000000000000000000200000000000000000000' ... '0000000000000000000000000000000000000000000300000000' ... '0000000000000000000000000000000000000000000000000000' ... '0004000000000000000000000000000000000000000000000000' ... '0000000000000005c49ae77603782054f17a9decea43b444eba0' ... 'edb12c6f1d31c6e0e4a84bf052eb010403010203050909090909' ... ) >>> from solana.message import Message >>> from solders.signature import Signature >>> msg = Message . deserialize ( raw_message ) >>> signatures = [ Signature ( bytes ([ 1 ] * SIG_LENGTH )), Signature ( bytes ([ 2 ] * SIG_LENGTH ))] >>> type ( Transaction . populate ( msg , signatures )) < class ' solana . transaction . Transaction '> Returns: Type Description Transaction The populated transaction. Source code in solana/transaction.py @classmethod def populate ( cls , message : Message , signatures : List [ Signature ]) -> Transaction : \"\"\"Populate Transaction object from message and signatures. Example: >>> raw_message = bytes.fromhex( ... '0200030500000000000000000000000000000000000000000000' ... '0000000000000000000100000000000000000000000000000000' ... '0000000000000000000000000000000200000000000000000000' ... '0000000000000000000000000000000000000000000300000000' ... '0000000000000000000000000000000000000000000000000000' ... '0004000000000000000000000000000000000000000000000000' ... '0000000000000005c49ae77603782054f17a9decea43b444eba0' ... 'edb12c6f1d31c6e0e4a84bf052eb010403010203050909090909' ... ) >>> from solana.message import Message >>> from solders.signature import Signature >>> msg = Message.deserialize(raw_message) >>> signatures = [Signature(bytes([1] * SIG_LENGTH)), Signature(bytes([2] * SIG_LENGTH))] >>> type(Transaction.populate(msg, signatures)) <class 'solana.transaction.Transaction'> Returns: The populated transaction. \"\"\" message_underlying = message . to_solders () return cls . from_solders ( SoldersTx . populate ( message_underlying , signatures )) serialize ( self , verify_signatures = True ) Serialize the Transaction in the wire format. The Transaction must have a valid signature before invoking this method. verify_signatures can be added if the signature does not require to be verified. Parameters: Name Type Description Default verify_signatures bool a bool indicating to verify the signature or not. Defaults to True True Examples: >>> from solana.keypair import Keypair >>> from solana.blockhash import Blockhash >>> from solana.publickey import PublicKey >>> from solana.system_program import transfer , TransferParams >>> seed = bytes ( PublicKey ( 1 )) >>> sender , receiver = Keypair . from_seed ( seed ), PublicKey ( 2 ) >>> transfer_tx = Transaction () . add ( transfer ( TransferParams ( from_pubkey = sender . public_key , to_pubkey = receiver , lamports = 1000 ))) >>> transfer_tx . recent_blockhash = Blockhash ( str ( PublicKey ( 3 ))) >>> transfer_tx . sign ( sender ) >>> transfer_tx . serialize () . hex () '019d53be8af3a7c30f86c1092d2c3ea61d270c0cfa275a23ba504674c8fbbb724827b23b42dc8e08019e23120f1b6f40f9799355ce54185b4415be37ca2cee6e0e010001034cb5abf6ad79fbf5abbccafcc269d85cd2651ed4b885b5869f241aedf0a5ba2900000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000301020200010c02000000e803000000000000' Returns: Type Description bytes The serialized transaction. Source code in solana/transaction.py def serialize ( self , verify_signatures : bool = True ) -> bytes : \"\"\"Serialize the Transaction in the wire format. The Transaction must have a valid `signature` before invoking this method. verify_signatures can be added if the signature does not require to be verified. Args: verify_signatures: a bool indicating to verify the signature or not. Defaults to True Example: >>> from solana.keypair import Keypair >>> from solana.blockhash import Blockhash >>> from solana.publickey import PublicKey >>> from solana.system_program import transfer, TransferParams >>> seed = bytes(PublicKey(1)) >>> sender, receiver = Keypair.from_seed(seed), PublicKey(2) >>> transfer_tx = Transaction().add(transfer(TransferParams(from_pubkey=sender.public_key, to_pubkey=receiver, lamports=1000))) >>> transfer_tx.recent_blockhash = Blockhash(str(PublicKey(3))) >>> transfer_tx.sign(sender) >>> transfer_tx.serialize().hex() '019d53be8af3a7c30f86c1092d2c3ea61d270c0cfa275a23ba504674c8fbbb724827b23b42dc8e08019e23120f1b6f40f9799355ce54185b4415be37ca2cee6e0e010001034cb5abf6ad79fbf5abbccafcc269d85cd2651ed4b885b5869f241aedf0a5ba2900000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000301020200010c02000000e803000000000000' Returns: The serialized transaction. \"\"\" # noqa: E501 pylint: disable=line-too-long if self . signatures == [ Signature . default () for sig in self . signatures ]: raise AttributeError ( \"transaction has not been signed\" ) if verify_signatures : if not self . verify_signatures (): raise AttributeError ( \"transaction has not been signed correctly\" ) return bytes ( self . _solders ) serialize_message ( self ) Get raw transaction data that need to be covered by signatures. Returns: Type Description bytes The serialized message. Source code in solana/transaction.py def serialize_message ( self ) -> bytes : \"\"\"Get raw transaction data that need to be covered by signatures. Returns: The serialized message. \"\"\" return self . compile_message () . serialize () sign ( self , * signers ) Sign the Transaction with the specified accounts. Multiple signatures may be applied to a Transaction. The first signature is considered \"primary\" and is used when testing for Transaction confirmation. Transaction fields should not be modified after the first call to sign , as doing so may invalidate the signature and cause the Transaction to be rejected. The Transaction must be assigned a valid recent_blockhash before invoking this method. Source code in solana/transaction.py def sign ( self , * signers : Keypair ) -> None : \"\"\"Sign the Transaction with the specified accounts. Multiple signatures may be applied to a Transaction. The first signature is considered \"primary\" and is used when testing for Transaction confirmation. Transaction fields should not be modified after the first call to `sign`, as doing so may invalidate the signature and cause the Transaction to be rejected. The Transaction must be assigned a valid `recent_blockhash` before invoking this method. \"\"\" underlying_signers = [ signer . to_solders () for signer in signers ] self . _solders . sign ( underlying_signers , self . _solders . message . recent_blockhash ) sign_partial ( self , * partial_signers ) Partially sign a Transaction with the specified keypairs. All the caveats from the sign method apply to sign_partial Source code in solana/transaction.py def sign_partial ( self , * partial_signers : Keypair ) -> None : \"\"\"Partially sign a Transaction with the specified keypairs. All the caveats from the `sign` method apply to `sign_partial` \"\"\" underlying_signers = [ signer . to_solders () for signer in partial_signers ] self . _solders . partial_sign ( underlying_signers , self . _solders . message . recent_blockhash ) signature ( self ) The first (payer) Transaction signature. Returns: Type Description Signature The payer signature. Source code in solana/transaction.py def signature ( self ) -> Signature : \"\"\"The first (payer) Transaction signature. Returns: The payer signature. \"\"\" return self . _solders . signatures [ 0 ] to_solders ( self ) Convert to a solders transaction. Returns: Type Description SoldersTx The solders transaction. Source code in solana/transaction.py def to_solders ( self ) -> SoldersTx : \"\"\"Convert to a `solders` transaction. Returns: The `solders` transaction. \"\"\" return self . _solders verify_signatures ( self ) Verify signatures of a complete, signed Transaction. Returns: Type Description bool a bool indicating if the signatures are correct or not. Source code in solana/transaction.py def verify_signatures ( self ) -> bool : \"\"\"Verify signatures of a complete, signed Transaction. Returns: a bool indicating if the signatures are correct or not. \"\"\" try : self . _solders . verify () except TransactionError : return False return True TransactionInstruction Transaction Instruction class. Source code in solana/transaction.py class TransactionInstruction ( NamedTuple ): \"\"\"Transaction Instruction class.\"\"\" keys : List [ AccountMeta ] \"\"\"Public keys to include in this transaction Boolean represents whether this pubkey needs to sign the transaction. \"\"\" program_id : PublicKey \"\"\"Program Id to execute.\"\"\" data : bytes = bytes ( 0 ) \"\"\"Program input.\"\"\" @classmethod def from_solders ( cls , ixn : instruction . Instruction ) -> TransactionInstruction : \"\"\"Convert from a `solders` instruction. Args: ixn: The `solders` instruction. Returns: The `solana-py` instruction. \"\"\" keys = [ AccountMeta . from_solders ( am ) for am in ixn . accounts ] program_id = PublicKey . from_solders ( ixn . program_id ) return cls ( keys = keys , program_id = program_id , data = ixn . data ) def to_solders ( self ) -> instruction . Instruction : \"\"\"Convert to a `solders` instruction. Returns: The `solders` instruction. \"\"\" accounts = [ key . to_solders () for key in self . keys ] return instruction . Instruction ( program_id = self . program_id . to_solders (), data = self . data , accounts = accounts ) data : bytes Program input. keys : List [ solana . transaction . AccountMeta ] Public keys to include in this transaction Boolean represents whether this pubkey needs to sign the transaction. program_id : PublicKey Program Id to execute. from_solders ( ixn ) classmethod Convert from a solders instruction. Parameters: Name Type Description Default ixn instruction.Instruction The solders instruction. required Returns: Type Description TransactionInstruction The solana-py instruction. Source code in solana/transaction.py @classmethod def from_solders ( cls , ixn : instruction . Instruction ) -> TransactionInstruction : \"\"\"Convert from a `solders` instruction. Args: ixn: The `solders` instruction. Returns: The `solana-py` instruction. \"\"\" keys = [ AccountMeta . from_solders ( am ) for am in ixn . accounts ] program_id = PublicKey . from_solders ( ixn . program_id ) return cls ( keys = keys , program_id = program_id , data = ixn . data ) to_solders ( self ) Convert to a solders instruction. Returns: Type Description instruction.Instruction The solders instruction. Source code in solana/transaction.py def to_solders ( self ) -> instruction . Instruction : \"\"\"Convert to a `solders` instruction. Returns: The `solders` instruction. \"\"\" accounts = [ key . to_solders () for key in self . keys ] return instruction . Instruction ( program_id = self . program_id . to_solders (), data = self . data , accounts = accounts )","title":"Transaction"},{"location":"core/transaction/#transaction","text":"","title":"Transaction"},{"location":"core/transaction/#solana.transaction","text":"Library to package an atomic sequence of instructions to a transaction.","title":"transaction"},{"location":"core/transaction/#solana.transaction.PACKET_DATA_SIZE","text":"Constant for maximum over-the-wire size of a Transaction.","title":"PACKET_DATA_SIZE"},{"location":"core/transaction/#solana.transaction.SIG_LENGTH","text":"Constant for standard length of a signature.","title":"SIG_LENGTH"},{"location":"core/transaction/#solana.transaction.TransactionSignature","text":"Type for TransactionSignature.","title":"TransactionSignature"},{"location":"core/transaction/#solana.transaction.AccountMeta","text":"Account metadata dataclass. Source code in solana/transaction.py @dataclass class AccountMeta : \"\"\"Account metadata dataclass.\"\"\" pubkey : PublicKey \"\"\"An account's public key.\"\"\" is_signer : bool \"\"\"True if an instruction requires a transaction signature matching `pubkey`\"\"\" is_writable : bool \"\"\"True if the `pubkey` can be loaded as a read-write account.\"\"\" @classmethod def from_solders ( cls , meta : instruction . AccountMeta ) -> AccountMeta : \"\"\"Convert from a `solders` AccountMeta. Args: meta: The `solders` AccountMeta. Returns: The `solana-py` AccountMeta. \"\"\" return cls ( pubkey = PublicKey . from_solders ( meta . pubkey ), is_signer = meta . is_signer , is_writable = meta . is_writable ) def to_solders ( self ) -> instruction . AccountMeta : \"\"\"Convert to a `solders` AccountMeta. Returns: The `solders` AccountMeta. \"\"\" return instruction . AccountMeta ( pubkey = self . pubkey . to_solders (), is_signer = self . is_signer , is_writable = self . is_writable )","title":"AccountMeta"},{"location":"core/transaction/#solana.transaction.AccountMeta.is_signer","text":"True if an instruction requires a transaction signature matching pubkey","title":"is_signer"},{"location":"core/transaction/#solana.transaction.AccountMeta.is_writable","text":"True if the pubkey can be loaded as a read-write account.","title":"is_writable"},{"location":"core/transaction/#solana.transaction.AccountMeta.pubkey","text":"An account's public key.","title":"pubkey"},{"location":"core/transaction/#solana.transaction.AccountMeta.from_solders","text":"Convert from a solders AccountMeta. Parameters: Name Type Description Default meta instruction.AccountMeta The solders AccountMeta. required Returns: Type Description AccountMeta The solana-py AccountMeta. Source code in solana/transaction.py @classmethod def from_solders ( cls , meta : instruction . AccountMeta ) -> AccountMeta : \"\"\"Convert from a `solders` AccountMeta. Args: meta: The `solders` AccountMeta. Returns: The `solana-py` AccountMeta. \"\"\" return cls ( pubkey = PublicKey . from_solders ( meta . pubkey ), is_signer = meta . is_signer , is_writable = meta . is_writable )","title":"from_solders()"},{"location":"core/transaction/#solana.transaction.AccountMeta.to_solders","text":"Convert to a solders AccountMeta. Returns: Type Description instruction.AccountMeta The solders AccountMeta. Source code in solana/transaction.py def to_solders ( self ) -> instruction . AccountMeta : \"\"\"Convert to a `solders` AccountMeta. Returns: The `solders` AccountMeta. \"\"\" return instruction . AccountMeta ( pubkey = self . pubkey . to_solders (), is_signer = self . is_signer , is_writable = self . is_writable )","title":"to_solders()"},{"location":"core/transaction/#solana.transaction.NonceInformation","text":"NonceInformation to be used to build a Transaction. Source code in solana/transaction.py class NonceInformation ( NamedTuple ): \"\"\"NonceInformation to be used to build a Transaction.\"\"\" nonce : Blockhash \"\"\"The current Nonce blockhash.\"\"\" nonce_instruction : TransactionInstruction \"\"\"AdvanceNonceAccount Instruction.\"\"\"","title":"NonceInformation"},{"location":"core/transaction/#solana.transaction.NonceInformation.nonce","text":"The current Nonce blockhash.","title":"nonce"},{"location":"core/transaction/#solana.transaction.NonceInformation.nonce_instruction","text":"AdvanceNonceAccount Instruction.","title":"nonce_instruction"},{"location":"core/transaction/#solana.transaction.SigPubkeyPair","text":"Pair of signature and corresponding public key. Source code in solana/transaction.py @dataclass class SigPubkeyPair : \"\"\"Pair of signature and corresponding public key.\"\"\" pubkey : PublicKey signature : Optional [ bytes ] = None","title":"SigPubkeyPair"},{"location":"core/transaction/#solana.transaction.Transaction","text":"Transaction class to represent an atomic transaction. Parameters: Name Type Description Default recent_blockhash Optional[Blockhash] A recent transaction id. None nonce_info Optional[NonceInformation] Nonce information. If populated, transaction will use a durable Nonce hash instead of a recent_blockhash . None fee_payer Optional[PublicKey] The transaction fee payer. None instructions Optional[Sequence[TransactionInstruction]] The instructions to be executed in this transaction. None Source code in solana/transaction.py class Transaction : \"\"\"Transaction class to represent an atomic transaction. Args: recent_blockhash: A recent transaction id. nonce_info: Nonce information. If populated, transaction will use a durable Nonce hash instead of a `recent_blockhash`. fee_payer: The transaction fee payer. instructions: The instructions to be executed in this transaction. \"\"\" # Default (empty) signature __DEFAULT_SIG = bytes ( 64 ) def __init__ ( self , recent_blockhash : Optional [ Blockhash ] = None , nonce_info : Optional [ NonceInformation ] = None , fee_payer : Optional [ PublicKey ] = None , instructions : Optional [ Sequence [ TransactionInstruction ]] = None , ) -> None : \"\"\"Init transaction object.\"\"\" self . _solders = _build_solders_tx ( recent_blockhash = recent_blockhash , nonce_info = nonce_info , fee_payer = fee_payer , instructions = instructions ) @classmethod def from_solders ( cls , txn : SoldersTx ) -> Transaction : \"\"\"Convert from a `solders` transaction. Args: txn: The `solders` transaction. Returns: The `solana-py` transaction. \"\"\" new_tx = cls () new_tx . _solders = txn return new_tx def to_solders ( self ) -> SoldersTx : \"\"\"Convert to a `solders` transaction. Returns: The `solders` transaction. \"\"\" return self . _solders def __eq__ ( self , other : Any ) -> bool : \"\"\"Equality defintion for Transactions.\"\"\" if not isinstance ( other , Transaction ): return False return self . to_solders () == other . to_solders () @property def recent_blockhash ( self ) -> Optional [ Blockhash ]: \"\"\"Optional[Blockhash]: The blockhash assigned to this transaction.\"\"\" return Blockhash ( str ( self . _solders . message . recent_blockhash )) @recent_blockhash . setter def recent_blockhash ( self , blockhash : Optional [ Blockhash ]) -> None : self . _solders = _build_solders_tx ( recent_blockhash = blockhash , nonce_info = None , fee_payer = self . fee_payer , instructions = self . instructions ) @property def fee_payer ( self ) -> Optional [ PublicKey ]: \"\"\"Optional[PublicKey]: The transaction fee payer.\"\"\" account_keys = self . _solders . message . account_keys return PublicKey . from_solders ( account_keys [ 0 ]) if account_keys else None @fee_payer . setter def fee_payer ( self , payer : Optional [ PublicKey ]) -> None : self . _solders = _build_solders_tx ( recent_blockhash = self . recent_blockhash , nonce_info = None , fee_payer = payer , instructions = self . instructions ) @property def instructions ( self ) -> Tuple [ TransactionInstruction , ... ]: \"\"\"Tuple[TransactionInstruction]: The instructions contained in this transaction.\"\"\" msg = self . _solders . message return tuple ( _decompile_instructions ( msg )) @instructions . setter def instructions ( self , ixns : Sequence [ TransactionInstruction ]) -> None : self . _solders = _build_solders_tx ( recent_blockhash = self . recent_blockhash , nonce_info = None , fee_payer = self . fee_payer , instructions = ixns ) @property def signatures ( self ) -> Tuple [ Signature , ... ]: \"\"\"Tuple[Signature]: Signatures for the transaction.\"\"\" return tuple ( self . _solders . signatures ) def signature ( self ) -> Signature : \"\"\"The first (payer) Transaction signature. Returns: The payer signature. \"\"\" return self . _solders . signatures [ 0 ] def add ( self , * args : Union [ Transaction , TransactionInstruction ]) -> Transaction : \"\"\"Add one or more instructions to this Transaction. Args: *args: The instructions to add to this Transaction. If a `Transaction` is passsed, the instructions will be extracted from it. Returns: The transaction with the added instructions. \"\"\" for arg in args : if isinstance ( arg , Transaction ): self . instructions = self . instructions + arg . instructions elif isinstance ( arg , TransactionInstruction ): self . instructions = ( * self . instructions , arg ) else : raise ValueError ( \"invalid instruction:\" , arg ) return self def compile_message ( self ) -> Message : # pylint: disable=too-many-locals \"\"\"Compile transaction data. Returns: The compiled message. \"\"\" return Message . from_solders ( self . _solders . message ) def serialize_message ( self ) -> bytes : \"\"\"Get raw transaction data that need to be covered by signatures. Returns: The serialized message. \"\"\" return self . compile_message () . serialize () def sign_partial ( self , * partial_signers : Keypair ) -> None : \"\"\"Partially sign a Transaction with the specified keypairs. All the caveats from the `sign` method apply to `sign_partial` \"\"\" underlying_signers = [ signer . to_solders () for signer in partial_signers ] self . _solders . partial_sign ( underlying_signers , self . _solders . message . recent_blockhash ) def sign ( self , * signers : Keypair ) -> None : \"\"\"Sign the Transaction with the specified accounts. Multiple signatures may be applied to a Transaction. The first signature is considered \"primary\" and is used when testing for Transaction confirmation. Transaction fields should not be modified after the first call to `sign`, as doing so may invalidate the signature and cause the Transaction to be rejected. The Transaction must be assigned a valid `recent_blockhash` before invoking this method. \"\"\" underlying_signers = [ signer . to_solders () for signer in signers ] self . _solders . sign ( underlying_signers , self . _solders . message . recent_blockhash ) def add_signature ( self , pubkey : PublicKey , signature : Signature ) -> None : \"\"\"Add an externally created signature to a transaction. Args: pubkey: The public key that created the signature. signature: The signature to add. \"\"\" presigner = Presigner ( pubkey . to_solders (), signature ) self . _solders . partial_sign ([ presigner ], self . _solders . message . recent_blockhash ) def verify_signatures ( self ) -> bool : \"\"\"Verify signatures of a complete, signed Transaction. Returns: a bool indicating if the signatures are correct or not. \"\"\" try : self . _solders . verify () except TransactionError : return False return True def serialize ( self , verify_signatures : bool = True ) -> bytes : \"\"\"Serialize the Transaction in the wire format. The Transaction must have a valid `signature` before invoking this method. verify_signatures can be added if the signature does not require to be verified. Args: verify_signatures: a bool indicating to verify the signature or not. Defaults to True Example: >>> from solana.keypair import Keypair >>> from solana.blockhash import Blockhash >>> from solana.publickey import PublicKey >>> from solana.system_program import transfer, TransferParams >>> seed = bytes(PublicKey(1)) >>> sender, receiver = Keypair.from_seed(seed), PublicKey(2) >>> transfer_tx = Transaction().add(transfer(TransferParams(from_pubkey=sender.public_key, to_pubkey=receiver, lamports=1000))) >>> transfer_tx.recent_blockhash = Blockhash(str(PublicKey(3))) >>> transfer_tx.sign(sender) >>> transfer_tx.serialize().hex() '019d53be8af3a7c30f86c1092d2c3ea61d270c0cfa275a23ba504674c8fbbb724827b23b42dc8e08019e23120f1b6f40f9799355ce54185b4415be37ca2cee6e0e010001034cb5abf6ad79fbf5abbccafcc269d85cd2651ed4b885b5869f241aedf0a5ba2900000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000301020200010c02000000e803000000000000' Returns: The serialized transaction. \"\"\" # noqa: E501 pylint: disable=line-too-long if self . signatures == [ Signature . default () for sig in self . signatures ]: raise AttributeError ( \"transaction has not been signed\" ) if verify_signatures : if not self . verify_signatures (): raise AttributeError ( \"transaction has not been signed correctly\" ) return bytes ( self . _solders ) @classmethod def deserialize ( cls , raw_transaction : bytes ) -> Transaction : \"\"\"Parse a wire transaction into a Transaction object. Example: >>> raw_transaction = bytes.fromhex( ... '019d53be8af3a7c30f86c1092d2c3ea61d270c0cfa2' ... '75a23ba504674c8fbbb724827b23b42dc8e08019e23' ... '120f1b6f40f9799355ce54185b4415be37ca2cee6e0' ... 'e010001034cb5abf6ad79fbf5abbccafcc269d85cd2' ... '651ed4b885b5869f241aedf0a5ba290000000000000' ... '0000000000000000000000000000000000000000000' ... '0000000200000000000000000000000000000000000' ... '0000000000000000000000000000000000000000000' ... '0000000000000000000000000000000000000000000' ... '000000301020200010c02000000e803000000000000' ... ) >>> type(Transaction.deserialize(raw_transaction)) <class 'solana.transaction.Transaction'> Returns: The deserialized transaction. \"\"\" return cls . from_solders ( SoldersTx . from_bytes ( raw_transaction )) @classmethod def populate ( cls , message : Message , signatures : List [ Signature ]) -> Transaction : \"\"\"Populate Transaction object from message and signatures. Example: >>> raw_message = bytes.fromhex( ... '0200030500000000000000000000000000000000000000000000' ... '0000000000000000000100000000000000000000000000000000' ... '0000000000000000000000000000000200000000000000000000' ... '0000000000000000000000000000000000000000000300000000' ... '0000000000000000000000000000000000000000000000000000' ... '0004000000000000000000000000000000000000000000000000' ... '0000000000000005c49ae77603782054f17a9decea43b444eba0' ... 'edb12c6f1d31c6e0e4a84bf052eb010403010203050909090909' ... ) >>> from solana.message import Message >>> from solders.signature import Signature >>> msg = Message.deserialize(raw_message) >>> signatures = [Signature(bytes([1] * SIG_LENGTH)), Signature(bytes([2] * SIG_LENGTH))] >>> type(Transaction.populate(msg, signatures)) <class 'solana.transaction.Transaction'> Returns: The populated transaction. \"\"\" message_underlying = message . to_solders () return cls . from_solders ( SoldersTx . populate ( message_underlying , signatures ))","title":"Transaction"},{"location":"core/transaction/#solana.transaction.Transaction.fee_payer","text":"Optional[PublicKey]: The transaction fee payer.","title":"fee_payer"},{"location":"core/transaction/#solana.transaction.Transaction.instructions","text":"Tuple[TransactionInstruction]: The instructions contained in this transaction.","title":"instructions"},{"location":"core/transaction/#solana.transaction.Transaction.recent_blockhash","text":"Optional[Blockhash]: The blockhash assigned to this transaction.","title":"recent_blockhash"},{"location":"core/transaction/#solana.transaction.Transaction.signatures","text":"Tuple[Signature]: Signatures for the transaction.","title":"signatures"},{"location":"core/transaction/#solana.transaction.Transaction.__init__","text":"Init transaction object. Source code in solana/transaction.py def __init__ ( self , recent_blockhash : Optional [ Blockhash ] = None , nonce_info : Optional [ NonceInformation ] = None , fee_payer : Optional [ PublicKey ] = None , instructions : Optional [ Sequence [ TransactionInstruction ]] = None , ) -> None : \"\"\"Init transaction object.\"\"\" self . _solders = _build_solders_tx ( recent_blockhash = recent_blockhash , nonce_info = nonce_info , fee_payer = fee_payer , instructions = instructions )","title":"__init__()"},{"location":"core/transaction/#solana.transaction.Transaction.add","text":"Add one or more instructions to this Transaction. Parameters: Name Type Description Default *args Union[Transaction, TransactionInstruction] The instructions to add to this Transaction. If a Transaction is passsed, the instructions will be extracted from it. () Returns: Type Description Transaction The transaction with the added instructions. Source code in solana/transaction.py def add ( self , * args : Union [ Transaction , TransactionInstruction ]) -> Transaction : \"\"\"Add one or more instructions to this Transaction. Args: *args: The instructions to add to this Transaction. If a `Transaction` is passsed, the instructions will be extracted from it. Returns: The transaction with the added instructions. \"\"\" for arg in args : if isinstance ( arg , Transaction ): self . instructions = self . instructions + arg . instructions elif isinstance ( arg , TransactionInstruction ): self . instructions = ( * self . instructions , arg ) else : raise ValueError ( \"invalid instruction:\" , arg ) return self","title":"add()"},{"location":"core/transaction/#solana.transaction.Transaction.add_signature","text":"Add an externally created signature to a transaction. Parameters: Name Type Description Default pubkey PublicKey The public key that created the signature. required signature Signature The signature to add. required Source code in solana/transaction.py def add_signature ( self , pubkey : PublicKey , signature : Signature ) -> None : \"\"\"Add an externally created signature to a transaction. Args: pubkey: The public key that created the signature. signature: The signature to add. \"\"\" presigner = Presigner ( pubkey . to_solders (), signature ) self . _solders . partial_sign ([ presigner ], self . _solders . message . recent_blockhash )","title":"add_signature()"},{"location":"core/transaction/#solana.transaction.Transaction.compile_message","text":"Compile transaction data. Returns: Type Description Message The compiled message. Source code in solana/transaction.py def compile_message ( self ) -> Message : # pylint: disable=too-many-locals \"\"\"Compile transaction data. Returns: The compiled message. \"\"\" return Message . from_solders ( self . _solders . message )","title":"compile_message()"},{"location":"core/transaction/#solana.transaction.Transaction.deserialize","text":"Parse a wire transaction into a Transaction object. Examples: >>> raw_transaction = bytes . fromhex ( ... '019d53be8af3a7c30f86c1092d2c3ea61d270c0cfa2' ... '75a23ba504674c8fbbb724827b23b42dc8e08019e23' ... '120f1b6f40f9799355ce54185b4415be37ca2cee6e0' ... 'e010001034cb5abf6ad79fbf5abbccafcc269d85cd2' ... '651ed4b885b5869f241aedf0a5ba290000000000000' ... '0000000000000000000000000000000000000000000' ... '0000000200000000000000000000000000000000000' ... '0000000000000000000000000000000000000000000' ... '0000000000000000000000000000000000000000000' ... '000000301020200010c02000000e803000000000000' ... ) >>> type ( Transaction . deserialize ( raw_transaction )) < class ' solana . transaction . Transaction '> Returns: Type Description Transaction The deserialized transaction. Source code in solana/transaction.py @classmethod def deserialize ( cls , raw_transaction : bytes ) -> Transaction : \"\"\"Parse a wire transaction into a Transaction object. Example: >>> raw_transaction = bytes.fromhex( ... '019d53be8af3a7c30f86c1092d2c3ea61d270c0cfa2' ... '75a23ba504674c8fbbb724827b23b42dc8e08019e23' ... '120f1b6f40f9799355ce54185b4415be37ca2cee6e0' ... 'e010001034cb5abf6ad79fbf5abbccafcc269d85cd2' ... '651ed4b885b5869f241aedf0a5ba290000000000000' ... '0000000000000000000000000000000000000000000' ... '0000000200000000000000000000000000000000000' ... '0000000000000000000000000000000000000000000' ... '0000000000000000000000000000000000000000000' ... '000000301020200010c02000000e803000000000000' ... ) >>> type(Transaction.deserialize(raw_transaction)) <class 'solana.transaction.Transaction'> Returns: The deserialized transaction. \"\"\" return cls . from_solders ( SoldersTx . from_bytes ( raw_transaction ))","title":"deserialize()"},{"location":"core/transaction/#solana.transaction.Transaction.from_solders","text":"Convert from a solders transaction. Parameters: Name Type Description Default txn SoldersTx The solders transaction. required Returns: Type Description Transaction The solana-py transaction. Source code in solana/transaction.py @classmethod def from_solders ( cls , txn : SoldersTx ) -> Transaction : \"\"\"Convert from a `solders` transaction. Args: txn: The `solders` transaction. Returns: The `solana-py` transaction. \"\"\" new_tx = cls () new_tx . _solders = txn return new_tx","title":"from_solders()"},{"location":"core/transaction/#solana.transaction.Transaction.populate","text":"Populate Transaction object from message and signatures. Examples: >>> raw_message = bytes . fromhex ( ... '0200030500000000000000000000000000000000000000000000' ... '0000000000000000000100000000000000000000000000000000' ... '0000000000000000000000000000000200000000000000000000' ... '0000000000000000000000000000000000000000000300000000' ... '0000000000000000000000000000000000000000000000000000' ... '0004000000000000000000000000000000000000000000000000' ... '0000000000000005c49ae77603782054f17a9decea43b444eba0' ... 'edb12c6f1d31c6e0e4a84bf052eb010403010203050909090909' ... ) >>> from solana.message import Message >>> from solders.signature import Signature >>> msg = Message . deserialize ( raw_message ) >>> signatures = [ Signature ( bytes ([ 1 ] * SIG_LENGTH )), Signature ( bytes ([ 2 ] * SIG_LENGTH ))] >>> type ( Transaction . populate ( msg , signatures )) < class ' solana . transaction . Transaction '> Returns: Type Description Transaction The populated transaction. Source code in solana/transaction.py @classmethod def populate ( cls , message : Message , signatures : List [ Signature ]) -> Transaction : \"\"\"Populate Transaction object from message and signatures. Example: >>> raw_message = bytes.fromhex( ... '0200030500000000000000000000000000000000000000000000' ... '0000000000000000000100000000000000000000000000000000' ... '0000000000000000000000000000000200000000000000000000' ... '0000000000000000000000000000000000000000000300000000' ... '0000000000000000000000000000000000000000000000000000' ... '0004000000000000000000000000000000000000000000000000' ... '0000000000000005c49ae77603782054f17a9decea43b444eba0' ... 'edb12c6f1d31c6e0e4a84bf052eb010403010203050909090909' ... ) >>> from solana.message import Message >>> from solders.signature import Signature >>> msg = Message.deserialize(raw_message) >>> signatures = [Signature(bytes([1] * SIG_LENGTH)), Signature(bytes([2] * SIG_LENGTH))] >>> type(Transaction.populate(msg, signatures)) <class 'solana.transaction.Transaction'> Returns: The populated transaction. \"\"\" message_underlying = message . to_solders () return cls . from_solders ( SoldersTx . populate ( message_underlying , signatures ))","title":"populate()"},{"location":"core/transaction/#solana.transaction.Transaction.serialize","text":"Serialize the Transaction in the wire format. The Transaction must have a valid signature before invoking this method. verify_signatures can be added if the signature does not require to be verified. Parameters: Name Type Description Default verify_signatures bool a bool indicating to verify the signature or not. Defaults to True True Examples: >>> from solana.keypair import Keypair >>> from solana.blockhash import Blockhash >>> from solana.publickey import PublicKey >>> from solana.system_program import transfer , TransferParams >>> seed = bytes ( PublicKey ( 1 )) >>> sender , receiver = Keypair . from_seed ( seed ), PublicKey ( 2 ) >>> transfer_tx = Transaction () . add ( transfer ( TransferParams ( from_pubkey = sender . public_key , to_pubkey = receiver , lamports = 1000 ))) >>> transfer_tx . recent_blockhash = Blockhash ( str ( PublicKey ( 3 ))) >>> transfer_tx . sign ( sender ) >>> transfer_tx . serialize () . hex () '019d53be8af3a7c30f86c1092d2c3ea61d270c0cfa275a23ba504674c8fbbb724827b23b42dc8e08019e23120f1b6f40f9799355ce54185b4415be37ca2cee6e0e010001034cb5abf6ad79fbf5abbccafcc269d85cd2651ed4b885b5869f241aedf0a5ba2900000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000301020200010c02000000e803000000000000' Returns: Type Description bytes The serialized transaction. Source code in solana/transaction.py def serialize ( self , verify_signatures : bool = True ) -> bytes : \"\"\"Serialize the Transaction in the wire format. The Transaction must have a valid `signature` before invoking this method. verify_signatures can be added if the signature does not require to be verified. Args: verify_signatures: a bool indicating to verify the signature or not. Defaults to True Example: >>> from solana.keypair import Keypair >>> from solana.blockhash import Blockhash >>> from solana.publickey import PublicKey >>> from solana.system_program import transfer, TransferParams >>> seed = bytes(PublicKey(1)) >>> sender, receiver = Keypair.from_seed(seed), PublicKey(2) >>> transfer_tx = Transaction().add(transfer(TransferParams(from_pubkey=sender.public_key, to_pubkey=receiver, lamports=1000))) >>> transfer_tx.recent_blockhash = Blockhash(str(PublicKey(3))) >>> transfer_tx.sign(sender) >>> transfer_tx.serialize().hex() '019d53be8af3a7c30f86c1092d2c3ea61d270c0cfa275a23ba504674c8fbbb724827b23b42dc8e08019e23120f1b6f40f9799355ce54185b4415be37ca2cee6e0e010001034cb5abf6ad79fbf5abbccafcc269d85cd2651ed4b885b5869f241aedf0a5ba2900000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000301020200010c02000000e803000000000000' Returns: The serialized transaction. \"\"\" # noqa: E501 pylint: disable=line-too-long if self . signatures == [ Signature . default () for sig in self . signatures ]: raise AttributeError ( \"transaction has not been signed\" ) if verify_signatures : if not self . verify_signatures (): raise AttributeError ( \"transaction has not been signed correctly\" ) return bytes ( self . _solders )","title":"serialize()"},{"location":"core/transaction/#solana.transaction.Transaction.serialize_message","text":"Get raw transaction data that need to be covered by signatures. Returns: Type Description bytes The serialized message. Source code in solana/transaction.py def serialize_message ( self ) -> bytes : \"\"\"Get raw transaction data that need to be covered by signatures. Returns: The serialized message. \"\"\" return self . compile_message () . serialize ()","title":"serialize_message()"},{"location":"core/transaction/#solana.transaction.Transaction.sign","text":"Sign the Transaction with the specified accounts. Multiple signatures may be applied to a Transaction. The first signature is considered \"primary\" and is used when testing for Transaction confirmation. Transaction fields should not be modified after the first call to sign , as doing so may invalidate the signature and cause the Transaction to be rejected. The Transaction must be assigned a valid recent_blockhash before invoking this method. Source code in solana/transaction.py def sign ( self , * signers : Keypair ) -> None : \"\"\"Sign the Transaction with the specified accounts. Multiple signatures may be applied to a Transaction. The first signature is considered \"primary\" and is used when testing for Transaction confirmation. Transaction fields should not be modified after the first call to `sign`, as doing so may invalidate the signature and cause the Transaction to be rejected. The Transaction must be assigned a valid `recent_blockhash` before invoking this method. \"\"\" underlying_signers = [ signer . to_solders () for signer in signers ] self . _solders . sign ( underlying_signers , self . _solders . message . recent_blockhash )","title":"sign()"},{"location":"core/transaction/#solana.transaction.Transaction.sign_partial","text":"Partially sign a Transaction with the specified keypairs. All the caveats from the sign method apply to sign_partial Source code in solana/transaction.py def sign_partial ( self , * partial_signers : Keypair ) -> None : \"\"\"Partially sign a Transaction with the specified keypairs. All the caveats from the `sign` method apply to `sign_partial` \"\"\" underlying_signers = [ signer . to_solders () for signer in partial_signers ] self . _solders . partial_sign ( underlying_signers , self . _solders . message . recent_blockhash )","title":"sign_partial()"},{"location":"core/transaction/#solana.transaction.Transaction.signature","text":"The first (payer) Transaction signature. Returns: Type Description Signature The payer signature. Source code in solana/transaction.py def signature ( self ) -> Signature : \"\"\"The first (payer) Transaction signature. Returns: The payer signature. \"\"\" return self . _solders . signatures [ 0 ]","title":"signature()"},{"location":"core/transaction/#solana.transaction.Transaction.to_solders","text":"Convert to a solders transaction. Returns: Type Description SoldersTx The solders transaction. Source code in solana/transaction.py def to_solders ( self ) -> SoldersTx : \"\"\"Convert to a `solders` transaction. Returns: The `solders` transaction. \"\"\" return self . _solders","title":"to_solders()"},{"location":"core/transaction/#solana.transaction.Transaction.verify_signatures","text":"Verify signatures of a complete, signed Transaction. Returns: Type Description bool a bool indicating if the signatures are correct or not. Source code in solana/transaction.py def verify_signatures ( self ) -> bool : \"\"\"Verify signatures of a complete, signed Transaction. Returns: a bool indicating if the signatures are correct or not. \"\"\" try : self . _solders . verify () except TransactionError : return False return True","title":"verify_signatures()"},{"location":"core/transaction/#solana.transaction.TransactionInstruction","text":"Transaction Instruction class. Source code in solana/transaction.py class TransactionInstruction ( NamedTuple ): \"\"\"Transaction Instruction class.\"\"\" keys : List [ AccountMeta ] \"\"\"Public keys to include in this transaction Boolean represents whether this pubkey needs to sign the transaction. \"\"\" program_id : PublicKey \"\"\"Program Id to execute.\"\"\" data : bytes = bytes ( 0 ) \"\"\"Program input.\"\"\" @classmethod def from_solders ( cls , ixn : instruction . Instruction ) -> TransactionInstruction : \"\"\"Convert from a `solders` instruction. Args: ixn: The `solders` instruction. Returns: The `solana-py` instruction. \"\"\" keys = [ AccountMeta . from_solders ( am ) for am in ixn . accounts ] program_id = PublicKey . from_solders ( ixn . program_id ) return cls ( keys = keys , program_id = program_id , data = ixn . data ) def to_solders ( self ) -> instruction . Instruction : \"\"\"Convert to a `solders` instruction. Returns: The `solders` instruction. \"\"\" accounts = [ key . to_solders () for key in self . keys ] return instruction . Instruction ( program_id = self . program_id . to_solders (), data = self . data , accounts = accounts )","title":"TransactionInstruction"},{"location":"core/transaction/#solana.transaction.TransactionInstruction.data","text":"Program input.","title":"data"},{"location":"core/transaction/#solana.transaction.TransactionInstruction.keys","text":"Public keys to include in this transaction Boolean represents whether this pubkey needs to sign the transaction.","title":"keys"},{"location":"core/transaction/#solana.transaction.TransactionInstruction.program_id","text":"Program Id to execute.","title":"program_id"},{"location":"core/transaction/#solana.transaction.TransactionInstruction.from_solders","text":"Convert from a solders instruction. Parameters: Name Type Description Default ixn instruction.Instruction The solders instruction. required Returns: Type Description TransactionInstruction The solana-py instruction. Source code in solana/transaction.py @classmethod def from_solders ( cls , ixn : instruction . Instruction ) -> TransactionInstruction : \"\"\"Convert from a `solders` instruction. Args: ixn: The `solders` instruction. Returns: The `solana-py` instruction. \"\"\" keys = [ AccountMeta . from_solders ( am ) for am in ixn . accounts ] program_id = PublicKey . from_solders ( ixn . program_id ) return cls ( keys = keys , program_id = program_id , data = ixn . data )","title":"from_solders()"},{"location":"core/transaction/#solana.transaction.TransactionInstruction.to_solders","text":"Convert to a solders instruction. Returns: Type Description instruction.Instruction The solders instruction. Source code in solana/transaction.py def to_solders ( self ) -> instruction . Instruction : \"\"\"Convert to a `solders` instruction. Returns: The `solders` instruction. \"\"\" accounts = [ key . to_solders () for key in self . keys ] return instruction . Instruction ( program_id = self . program_id . to_solders (), data = self . data , accounts = accounts )","title":"to_solders()"},{"location":"core/utils/","text":"Utils solana.utils special Utility functions for solanaweb3. cluster Tools for getting RPC cluster information. ClusterUrls A collection of urls for each cluster. Source code in solana/utils/cluster.py class ClusterUrls ( NamedTuple ): \"\"\"A collection of urls for each cluster.\"\"\" devnet : str testnet : str mainnet_beta : str Endpoint Container for http and https cluster urls. Source code in solana/utils/cluster.py class Endpoint ( NamedTuple ): \"\"\"Container for http and https cluster urls.\"\"\" http : ClusterUrls https : ClusterUrls cluster_api_url ( cluster = None , tls = True ) Retrieve the RPC API URL for the specified cluster. :param cluster: The name of the cluster to use. :param tls: If True, use https. Defaults to True. Source code in solana/utils/cluster.py def cluster_api_url ( cluster : Optional [ Cluster ] = None , tls : bool = True ) -> str : \"\"\"Retrieve the RPC API URL for the specified cluster. :param cluster: The name of the cluster to use. :param tls: If True, use https. Defaults to True. \"\"\" urls = ENDPOINT . https if tls else ENDPOINT . http if cluster is None : return urls . devnet return getattr ( urls , cluster ) helpers Helper functions. decode_byte_string ( byte_string , encoding = 'base64' ) Decode an encoded string from an RPC Response. Source code in solana/utils/helpers.py def decode_byte_string ( byte_string : str , encoding : str = \"base64\" ) -> bytes : \"\"\"Decode an encoded string from an RPC Response.\"\"\" b_str = str . encode ( byte_string ) if encoding == \"base64\" : return b64decode ( b_str ) if encoding == \"base58\" : return b58decode ( b_str ) raise NotImplementedError ( f \" { encoding } decoding not currently supported.\" ) from_uint8_bytes ( uint8 ) Convert from uint8 to python int. Source code in solana/utils/helpers.py def from_uint8_bytes ( uint8 : bytes ) -> int : \"\"\"Convert from uint8 to python int.\"\"\" return int . from_bytes ( uint8 , byteorder = \"little\" ) to_uint8_bytes ( val ) Convert an integer to uint8. Source code in solana/utils/helpers.py def to_uint8_bytes ( val : int ) -> bytes : \"\"\"Convert an integer to uint8.\"\"\" return val . to_bytes ( 1 , byteorder = \"little\" ) validate Validation utilities. validate_instruction_keys ( instruction , expected ) Verify length of AccountMeta list of a transaction instruction is at least the expected length. Parameters: Name Type Description Default instruction TransactionInstruction A TransactionInstruction object. required expected int The expected length. required Source code in solana/utils/validate.py def validate_instruction_keys ( instruction : TransactionInstruction , expected : int ) -> None : \"\"\"Verify length of AccountMeta list of a transaction instruction is at least the expected length. Args: instruction: A TransactionInstruction object. expected: The expected length. \"\"\" if len ( instruction . keys ) < expected : raise ValueError ( f \"invalid instruction: found { len ( instruction . keys ) } keys, expected at least { expected } \" ) validate_instruction_type ( parsed_data , expected_type ) Check that the instruction type of the parsed data matches the expected instruction type. Parameters: Name Type Description Default parsed_data Any Parsed instruction data object with instruction_type field. required expected_type IntEnum The expected instruction type. required Source code in solana/utils/validate.py def validate_instruction_type ( parsed_data : Any , expected_type : IntEnum ) -> None : \"\"\"Check that the instruction type of the parsed data matches the expected instruction type. Args: parsed_data: Parsed instruction data object with `instruction_type` field. expected_type: The expected instruction type. \"\"\" if parsed_data . instruction_type != expected_type : raise ValueError ( f \"invalid instruction; instruction index mismatch { parsed_data . instruction_type } != { expected_type } \" )","title":"Utils"},{"location":"core/utils/#utils","text":"","title":"Utils"},{"location":"core/utils/#solana.utils","text":"Utility functions for solanaweb3.","title":"utils"},{"location":"core/utils/#solana.utils.cluster","text":"Tools for getting RPC cluster information.","title":"cluster"},{"location":"core/utils/#solana.utils.cluster.ClusterUrls","text":"A collection of urls for each cluster. Source code in solana/utils/cluster.py class ClusterUrls ( NamedTuple ): \"\"\"A collection of urls for each cluster.\"\"\" devnet : str testnet : str mainnet_beta : str","title":"ClusterUrls"},{"location":"core/utils/#solana.utils.cluster.Endpoint","text":"Container for http and https cluster urls. Source code in solana/utils/cluster.py class Endpoint ( NamedTuple ): \"\"\"Container for http and https cluster urls.\"\"\" http : ClusterUrls https : ClusterUrls","title":"Endpoint"},{"location":"core/utils/#solana.utils.cluster.cluster_api_url","text":"Retrieve the RPC API URL for the specified cluster. :param cluster: The name of the cluster to use. :param tls: If True, use https. Defaults to True. Source code in solana/utils/cluster.py def cluster_api_url ( cluster : Optional [ Cluster ] = None , tls : bool = True ) -> str : \"\"\"Retrieve the RPC API URL for the specified cluster. :param cluster: The name of the cluster to use. :param tls: If True, use https. Defaults to True. \"\"\" urls = ENDPOINT . https if tls else ENDPOINT . http if cluster is None : return urls . devnet return getattr ( urls , cluster )","title":"cluster_api_url()"},{"location":"core/utils/#solana.utils.helpers","text":"Helper functions.","title":"helpers"},{"location":"core/utils/#solana.utils.helpers.decode_byte_string","text":"Decode an encoded string from an RPC Response. Source code in solana/utils/helpers.py def decode_byte_string ( byte_string : str , encoding : str = \"base64\" ) -> bytes : \"\"\"Decode an encoded string from an RPC Response.\"\"\" b_str = str . encode ( byte_string ) if encoding == \"base64\" : return b64decode ( b_str ) if encoding == \"base58\" : return b58decode ( b_str ) raise NotImplementedError ( f \" { encoding } decoding not currently supported.\" )","title":"decode_byte_string()"},{"location":"core/utils/#solana.utils.helpers.from_uint8_bytes","text":"Convert from uint8 to python int. Source code in solana/utils/helpers.py def from_uint8_bytes ( uint8 : bytes ) -> int : \"\"\"Convert from uint8 to python int.\"\"\" return int . from_bytes ( uint8 , byteorder = \"little\" )","title":"from_uint8_bytes()"},{"location":"core/utils/#solana.utils.helpers.to_uint8_bytes","text":"Convert an integer to uint8. Source code in solana/utils/helpers.py def to_uint8_bytes ( val : int ) -> bytes : \"\"\"Convert an integer to uint8.\"\"\" return val . to_bytes ( 1 , byteorder = \"little\" )","title":"to_uint8_bytes()"},{"location":"core/utils/#solana.utils.validate","text":"Validation utilities.","title":"validate"},{"location":"core/utils/#solana.utils.validate.validate_instruction_keys","text":"Verify length of AccountMeta list of a transaction instruction is at least the expected length. Parameters: Name Type Description Default instruction TransactionInstruction A TransactionInstruction object. required expected int The expected length. required Source code in solana/utils/validate.py def validate_instruction_keys ( instruction : TransactionInstruction , expected : int ) -> None : \"\"\"Verify length of AccountMeta list of a transaction instruction is at least the expected length. Args: instruction: A TransactionInstruction object. expected: The expected length. \"\"\" if len ( instruction . keys ) < expected : raise ValueError ( f \"invalid instruction: found { len ( instruction . keys ) } keys, expected at least { expected } \" )","title":"validate_instruction_keys()"},{"location":"core/utils/#solana.utils.validate.validate_instruction_type","text":"Check that the instruction type of the parsed data matches the expected instruction type. Parameters: Name Type Description Default parsed_data Any Parsed instruction data object with instruction_type field. required expected_type IntEnum The expected instruction type. required Source code in solana/utils/validate.py def validate_instruction_type ( parsed_data : Any , expected_type : IntEnum ) -> None : \"\"\"Check that the instruction type of the parsed data matches the expected instruction type. Args: parsed_data: Parsed instruction data object with `instruction_type` field. expected_type: The expected instruction type. \"\"\" if parsed_data . instruction_type != expected_type : raise ValueError ( f \"invalid instruction; instruction index mismatch { parsed_data . instruction_type } != { expected_type } \" )","title":"validate_instruction_type()"},{"location":"core/vote_program/","text":"Vote Program solana.vote_program Library to interface with the vote program. VOTE_PROGRAM_ID : PublicKey Public key that identifies the Vote program. WithdrawFromVoteAccountParams Transfer SOL from vote account to identity. Source code in solana/vote_program.py class WithdrawFromVoteAccountParams ( NamedTuple ): \"\"\"Transfer SOL from vote account to identity.\"\"\" vote_account_from_pubkey : PublicKey \"\"\"\"\"\" to_pubkey : PublicKey \"\"\"\"\"\" lamports : int \"\"\"\"\"\" withdrawer : PublicKey \"\"\"\"\"\" withdraw_from_vote_account ( params ) Generate an instruction that transfers lamports from a vote account to any other. Examples: >>> from solana.publickey import PublicKey >>> from solana.keypair import Keypair >>> vote = PublicKey ( 1 ) >>> withdrawer = Keypair . from_seed ( bytes ([ 0 ] * 32 )) >>> instruction = withdraw_from_vote_account ( ... WithdrawFromVoteAccountParams ( ... vote_account_from_pubkey = vote , ... to_pubkey = withdrawer , ... withdrawer = withdrawer , ... lamports = 3_000_000_000 , ... ) ... ) >>> type ( instruction ) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The generated instruction. Source code in solana/vote_program.py def withdraw_from_vote_account ( params : WithdrawFromVoteAccountParams ) -> TransactionInstruction : \"\"\"Generate an instruction that transfers lamports from a vote account to any other. Example: >>> from solana.publickey import PublicKey >>> from solana.keypair import Keypair >>> vote = PublicKey(1) >>> withdrawer = Keypair.from_seed(bytes([0]*32)) >>> instruction = withdraw_from_vote_account( ... WithdrawFromVoteAccountParams( ... vote_account_from_pubkey=vote, ... to_pubkey=withdrawer, ... withdrawer=withdrawer, ... lamports=3_000_000_000, ... ) ... ) >>> type(instruction) <class 'solana.transaction.TransactionInstruction'> Returns: The generated instruction. \"\"\" data = VOTE_INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . WITHDRAW_FROM_VOTE_ACCOUNT , args = dict ( lamports = params . lamports )) ) return TransactionInstruction ( keys = [ AccountMeta ( pubkey = params . vote_account_from_pubkey , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . to_pubkey , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . withdrawer , is_signer = True , is_writable = True ), ], program_id = VOTE_PROGRAM_ID , data = data , )","title":"Vote Program"},{"location":"core/vote_program/#vote-program","text":"","title":"Vote Program"},{"location":"core/vote_program/#solana.vote_program","text":"Library to interface with the vote program.","title":"vote_program"},{"location":"core/vote_program/#solana.vote_program.VOTE_PROGRAM_ID","text":"Public key that identifies the Vote program.","title":"VOTE_PROGRAM_ID"},{"location":"core/vote_program/#solana.vote_program.WithdrawFromVoteAccountParams","text":"Transfer SOL from vote account to identity. Source code in solana/vote_program.py class WithdrawFromVoteAccountParams ( NamedTuple ): \"\"\"Transfer SOL from vote account to identity.\"\"\" vote_account_from_pubkey : PublicKey \"\"\"\"\"\" to_pubkey : PublicKey \"\"\"\"\"\" lamports : int \"\"\"\"\"\" withdrawer : PublicKey \"\"\"\"\"\"","title":"WithdrawFromVoteAccountParams"},{"location":"core/vote_program/#solana.vote_program.withdraw_from_vote_account","text":"Generate an instruction that transfers lamports from a vote account to any other. Examples: >>> from solana.publickey import PublicKey >>> from solana.keypair import Keypair >>> vote = PublicKey ( 1 ) >>> withdrawer = Keypair . from_seed ( bytes ([ 0 ] * 32 )) >>> instruction = withdraw_from_vote_account ( ... WithdrawFromVoteAccountParams ( ... vote_account_from_pubkey = vote , ... to_pubkey = withdrawer , ... withdrawer = withdrawer , ... lamports = 3_000_000_000 , ... ) ... ) >>> type ( instruction ) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The generated instruction. Source code in solana/vote_program.py def withdraw_from_vote_account ( params : WithdrawFromVoteAccountParams ) -> TransactionInstruction : \"\"\"Generate an instruction that transfers lamports from a vote account to any other. Example: >>> from solana.publickey import PublicKey >>> from solana.keypair import Keypair >>> vote = PublicKey(1) >>> withdrawer = Keypair.from_seed(bytes([0]*32)) >>> instruction = withdraw_from_vote_account( ... WithdrawFromVoteAccountParams( ... vote_account_from_pubkey=vote, ... to_pubkey=withdrawer, ... withdrawer=withdrawer, ... lamports=3_000_000_000, ... ) ... ) >>> type(instruction) <class 'solana.transaction.TransactionInstruction'> Returns: The generated instruction. \"\"\" data = VOTE_INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . WITHDRAW_FROM_VOTE_ACCOUNT , args = dict ( lamports = params . lamports )) ) return TransactionInstruction ( keys = [ AccountMeta ( pubkey = params . vote_account_from_pubkey , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . to_pubkey , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . withdrawer , is_signer = True , is_writable = True ), ], program_id = VOTE_PROGRAM_ID , data = data , )","title":"withdraw_from_vote_account()"},{"location":"rpc/api/","text":"API Client solana.rpc.api API client to interact with the Solana JSON RPC Endpoint. Client Client class. Parameters: Name Type Description Default endpoint Optional[str] URL of the RPC endpoint. None commitment Optional[Commitment] Default bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None blockhash_cache Union[BlockhashCache, bool] (Experimental) If True, keep a cache of recent blockhashes to make send_transaction calls faster. You can also pass your own BlockhashCache object to customize its parameters. The cache works as follows: Retrieve the oldest unused cached blockhash that is younger than ttl seconds, where ttl is defined in the BlockhashCache (we prefer unused blockhashes because reusing blockhashes can cause errors in some edge cases, and we prefer slightly older blockhashes because they're more likely to be accepted by every validator). If there are no unused blockhashes in the cache, take the oldest used blockhash that is younger than ttl seconds. Fetch a new recent blockhash after sending the transaction. This is to keep the cache up-to-date. If you want something tailored to your use case, run your own loop that fetches the recent blockhash, and pass that value in your .send_transaction calls. False timeout float HTTP request timeout in seconds. 10 Source code in solana/rpc/api.py class Client ( _ClientCore ): # pylint: disable=too-many-public-methods \"\"\"Client class. Args: endpoint: URL of the RPC endpoint. commitment: Default bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". blockhash_cache: (Experimental) If True, keep a cache of recent blockhashes to make `send_transaction` calls faster. You can also pass your own BlockhashCache object to customize its parameters. The cache works as follows: 1. Retrieve the oldest unused cached blockhash that is younger than `ttl` seconds, where `ttl` is defined in the BlockhashCache (we prefer unused blockhashes because reusing blockhashes can cause errors in some edge cases, and we prefer slightly older blockhashes because they're more likely to be accepted by every validator). 2. If there are no unused blockhashes in the cache, take the oldest used blockhash that is younger than `ttl` seconds. 3. Fetch a new recent blockhash *after* sending the transaction. This is to keep the cache up-to-date. If you want something tailored to your use case, run your own loop that fetches the recent blockhash, and pass that value in your `.send_transaction` calls. timeout: HTTP request timeout in seconds. \"\"\" def __init__ ( self , endpoint : Optional [ str ] = None , commitment : Optional [ Commitment ] = None , blockhash_cache : Union [ BlockhashCache , bool ] = False , timeout : float = 10 , ): \"\"\"Init API client.\"\"\" super () . __init__ ( commitment , blockhash_cache ) self . _provider = http . HTTPProvider ( endpoint , timeout = timeout ) @property def request ( self ): if getattr ( self , '_provider' ): request_raw = self . _provider . content return self . _provider . json_decode ( request_raw ) return None @property def response_headers ( self ): return self . _provider . response_headers if getattr ( self , '_provider' ) else None def is_connected ( self ) -> bool : \"\"\"Health check. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.is_connected() # doctest: +SKIP True Returns: True if the client is connected. \"\"\" return self . _provider . is_connected () def get_balance ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns the balance of the account of provided Pubkey. Args: pubkey: Pubkey of account to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". min_context_slot: set the minimum slot that the request can be evaluated at Example: >>> from solana.publickey import PublicKey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_balance(PublicKey(1)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 228}, 'value': 0}, 'id': 1} \"\"\" args = self . _get_balance_args ( pubkey , commitment , min_context_slot ) return self . _provider . make_request ( * args ) def get_account_info ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns all the account info for the specified public key. Args: pubkey: Pubkey of account to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. - \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. min_context_slot: set the minimum slot that the request can be evaluated at Example: >>> from solana.publickey import PublicKey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_account_info(PublicKey(1)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 33265073}, 'value': {'data': '', 'executable': False, 'lamports': 4459816188034584, 'owner': '11111111111111111111111111111111', 'rentEpoch': 90}}, 'id': 1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_account_info_args ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , min_context_slot = min_context_slot , ) return self . _provider . make_request ( * args ) def get_block_commitment ( self , slot : int ) -> types . RPCResponse : \"\"\"Fetch the commitment for particular block. Args: slot: Block, identified by Slot. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_commitment(0) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'commitment': [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 497717120], 'totalStake': 497717120}, 'id': 1}} \"\"\" args = self . _get_block_commitment_args ( slot ) return self . _provider . make_request ( * args ) def get_block_time ( self , slot : int ) -> types . RPCResponse : \"\"\"Fetch the estimated production time of a block. Args: slot: Block, identified by Slot. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_time(5) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1598400007, 'id': 1} \"\"\" args = self . _get_block_time_args ( slot ) return self . _provider . make_request ( * args ) def get_cluster_nodes ( self ) -> types . RPCResponse : \"\"\"Returns information about all the nodes participating in the cluster. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_cluster_nodes() # doctest: +SKIP {'jsonrpc': '2.0', 'result': [{'gossip': '127.0.0.1:8001', 'pubkey': 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk', 'rpc': '127.0.0.1:8899', 'tpu': '127.0.0.1:8003', 'version': '1.4.0 5332fcad'}], 'id': 1} \"\"\" return self . _provider . make_request ( self . _get_cluster_nodes ) def get_confirmed_block ( self , slot : int , encoding : str = \"json\" , max_support_transaction_version = None , ) -> types . RPCResponse : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_confirmed_block(1) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': {'message': {'accountKeys': ['LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk', 'EKAar3bMQUZvGSonq7vcPF2nPaCYowbnat44FPafW8Po', 'SysvarS1otHashes111111111111111111111111111', 'SysvarC1ock11111111111111111111111111111111', 'Vote111111111111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 3, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [1, 2, 3, 0], 'data': '37u9WtQpcm6ULa3VmTgTKEBCtYMxq84mk82tRvKdFEwj3rALiptAzuMJ1yoVSFAMARMZYp7q', 'programIdIndex': 4}], 'recentBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2'}, 'signatures': ['63jnpMCs7TNnCjnTqUrX7Mvqc5CbJMtVkLxBjPHUQkjXyZrQuZpfhjvzA7A29D9tMqVaiQC3UNP1NeaZKFFHJyQE']}}]}, 'id': 9} >>> solana_client.get_confirmed_block(1, encoding=\"base64\") # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': ['AfxyKHmHIjXWjkyHODGeAbVxmfQWPj1ydS9nF+ynJHo8I1vCPDp2P9Cj5aA6W1CAHEHCqY0B1FDKomCzRo3qrAsBAAMFBQ6QBWfhQF7rG02xhuEsmmrUtz3AUjBtJKkqaHPJEmvFzziDX0C0robPrl9RbOyXHoc9/Dxa0zoGL6cEjvCjLgan1RcZLwqvxvJl4/t3zHragsUp0L47E24tAFUgAAAABqfVFxjHdMkoVmOYaR1etoteuKObS21cc1VbIQAAAAAHYUgdNXR0u3xNdiTr072z2DVec9EQQ/wNo1OAAAAAAM8NSv7ISDPN9E9XNL9vX7h8LuJHWlopUcX39DxsDx23AQQEAQIDADUCAAAAAQAAAAAAAAAAAAAAAAAAAIWWp5Il3Kg312pzVk6Jt61iyFhTbtmkh/ORbj3JUQRbAA==', 'base64']}]}, 'id': 10} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_confirmed_block_args ( slot , encoding , max_support_transaction_version , ) return self . _provider . make_request ( * args ) def get_recent_performance_samples ( self , limit : Optional [ int ] = None ) -> types . RPCResponse : \"\"\"Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Args: limit: Limit (optional) number of samples to return (maximum 720) Examples: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_recent_performance_samples(4) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [ { 'numSlots': 126, 'numTransactions': 126, 'samplePeriodSecs': 60, 'slot': 348125 }, { 'numSlots': 126, 'numTransactions': 126, 'samplePeriodSecs': 60, 'slot': 347999 }, { 'numSlots': 125, 'numTransactions': 125, 'samplePeriodSecs': 60, 'slot': 347873 }, { 'numSlots': 125, 'numTransactions': 125, 'samplePeriodSecs': 60, 'slot': 347748 } ], 'id': 1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_recent_performance_samples_args ( limit ) return self . _provider . make_request ( * args ) def get_block ( self , slot : int , encoding : str = \"json\" , commitment : Optional [ Commitment ] = None , rewards : Optional [ bool ] = None , transaction_details : Optional [ str ] = None , max_support_transaction_version : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. commitment:(optional) It can be either \"finalized\", \"confirmed\". \"processed\" is not supported. If parameter not provided, the default is \"finalized\". rewards: (optional) whether to populate the rewards array. If parameter not provided, the default includes rewards. transaction_details: (optional) level of transaction detail to return, either \"full\", \"accounts\", \"signatures\", or \"none\". If parameter not provided, the default detail level is \"full\". max_support_transaction_version: (optional) set the max transaction version to return in responses. If the requested block contains a transaction with a higher version, an error will be returned. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block(1) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockHeight': 0, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': {'message': {'accountKeys': ['LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk', 'EKAar3bMQUZvGSonq7vcPF2nPaCYowbnat44FPafW8Po', 'SysvarS1otHashes111111111111111111111111111', 'SysvarC1ock11111111111111111111111111111111', 'Vote111111111111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 3, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [1, 2, 3, 0], 'data': '37u9WtQpcm6ULa3VmTgTKEBCtYMxq84mk82tRvKdFEwj3rALiptAzuMJ1yoVSFAMARMZYp7q', 'programIdIndex': 4}], 'recentBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2'}, 'signatures': ['63jnpMCs7TNnCjnTqUrX7Mvqc5CbJMtVkLxBjPHUQkjXyZrQuZpfhjvzA7A29D9tMqVaiQC3UNP1NeaZKFFHJyQE']}}]}, 'id': 9} >>> solana_client.get_block(1, encoding=\"base64\") # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockHeight': 0, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': ['AfxyKHmHIjXWjkyHODGeAbVxmfQWPj1ydS9nF+ynJHo8I1vCPDp2P9Cj5aA6W1CAHEHCqY0B1FDKomCzRo3qrAsBAAMFBQ6QBWfhQF7rG02xhuEsmmrUtz3AUjBtJKkqaHPJEmvFzziDX0C0robPrl9RbOyXHoc9/Dxa0zoGL6cEjvCjLgan1RcZLwqvxvJl4/t3zHragsUp0L47E24tAFUgAAAABqfVFxjHdMkoVmOYaR1etoteuKObS21cc1VbIQAAAAAHYUgdNXR0u3xNdiTr072z2DVec9EQQ/wNo1OAAAAAAM8NSv7ISDPN9E9XNL9vX7h8LuJHWlopUcX39DxsDx23AQQEAQIDADUCAAAAAQAAAAAAAAAAAAAAAAAAAIWWp5Il3Kg312pzVk6Jt61iyFhTbtmkh/ORbj3JUQRbAA==', 'base64']}]}, 'id': 10} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_block_args ( slot , encoding , commitment , rewards , transaction_details , max_support_transaction_version , ) return self . _provider . make_request ( * args ) def get_block_height ( self , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns the current block height of the node. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_height() # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1233, 'id': 1} \"\"\" args = self . _get_block_height_args ( commitment , min_context_slot ) return self . _provider . make_request ( * args ) def get_confirmed_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> types . RPCResponse : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_confirmed_blocks(5, 10) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [5, 6, 7, 8, 9, 10], 'id': 1} \"\"\" args = self . _get_confirmed_blocks_args ( start_slot , end_slot ) return self . _provider . make_request ( * args ) def get_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> types . RPCResponse : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_blocks(5, 10) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [5, 6, 7, 8, 9, 10], 'id': 1} \"\"\" args = self . _get_blocks_args ( start_slot , end_slot ) return self . _provider . make_request ( * args ) def get_confirmed_signature_for_address2 ( self , account : Union [ str , Keypair , PublicKey ], before : Optional [ str ] = None , until : Optional [ str ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optoinal) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_confirmed_signature_for_address2(\"Vote111111111111111111111111111111111111111\", limit=1) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [{'err': None, 'memo': None, 'signature': 'v1BK8XcaPBzAGd7TB1K53pMdi6TBGe5CLCgx8cmZ4Bj63ZNvA6ca2QaxFpBFdvmpoFQ51VorBjifkBGLTDhwpqN', 'slot': 4290}], 'id': 2} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_confirmed_signature_for_address2_args ( account , before , until , limit , commitment ) return self . _provider . make_request ( * args ) def get_signatures_for_address ( self , account : Union [ str , Keypair , PublicKey ], before : Optional [ str ] = None , until : Optional [ str ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_signatures_for_address(\"Vote111111111111111111111111111111111111111\", limit=1) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [{'err': None, 'memo': None, 'signature': 'v1BK8XcaPBzAGd7TB1K53pMdi6TBGe5CLCgx8cmZ4Bj63ZNvA6ca2QaxFpBFdvmpoFQ51VorBjifkBGLTDhwpqN', 'slot': 4290}], 'id': 2} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_signatures_for_address_args ( account , before , until , limit , commitment , min_context_slot , ) return self . _provider . make_request ( * args ) def get_confirmed_transaction ( self , tx_sig : str , encoding : str = \"json\" ) -> types . RPCResponse : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_confirmed_transaction(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\") # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'meta': {'err': None, 'fee': 5000, 'postBalances': [498449233720610510, 1000001001987940, 1], 'preBalances': [498449233721615510, 1000001000987940, 1], 'status': {'Ok': None}}, 'slot': 1659335, 'transaction': {'message': {'accountKeys': ['9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g', '2KW2XRd9kwqet15Aha2oK3tYvd3nWbTFH1MBiRAv1BE1', '11111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 1, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [0, 1], 'data': '3Bxs4Bc3VYuGVB19', 'programIdIndex': 2}], 'recentBlockhash': 'FwcsKNptGtMLccXAA9YgnivVFK95mKzECLT1DNPi3SDr'}, 'signatures': ['3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy']}}, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_confirmed_transaction_args ( tx_sig , encoding ) return self . _provider . make_request ( * args ) def get_transaction ( self , tx_sig : str , encoding : str = \"json\" , commitment : Optional [ Commitment ] = None , max_support_transaction_version : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". max_support_transaction_version: (optional) set the max transaction version to return in responses. If the requested block contains a transaction with a higher version, an error will be returned. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_transaction(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\") # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'meta': {'err': None, 'fee': 5000, 'rewards': [], 'postBalances': [498449233720610510, 1000001001987940, 1], 'preBalances': [498449233721615510, 1000001000987940, 1], 'status': {'Ok': None}}, 'slot': 1659335, 'transaction': {'message': {'accountKeys': ['9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g', '2KW2XRd9kwqet15Aha2oK3tYvd3nWbTFH1MBiRAv1BE1', '11111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 1, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [0, 1], 'data': '3Bxs4Bc3VYuGVB19', 'programIdIndex': 2}], 'recentBlockhash': 'FwcsKNptGtMLccXAA9YgnivVFK95mKzECLT1DNPi3SDr'}, 'signatures': ['3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy']}}, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_transaction_args ( tx_sig , encoding , commitment , max_support_transaction_version ) return self . _provider . make_request ( * args ) def get_epoch_info ( self , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns information about the current epoch. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_epoch_info() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'absoluteSlot': 5150, 'blockHeight': 5150, 'epoch': 0, 'slotIndex': 5150, 'slotsInEpoch': 8192}, 'id': 5} \"\"\" args = self . _get_epoch_info_args ( commitment , min_context_slot ) return self . _provider . make_request ( * args ) def get_epoch_schedule ( self ) -> types . RPCResponse : \"\"\"Returns epoch schedule information from this cluster's genesis config. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_epoch_schedule() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'firstNormalEpoch': 0, 'firstNormalSlot': 0, 'leaderScheduleSlotOffset': 8192, 'slotsPerEpoch': 8192, 'warmup': False}, 'id': 6} \"\"\" return self . _provider . make_request ( self . _get_epoch_schedule ) def get_fee_calculator_for_blockhash ( self , blockhash : Union [ str , Blockhash ], commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the fee calculator associated with the query blockhash, or null if the blockhash has expired. Args: blockhash: Blockhash to query as a Base58 encoded string. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_fee_calculator_for_blockhash(\"BaQSR194dC4dZaRxATtxYyEwDkk7VgqUY8NVNkub8HFZ\") # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 7065}, 'value': {'feeCalculator': {'lamportsPerSignature': 5000}}}, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_fee_calculator_for_blockhash_args ( blockhash , commitment ) return self . _provider . make_request ( * args ) def get_fee_for_message ( self , message : Message , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the fee for a message. Args: message: Message that the fee is requested for. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solana.keypair import Keypair >>> from solana.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> sender, receiver = Keypair.from_seed(bytes(PublicKey(1))), Keypair.from_seed(bytes(PublicKey(2))) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.public_key, to_pubkey=receiver.public_key, lamports=1000))) >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_fee_for_message(txn.compile_message()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': { 'context': { 'slot': 5068 }, 'value': 5000 }, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long if isinstance ( message , Transaction ): raise TransactionUncompiledError ( \"Transaction uncompiled, please compile to message first.\" ) args = self . _get_fee_for_message_args ( message , commitment ) return self . _provider . make_request ( * args ) def get_fee_rate_governor ( self ) -> types . RPCResponse : \"\"\"Returns the fee rate governor information from the root bank. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_fee_rate_governor() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 7172}, 'value': {'feeRateGovernor': {'burnPercent': 50, 'maxLamportsPerSignature': 100000, 'minLamportsPerSignature': 5000, 'targetLamportsPerSignature': 10000, 'targetSignaturesPerSlot': 20000}}}, 'id': 5} \"\"\" return self . _provider . make_request ( self . _get_fee_rate_governor ) def get_fees ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns a recent block hash from the ledger, a fee schedule and the last slot the blockhash will be valid. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_fees() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 7727}, 'value': {'blockhash': 'GGS6AEDqjF5irU6D6VQNherEZ2hckGaeBiVdfSZKg4gd', 'feeCalculator': {'lamportsPerSignature': 5000}, 'lastValidSlot': 8027}}, 'id': 1} \"\"\" args = self . _get_fees_args ( commitment ) return self . _provider . make_request ( * args ) def get_first_available_block ( self ) -> types . RPCResponse : \"\"\"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_fees() # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1, 'id': 2} \"\"\" return self . _provider . make_request ( self . _get_first_available_block ) def get_genesis_hash ( self ) -> types . RPCResponse : \"\"\"Returns the genesis hash. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_genesis_hash() # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'id': 3} \"\"\" return self . _provider . make_request ( self . _get_genesis_hash ) def get_health ( self ) -> types . RPCResponse : \"\"\"Returns the current health of the node. >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_health() # doctest: +SKIP Healthy result: {\"jsonrpc\":\"2.0\", \"result\": \"ok\", \"id\":1} \"\"\" return self . _provider . make_request ( self . _get_health ) def get_identity ( self ) -> types . RPCResponse : \"\"\"Returns the identity pubkey for the current node. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_identity() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'identity': 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk'}, 'id': 4} \"\"\" return self . _provider . make_request ( self . _get_identity ) def get_inflation_governor ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the current inflation governor. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_governor() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'foundation': 0.05, 'foundationTerm': 7.0, 'initial': 0.15, 'taper': 0.15, 'terminal': 0.015}, 'id': 5} \"\"\" args = self . _get_inflation_governor_args ( commitment ) return self . _provider . make_request ( * args ) def get_inflation_rate ( self ) -> types . RPCResponse : \"\"\"Returns the specific inflation values for the current epoch. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_rate() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'epoch': 1, 'foundation': 0.007499746885736559, 'total': 0.14999493771473116, 'validator': 0.1424951908289946}, 'id': 1} \"\"\" return self . _provider . make_request ( self . _get_inflation_rate ) def get_inflation_reward ( self , address_list : List [ Union [ str , PublicKey ]], commitment : Optional [ Commitment ] = None , epoch : Optional [ int ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns the inflation reward for a list of addresses for an epoch. :param address_list: An array of addresses to query, as base-58 encoded strings :param commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". :param epoch: An epoch for which the reward occurs. If omitted, the previous epoch will be used >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_reward(address_list) # doctest: +SKIP { \"jsonrpc\": \"2.0\", \"result\": [ { \"amount\": 2500, \"effectiveSlot\": 224, \"epoch\": 2, \"postBalance\": 499999442500 }, null ], \"id\": 1 } \"\"\" args = self . _get_inflation_reward_args ( address_list = address_list , commitment = commitment , epoch = epoch , min_context_slot = min_context_slot , ) return self . _provider . make_request ( * args ) def get_largest_accounts ( self , filter_opt : Optional [ str ] = None , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the 20 largest accounts, by lamport balance. Args: filter_opt: Filter results by account type; currently supported: circulating|nonCirculating. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_largest_accounts() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 8890}, 'value': [{'address': '95L7AsBCLRsqghsi6ksZkzjNbs6rqDgHCzKaGZ7bJi75', 'lamports': 500000000000000000}, {'address': 'APnSR52EC1eH676m7qTBHUJ1nrGpHYpV7XKPxgRDD8gX', 'lamports': 164511033098290000}, {'address': '13LeFbG6m2EP1fqCj9k66fcXsoTHMMtgr7c78AivUrYD', 'lamports': 153333632446109120}, {'address': 'GK2zqSsXLA2rwVZk347RYhh6jJpRsCA69FjLW93ZGi3B', 'lamports': 57499999036109120}, {'address': '8HVqyX9jebh31Q9Hp8t5sMVJs665979ZeEr3eCfzitUe', 'lamports': 30301031036109120}, {'address': 'HbZ5FfmKWNHC7uwk6TF1hVi6TCs7dtYfdjEcuPGgzFAg', 'lamports': 14999999036109120}, {'address': '14FUT96s9swbmH7ZjpDvfEDywnAYy9zaNhv4xvezySGu', 'lamports': 4999999036109120}, {'address': '9huDUZfxoJ7wGMTffUE7vh1xePqef7gyrLJu9NApncqA', 'lamports': 4999999036109120}, {'address': 'C7C8odR8oashR5Feyrq2tJKaXL18id1dSj2zbkDGL2C2', 'lamports': 4999999036109120}, {'address': 'AYgECURrvuX6GtFe4tX7aAj87Xc5r5Znx96ntNk1nCv', 'lamports': 2499999518054560}, {'address': 'AogcwQ1ubM76EPMhSD5cw1ES4W5econvQCFmBL6nTW1', 'lamports': 2499999518054560}, {'address': 'gWgqQ4udVxE3uNxRHEwvftTHwpEmPHAd8JR9UzaHbR2', 'lamports': 2499999518054560}, {'address': '3D91zLQPRLamwJfGR5ZYMKQb4C18gsJNaSdmB6b2wLhw', 'lamports': 2499999518054560}, {'address': '3bHbMa5VW3np5AJazuacidrN4xPZgwhcXigmjwHmBg5e', 'lamports': 2499999518054560}, {'address': '4U3RFq7X5kLG6tZ9kcksFL8oXeGNjtuUN1YfkVKXbs5x', 'lamports': 2499999518054560}, {'address': '5cBVGBKY6kBaiTVmsQpxThJ2oqitBYuCAX9Zm2zMuV4y', 'lamports': 2499999518054560}, {'address': '8PjJTv657aeN9p5R2WoM6pPSz385chvTTytUWaEjSjkq', 'lamports': 2499999518054560}, {'address': 'AHB94zKUASftTdqgdfiDSdnPJHkEFp7zX3yMrcSxABsv', 'lamports': 2499999518054560}, {'address': 'Hc36Wh1ZqYGzGAnsJWNT9r2gY3h9n89uDpxZPsmEsiE3', 'lamports': 2499999518054560}, {'address': 'GxyRKP2eVKACaSSnso4VLSAjZKmHsFXHWUfS3A5CtiMA', 'lamports': 1940147018054560}]}, 'id': 2} \"\"\" args = self . _get_largest_accounts_args ( filter_opt , commitment ) return self . _provider . make_request ( * args ) def get_leader_schedule ( self , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the leader schedule for an epoch. Args: epoch: Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_leader_schedule() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'EWj2cuEuVhi7RX81cnAY3TzpyFwnHzzVwvuTyfmxmhs3': [0, 1, 2, 3, 4, 5, ...]}, 'id': 6} \"\"\" args = self . _get_leader_schedule_args ( epoch , commitment ) return self . _provider . make_request ( * args ) def get_minimum_balance_for_rent_exemption ( self , usize : int , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns minimum balance required to make account rent exempt. Args: usize: Account data length. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_minimum_balance_for_rent_exemption(50) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1238880, 'id': 7} \"\"\" args = self . _get_minimum_balance_for_rent_exemption_args ( usize , commitment ) return self . _provider . make_request ( * args ) def get_multiple_accounts ( self , pubkeys : List [ Union [ PublicKey , str ]], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. - \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solana.publickey import PublicKey >>> solana_client = Client(\"http://localhost:8899\") >>> pubkeys = [PublicKey(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), PublicKey(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> solana_client.get_multiple_accounts(pubkeys) # doctest: +SKIP { \"jsonrpc\": \"2.0\", \"result\": { \"context\": {\"slot\": 97531946}, \"value\": [ { \"data\": [\"\", \"base64\"], \"executable\": False, \"lamports\": 1, \"owner\": \"11111111111111111111111111111111\", \"rentEpoch\": 225, }, { \"data\": [\"\", \"base64\"], \"executable\": False, \"lamports\": 809441127, \"owner\": \"11111111111111111111111111111111\", \"rentEpoch\": 225, }, ], }, \"id\": 1, } \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_multiple_accounts_args ( pubkeys = pubkeys , commitment = commitment , encoding = encoding , data_slice = data_slice , min_context_slot = min_context_slot , ) return self . _provider . make_request ( * args ) def get_program_accounts ( # pylint: disable=too-many-arguments self , pubkey : Union [ str , PublicKey ], commitment : Optional [ Commitment ] = Finalized , encoding : Optional [ str ] = None , data_slice : Optional [ types . DataSliceOpts ] = None , data_size : Optional [ int ] = None , memcmp_opts : Optional [ List [ types . MemcmpOpts ]] = None , with_context : Optional [ bool ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for the returned Transaction, either jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and ` length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. data_size: (optional) Option to compare the program account data length with the provided data size. memcmp_opts: (optional) Options to compare a provided series of bytes with program account data at a particular offset. with_context: (optional ) Option to wrap the result in an RpcResponse JSON object. min_context_slot: (optional ) set the minimum slot that the request can be evaluated at Example: >>> solana_client = Client(\"http://localhost:8899\") >>> memcmp_opts = [ ... MemcmpOpt(offset=4, bytes=\"3Mc6vR\"), ... ] >>> solana_client.get_program_accounts(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\", data_size=17, memcmp_opts=memcmp_opts) # doctest: +SKIP {'jsonrpc': \"2.0\", 'result' :[{ 'account' :{ 'data' :'2R9jLfiAQ9bgdcw6h8s44439', 'executable' :false, 'lamports' :15298080, 'owner' :'4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T', 'rentEpoch' :28}, 'pubkey' :'CxELquR1gPP8wHe33gZ4QxqGB3sZ9RSwsJ2KshVewkFY'}], 'id' :1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_program_accounts_args ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , data_size = data_size , memcmp_opts = memcmp_opts , with_context = with_context , min_context_slot = min_context_slot , ) return self . _provider . make_request ( * args ) def get_recent_performance_samples ( self , limit : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\" Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Parameters: limit: <usize> - (optional) number of samples to return (maximum 720) Example: solana_client = Client(\"http://localhost:8899\") solana_client.get_recent_performance_samples() solana_client.get_recent_performance_samples(5) \"\"\" args = self . _get_recent_performance_samples_args ( limit ) return self . _provider . make_request ( * args ) def get_max_shred_insert_slot ( self ) -> types . RPCResponse : \"\"\" Get the max slot seen from after shred insert. solana_client = Client(\"http://localhost:8899\") solana_client.get_max_shred_insert_slot() \"\"\" return self . _provider . make_request ( types . RPCMethod ( \"getMaxShredInsertSlot\" ), ) def get_blocks_with_limit ( self , start_slot : int , limit : int , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\" Returns a list of confirmed blocks starting at the given slot Parameters: <u64> - start_slot, as u64 integer <u64> - limit, as u64 integer (optional) Commitment; \"processed\" is not supported. If parameter not provided, the default is \"finalized\". Example: solana_client = Client(\"http://localhost:8899\") solana_client.get_blocks_with_limit(126411503, 5) solana_client.get_blocks_with_limit(126411503, 10, 'confirmed') \"\"\" args = self . _get_blocks_with_limit_args ( start_slot , limit , commitment ) return self . _provider . make_request ( * args ) def get_recent_blockhash ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns a recent block hash from the ledger. Response also includes a fee schedule that can be used to compute the cost of submitting a transaction using it. Deprecated, please use get_latest_blockhash() instead. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_recent_blockhash() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 1637}, 'value': {'blockhash': 'EALChog1mXQ9nEgEUQpWAtmA5UueUZvZiL16ZivmR7eb', 'feeCalculator': {'lamportsPerSignature': 5000}}}, 'id': 2} \"\"\" args = self . _get_recent_blockhash_args ( commitment ) return self . _provider . make_request ( * args ) def get_latest_blockhash ( self , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns the latest block hash from the ledger. Response also includes the last valid block height. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_latest_blockhash() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 1637}, 'value': {'blockhash': 'EALChog1mXQ9nEgEUQpWAtmA5UueUZvZiL16ZivmR7eb', 'lastValidBlockHeight': 3090}}, 'id': 2} \"\"\" args = self . _get_latest_blockhash_args ( commitment , min_context_slot ) return self . _provider . make_request ( * args ) def get_fee_for_message ( self , message : str , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Get the fee the network will charge for a particular Message NEW: This method is only available in solana-core v1.9 or newer. Please use getRecentBlockhash for solana-core v1.8 Args: message: Base-64 encoded Message commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: solana_client = Client(\"http://localhost:8899\") solana_client.get_fee_for_message( 'AQABAgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQAA' ) \"\"\" args = self . _get_fee_for_message_args ( message , commitment ) return self . _provider . make_request ( * args ) def is_blockhash_valid ( self , blockhash : str , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns whether a blockhash is still valid or not NEW: This method is only available in solana-core v1.9 or newer. Please use getRecentBlockhash for solana-core v1.8 Args: blockhash: the blockhash of this block, as base-58 encoded string commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". min_context_slot: set the minimum slot that the request can be evaluated at Example: solana_client = Client(\"http://localhost:8899\") solana_client.is_blockhash_valid( 'J7rBdM6AecPDEZp8aPq5iPSNKVkU5Q76F3oAV4eW5wsW' ) \"\"\" args = self . _get_is_blockhash_valid_args ( blockhash , commitment , min_context_slot , ) return self . _provider . make_request ( * args ) def get_slot_leaders ( self , start_slot : int , limit : int ) -> types . RPCResponse : \"\"\" Returns the slot leaders for a given slot range Parameters: <u64> - start_slot, as u64 integer <u64> - limit, as u64 integer Example: solana_client = Client(\"http://localhost:8899\") solana_client.get_slot_leaders(126411503, 5) \"\"\" args = self . _get_slot_leaders_args ( start_slot , limit ) return self . _provider . make_request ( * args ) def get_highest_snapshot_slot ( self ) -> types . RPCResponse : \"\"\" Returns the highest slot information that the node has snapshots for. This will find the highest full snapshot slot, and the highest incremental snapshot slot based on the full snapshot slot, if there is one. solana_client = Client(\"http://localhost:8899\") solana_client.get_highest_snapshot_slot() \"\"\" return self . _provider . make_request ( types . RPCMethod ( \"getHighestSnapshotSlot\" ), ) def get_max_retransmit_slot ( self ) -> types . RPCResponse : \"\"\" Get the max slot seen from retransmit stage. Example: solana_client = Client(\"http://localhost:8899\") solana_client.get_max_retransmit_slot() \"\"\" return self . _provider . make_request ( types . RPCMethod ( \"getMaxRetransmitSlot\" ), ) def get_block_production ( self , commitment : Optional [ Commitment ] = None , first_slot : Optional [ int ] = None , last_slot : Optional [ int ] = None , identity : Optional [ str ] = None , ) -> types . RPCResponse : \"\"\"Returns recent block production information from the current or previous epoch. Args: (optional) commitment (optional) first_slot: <u64> - first slot to return block production information for (inclusive) (optional) last_slot: <u64> - last slot to return block production information for (inclusive). If parameter not provided, defaults to the highest slot (optional) identity: <string> - Only return results for this validator identity (base-58 encoded) Example: solana_client = Client(\"http://localhost:8899\") solana_client.get_block_production() \"\"\" args = self . _get_block_production_args ( commitment , first_slot , last_slot , identity , ) return self . _provider . make_request ( * args ) def get_signature_statuses ( self , signatures : List [ Union [ str , bytes ]], search_transaction_history : bool = False ) -> types . RPCResponse : \"\"\"Returns the statuses of a list of signatures. Unless the `search_transaction_history` configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus `MAX_RECENT_BLOCKHASHES` rooted slots. Args: signatures: An array of transaction signatures to confirm. search_transaction_history: If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> signatures = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\", ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\"] >>> solana_client.get_signature_statuses(signatures) # doctest: +SKIP {'jsonrpc': '2.0', 'result': { 'context': {'slot':82}, 'value': [{ 'slot': 72, 'confirmations': 10, 'err': null, 'status': {'Ok': null}}, null]}, 'id': 1} \"\"\" args = self . _get_signature_statuses_args ( signatures , search_transaction_history ) return self . _provider . make_request ( * args ) def get_slot ( self , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns the current slot the node is processing. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_slot() # doctest: +SKIP {'jsonrpc': '2.0', 'result': 7515, 'id': 1} \"\"\" args = self . _get_slot_args ( commitment , min_context_slot ) return self . _provider . make_request ( * args ) def get_slot_leader ( self , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns the current slot leader. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_slot_leader() # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'EWj2cuEuVhi7RX81cnAY3TzpyFwnHzzVwvuTyfmxmhs3', 'id': 1} \"\"\" args = self . _get_slot_leader_args ( commitment , min_context_slot ) return self . _provider . make_request ( * args ) def get_stake_activation ( self , pubkey : Union [ PublicKey , str ], epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns epoch activation information for a stake account. Args: pubkey: Pubkey of stake account to query, as base-58 encoded string or PublicKey object. epoch: (optional) Epoch for which to calculate activation details. If parameter not provided, defaults to current epoch. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". min_context_slot: set the minimum slot that the request can be evaluated at Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_stake_activation() # doctest: +SKIP {'jsonrpc': '2.0','result': {'active': 124429280, 'inactive': 73287840, 'state': 'activating'}, 'id': 1}} \"\"\" args = self . _get_stake_activation_args ( pubkey , epoch , commitment , min_context_slot , ) return self . _provider . make_request ( * args ) def get_supply ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns information about the current supply. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_supply() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 3846}, 'value': {'circulating': 683635192454157660, 'nonCirculating': 316364808037127120, 'nonCirculatingAccounts': ['ETfDYz7Cg5p9SDFmdpRerjBN5puKK7xydEBZZGM2V4Ay', '7cKxv6UznFoWRuJkgw5bWj5rp5PiKTcXZeEaLqyd3Bbm', 'CV7qh8ZoqeUSTQagosGpkLptXoojf9yCszxkRx1jTD12', 'FZ9S7X9jMbCaMyJjRfSoBhFyarUMVwvx7HWRe4LnZHsg', ...] 'total': 1000000000491284780}}, 'id': 1} \"\"\" args = self . _get_supply_args ( commitment ) return self . _provider . make_request ( * args ) def get_token_account_balance ( self , pubkey : Union [ str , PublicKey ], commitment : Optional [ Commitment ] = None ): \"\"\"Returns the token balance of an SPL Token account (UNSTABLE). Args: pubkey: Pubkey of Token account to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_token_account_balance(\"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\") # doctest: +SKIP {'jsonrpc': '2.0','result': { 'context': {'slot':1114}, 'value': { 'uiAmount': 98.64, 'amount': '9864', 'decimals': 2}, 'id' :1} \"\"\" args = self . _get_token_account_balance_args ( pubkey , commitment ) return self . _provider . make_request ( * args ) def get_token_accounts_by_delegate ( self , delegate : PublicKey , opts : Optional [ types . TokenAccountOpts ] = None , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" args = self . _get_token_accounts_by_delegate_args ( delegate , opts , commitment ) return self . __get_token_accounts ( * args ) def get_token_accounts_by_owner ( self , owner : PublicKey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Returns all SPL Token accounts by token owner (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" args = self . _get_token_accounts_by_owner_args ( owner , opts , commitment ) return self . __get_token_accounts ( * args ) def __get_token_accounts ( self , method : types . RPCMethod , pubkey : str , opts : types . TokenAccountOpts , commitment : Commitment , ) -> types . RPCResponse : args = self . _get_token_accounts_args ( method , pubkey , opts , commitment ) return self . _provider . make_request ( * args ) def get_token_largest_accounts ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the 20 largest accounts of a particular SPL Token type.\"\"\" args = self . _get_token_largest_account_args ( pubkey , commitment ) return self . _provider . make_request ( * args ) def get_token_supply ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the total supply of an SPL Token type.\"\"\" args = self . _get_token_supply_args ( pubkey , commitment ) return self . _provider . make_request ( * args ) def get_transaction_count ( self , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns the current Transaction count from the ledger. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_transaction_count() # doctest: +SKIP {'jsonrpc': '2.0', 'result': 4554, 'id': 1} \"\"\" args = self . _get_transaction_count_args ( commitment , min_context_slot ) return self . _provider . make_request ( * args ) def get_minimum_ledger_slot ( self ) -> types . RPCResponse : \"\"\"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_minimum_ledger_slot() # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1234, 'id': 1} \"\"\" return self . _provider . make_request ( self . _minimum_ledger_slot ) def get_version ( self ) -> types . RPCResponse : \"\"\"Returns the current solana versions running on the node. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_version() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'solana-core': '1.4.0 5332fcad'}, 'id': 1} \"\"\" return self . _provider . make_request ( self . _get_version ) def get_vote_accounts ( self , commitment : Optional [ Commitment ] = None ): \"\"\"Returns the account info and associated stake for all the voting accounts in the current bank. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_vote_accounts() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'current': [{'activatedStake': 0, 'commission': 100, 'epochCredits': [[165, 714644, 707372], [166, 722092, 714644], [167, 730285, 722092], [168, 738476, 730285], ...] 'epochVoteAccount': True, 'lastVote': 1872294, 'nodePubkey': 'J7v9ndmcoBuo9to2MnHegLnBkC9x3SAVbQBJo5MMJrN1', 'rootSlot': 1872263, 'votePubkey': 'HiFjzpR7e5Kv2tdU9jtE4FbH1X8Z9Syia3Uadadx18b5'}, {'activatedStake': 500029968930560, 'commission': 100, 'epochCredits': [[165, 1359689, 1351498], [166, 1367881, 1359689], [167, 1376073, 1367881], [168, 1384265, 1376073], ...], 'epochVoteAccount': True, 'lastVote': 1872295, 'nodePubkey': 'dv1LfzJvDF7S1fBKpFgKoKXK5yoSosmkAdfbxBo1GqJ', 'rootSlot': 1872264, 'votePubkey': '5MMCR4NbTZqjthjLGywmeT66iwE9J9f7kjtxzJjwfUx2'}, {'activatedStake': 0, 'commission': 100, 'epochCredits': [[227, 2751, 0], [228, 7188, 2751]], 'epochVoteAccount': True, 'lastVote': 1872295, 'nodePubkey': 'H1wDvJ5HJc1SzhHoWtaycpzQpFbsL7g8peaRV3obKShs', 'rootSlot': 1872264, 'votePubkey': 'DPqpgoLQVU3aq72HEqSMsB9qh4KoXc9fGEpvgEuiwnp6'}], 'delinquent': []}, 'id': 1} \"\"\" args = self . _get_vote_accounts_args ( commitment ) return self . _provider . make_request ( * args ) def request_airdrop ( self , pubkey : Union [ PublicKey , str ], lamports : int , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Requests an airdrop of lamports to a Pubkey. Args: pubkey: Pubkey of account to receive lamports, as base-58 encoded string or public key object. lamports: Amout of lamports. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solana.publickey import PublicKey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.request_airdrop(PublicKey(1), 10000) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'uK6gbLbhnTEgjgmwn36D5BRTRkG4AT8r7Q162TLnJzQnHUZVL9r6BYZVfRttrhmkmno6Fp4VQELzL4AiriCo61U', 'id': 1} \"\"\" args = self . _request_airdrop_args ( pubkey , lamports , commitment ) return self . _provider . make_request ( * args ) def send_raw_transaction ( self , txn : Union [ bytes , str ], opts : Optional [ types . TxOpts ] = None , ) -> types . RPCResponse : \"\"\"Send a transaction that has already been signed and serialized into the wire format. Args: txn: Fully-signed Transaction object, a fully sign transaction in wire format, or a fully transaction as base-64 encoded string. opts: (optional) Transaction options. Before submitting, the following preflight checks are performed (unless disabled with the `skip_preflight` option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> full_signed_tx_str = ( ... \"AbN5XM+qw+7oOLsFw7goQSLBis7c1kXJFP6OF4w7YmQNhhbQYcyBiybKuOzzhV7McvoRP3Mey9AhXojtwDCdbwoBAAEDE5j2\" ... \"LG0aRXxRumpLXz29L2n8qTIWIY3ImX5Ba9F9k8poq0Z3/7HyiU3QphU8Ix1F7ENq5TrmAUnb4V8y5LhwPwAAAAAAAAAAAAAA\" ... \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAg5YY9wG6fpuieuWYJd1ta7ZtFPbV0OriFRYdcYUaEGkBAgIAAQwCAAAAQEIPAAAAAAA=\") >>> solana_client.send_raw_transaction(full_signed_tx_str) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'CMwyESM2NE74mghfbvsHJDERF7xMYKshwwm6VgH6GFqXzx8LfBFuP5ruccumfhTguha6seUHPpiHzzHUQXzq2kN', 'id': 1} \"\"\" # noqa: E501 # pylint: disable=line-too-long opts_to_use = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts args = self . _send_raw_transaction_args ( txn , opts_to_use ) resp = self . _provider . make_request ( * args ) if opts_to_use . skip_confirmation : return self . _post_send ( resp ) post_send_args = self . _send_raw_transaction_post_send_args ( resp , opts_to_use ) return self . __post_send_with_confirm ( * post_send_args ) def send_transaction ( self , txn : Transaction , * signers : Keypair , opts : Optional [ types . TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> types . RPCResponse : \"\"\"Send a transaction. Args: txn: Transaction object. signers: Signers to sign the transaction. opts: (optional) Transaction options. recent_blockhash: (optional) Pass a valid recent blockhash here if you want to skip fetching the recent blockhash or relying on the cache. Example: >>> from solana.keypair import Keypair >>> from solana.publickey import PublicKey >>> from solana.rpc.api import Client >>> from solana.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> sender, receiver = Keypair.from_seed(bytes(PublicKey(1))), Keypair.from_seed(bytes(PublicKey(2))) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.public_key, to_pubkey=receiver.public_key, lamports=1000))) >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.send_transaction(txn, sender) # doctest: +SKIP {'jsonrpc': '2.0', 'result': '236zSA5w4NaVuLXXHK1mqiBuBxkNBu84X6cfLBh1v6zjPrLfyECz4zdedofBaZFhs4gdwzSmij9VkaSo2tR5LTgG', 'id': 12} \"\"\" last_valid_block_height = None if recent_blockhash is None : if self . blockhash_cache : try : recent_blockhash = self . blockhash_cache . get () except ValueError : blockhash_resp = self . get_latest_blockhash ( Finalized ) recent_blockhash = self . _process_blockhash_resp ( blockhash_resp , used_immediately = True ) last_valid_block_height = blockhash_resp [ \"result\" ][ \"value\" ][ \"lastValidBlockHeight\" ] else : blockhash_resp = self . get_latest_blockhash ( Finalized ) recent_blockhash = self . parse_recent_blockhash ( blockhash_resp ) last_valid_block_height = blockhash_resp [ \"result\" ][ \"value\" ][ \"lastValidBlockHeight\" ] txn . recent_blockhash = recent_blockhash txn . sign ( * signers ) opts_to_use = ( types . TxOpts ( preflight_commitment = self . _commitment , last_valid_block_height = last_valid_block_height ) if opts is None else opts ) txn_resp = self . send_raw_transaction ( txn . serialize (), opts = opts_to_use ) if self . blockhash_cache : blockhash_resp = self . get_recent_blockhash ( Finalized ) self . _process_blockhash_resp ( blockhash_resp , used_immediately = False ) return txn_resp def simulate_transaction ( self , txn : Union [ bytes , str , Transaction ], sig_verify : bool = False , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Simulate sending a transaction. Args: txn: A Transaction object, a transaction in wire format, or a transaction as base-64 encoded string The transaction must have a valid blockhash, but is not required to be signed. sig_verify: If true the transaction signatures will be verified (default: false). commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> tx_str = ( ... \"4hXTCkRzt9WyecNzV1XPgCDfGAZzQKNxLXgynz5QDuWWPSAZBZSHptvWRL3BjCvzUXRdKvHL2b7yGrRQcWyaqsaBCncVG7BF\" ... \"ggS8w9snUts67BSh3EqKpXLUm5UMHfD7ZBe9GhARjbNQMLJ1QD3Spr6oMTBU6EhdB4RD8CP2xUxr2u3d6fos36PD98XS6oX8\" ... \"TQjLpsMwncs5DAMiD4nNnR8NBfyghGCWvCVifVwvA8B8TJxE1aiyiv2L429BCWfyzAme5sZW8rDb14NeCQHhZbtNqfXhcp2t\" ... ) >>> solana_client.simulate_transaction(tx_str) # doctest: +SKIP {'jsonrpc' :'2.0', 'result': {'context': {'slot': 218}, 'value': { 'err': null, 'logs': ['BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success']}, 'id':1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _simulate_transaction_args ( txn , sig_verify , commitment , min_context_slot , ) return self . _provider . make_request ( * args ) def set_log_filter ( self , log_filter : str ) -> types . RPCResponse : \"\"\"Sets the log filter on the validator. Args: log_filter: The new log filter to use. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.set_log_filter(\"solana_core=debug\") # doctest: +SKIP {'jsonrpc': '2.0', 'result': None, 'id': 1} \"\"\" args = self . _set_log_filter_args ( log_filter ) return self . _provider . make_request ( * args ) def validator_exit ( self ) -> types . RPCResponse : \"\"\"Request to have the validator exit. Validator must have booted with RPC exit enabled (`--enable-rpc-exit` parameter). Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.validator_exit() # doctest: +SKIP {'jsonrpc': '2.0', 'result': true, 'id': 1} \"\"\" return self . _provider . make_request ( self . _validator_exit ) def __post_send_with_confirm ( self , resp : types . RPCResponse , conf_comm : Commitment , last_valid_block_height : Optional [ int ] ) -> types . RPCResponse : resp = self . _post_send ( resp ) self . _provider . logger . info ( \"Transaction sent to %s . Signature %s : \" , self . _provider . endpoint_uri , resp [ \"result\" ] ) self . confirm_transaction ( resp [ \"result\" ], conf_comm ) return resp def confirm_transaction ( self , tx_sig : str , commitment : Optional [ Commitment ] = None , sleep_seconds : float = 0.5 , last_valid_block_height : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Confirm the transaction identified by the specified signature. Args: tx_sig: the transaction signature to confirm. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". sleep_seconds: The number of seconds to sleep when polling the signature status. \"\"\" timeout = time () + 90 commitment_to_use = self . _commitment if commitment is None else commitment commitment_rank = COMMITMENT_RANKS [ commitment_to_use ] if last_valid_block_height : # pylint: disable=no-else-return current_blockheight = ( self . get_block_height ( commitment ))[ \"result\" ] while current_blockheight <= last_valid_block_height : resp = self . get_signature_statuses ([ tx_sig ]) maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) resp_value = resp [ \"result\" ][ \"value\" ][ 0 ] if resp_value is not None : confirmation_status = resp_value [ \"confirmationStatus\" ] confirmation_rank = COMMITMENT_RANKS [ confirmation_status ] if confirmation_rank >= commitment_rank : break current_blockheight = ( self . get_block_height ( commitment ))[ \"result\" ] sleep ( sleep_seconds ) else : maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) raise TransactionExpiredBlockheightExceededError ( f \" { tx_sig } has expired: block height exceeded\" ) return resp else : while time () < timeout : resp = self . get_signature_statuses ([ tx_sig ]) maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) resp_value = resp [ \"result\" ][ \"value\" ][ 0 ] if resp_value is not None : confirmation_status = resp_value [ \"confirmationStatus\" ] confirmation_rank = COMMITMENT_RANKS [ confirmation_status ] if confirmation_rank >= commitment_rank : break sleep ( sleep_seconds ) else : maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) raise UnconfirmedTxError ( f \"Unable to confirm transaction { tx_sig } \" ) return resp __init__ ( self , endpoint = None , commitment = None , blockhash_cache = False , timeout = 10 ) special Init API client. Source code in solana/rpc/api.py def __init__ ( self , endpoint : Optional [ str ] = None , commitment : Optional [ Commitment ] = None , blockhash_cache : Union [ BlockhashCache , bool ] = False , timeout : float = 10 , ): \"\"\"Init API client.\"\"\" super () . __init__ ( commitment , blockhash_cache ) self . _provider = http . HTTPProvider ( endpoint , timeout = timeout ) confirm_transaction ( self , tx_sig , commitment = None , sleep_seconds = 0.5 , last_valid_block_height = None ) Confirm the transaction identified by the specified signature. Parameters: Name Type Description Default tx_sig str the transaction signature to confirm. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None sleep_seconds float The number of seconds to sleep when polling the signature status. 0.5 Source code in solana/rpc/api.py def confirm_transaction ( self , tx_sig : str , commitment : Optional [ Commitment ] = None , sleep_seconds : float = 0.5 , last_valid_block_height : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Confirm the transaction identified by the specified signature. Args: tx_sig: the transaction signature to confirm. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". sleep_seconds: The number of seconds to sleep when polling the signature status. \"\"\" timeout = time () + 90 commitment_to_use = self . _commitment if commitment is None else commitment commitment_rank = COMMITMENT_RANKS [ commitment_to_use ] if last_valid_block_height : # pylint: disable=no-else-return current_blockheight = ( self . get_block_height ( commitment ))[ \"result\" ] while current_blockheight <= last_valid_block_height : resp = self . get_signature_statuses ([ tx_sig ]) maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) resp_value = resp [ \"result\" ][ \"value\" ][ 0 ] if resp_value is not None : confirmation_status = resp_value [ \"confirmationStatus\" ] confirmation_rank = COMMITMENT_RANKS [ confirmation_status ] if confirmation_rank >= commitment_rank : break current_blockheight = ( self . get_block_height ( commitment ))[ \"result\" ] sleep ( sleep_seconds ) else : maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) raise TransactionExpiredBlockheightExceededError ( f \" { tx_sig } has expired: block height exceeded\" ) return resp else : while time () < timeout : resp = self . get_signature_statuses ([ tx_sig ]) maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) resp_value = resp [ \"result\" ][ \"value\" ][ 0 ] if resp_value is not None : confirmation_status = resp_value [ \"confirmationStatus\" ] confirmation_rank = COMMITMENT_RANKS [ confirmation_status ] if confirmation_rank >= commitment_rank : break sleep ( sleep_seconds ) else : maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) raise UnconfirmedTxError ( f \"Unable to confirm transaction { tx_sig } \" ) return resp get_account_info ( self , pubkey , commitment = None , encoding = 'base64' , data_slice = None , min_context_slot = None ) Returns all the account info for the specified public key. Parameters: Name Type Description Default pubkey Union[PublicKey, str] Pubkey of account to query, as base-58 encoded string or PublicKey object. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding str (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". \"base58\" is limited to Account data of less than 128 bytes. \"base64\" will return base64 encoded data for Account data of any size. \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). 'base64' data_slice Optional[types.DataSliceOpts] (optional) Option to limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None min_context_slot Optional[int] set the minimum slot that the request can be evaluated at None Examples: >>> from solana.publickey import PublicKey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_account_info ( PublicKey ( 1 )) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 33265073 }, 'value' : { 'data' : '' , 'executable' : False , 'lamports' : 4459816188034584 , 'owner' : '11111111111111111111111111111111' , 'rentEpoch' : 90 }}, 'id' : 1 } Source code in solana/rpc/api.py def get_account_info ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns all the account info for the specified public key. Args: pubkey: Pubkey of account to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. - \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. min_context_slot: set the minimum slot that the request can be evaluated at Example: >>> from solana.publickey import PublicKey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_account_info(PublicKey(1)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 33265073}, 'value': {'data': '', 'executable': False, 'lamports': 4459816188034584, 'owner': '11111111111111111111111111111111', 'rentEpoch': 90}}, 'id': 1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_account_info_args ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , min_context_slot = min_context_slot , ) return self . _provider . make_request ( * args ) get_balance ( self , pubkey , commitment = None , min_context_slot = None ) Returns the balance of the account of provided Pubkey. Parameters: Name Type Description Default pubkey Union[PublicKey, str] Pubkey of account to query, as base-58 encoded string or PublicKey object. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None min_context_slot Optional[int] set the minimum slot that the request can be evaluated at None Examples: >>> from solana.publickey import PublicKey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_balance ( PublicKey ( 1 )) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 228 }, 'value' : 0 }, 'id' : 1 } Source code in solana/rpc/api.py def get_balance ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns the balance of the account of provided Pubkey. Args: pubkey: Pubkey of account to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". min_context_slot: set the minimum slot that the request can be evaluated at Example: >>> from solana.publickey import PublicKey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_balance(PublicKey(1)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 228}, 'value': 0}, 'id': 1} \"\"\" args = self . _get_balance_args ( pubkey , commitment , min_context_slot ) return self . _provider . make_request ( * args ) get_block ( self , slot , encoding = 'json' , commitment = None , rewards = None , transaction_details = None , max_support_transaction_version = None ) Returns identity and transaction information about a confirmed block in the ledger. Parameters: Name Type Description Default slot int Slot, as u64 integer. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' commitment Optional[Commitment] (optional) It can be either \"finalized\", \"confirmed\". \"processed\" is not supported. If parameter not provided, the default is \"finalized\". None rewards Optional[bool] (optional) whether to populate the rewards array. If parameter not provided, the default includes rewards. None transaction_details Optional[str] (optional) level of transaction detail to return, either \"full\", \"accounts\", \"signatures\", or \"none\". If parameter not provided, the default detail level is \"full\". None max_support_transaction_version Optional[int] (optional) set the max transaction version to return in responses. If the requested block contains a transaction with a higher version, an error will be returned. None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_block ( 1 ) { 'jsonrpc' : '2.0' , 'result' : { 'blockTime' : None , 'blockHeight' : 0 , 'blockhash' : '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj' , 'parentSlot' : 0 , 'previousBlockhash' : 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2' , 'rewards' : [], 'transactions' : [{ 'meta' : { 'err' : None , 'fee' : 0 , 'postBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'preBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'status' : { 'Ok' : None }}, 'transaction' : { 'message' : { 'accountKeys' : [ 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk' , 'EKAar3bMQUZvGSonq7vcPF2nPaCYowbnat44FPafW8Po' , 'SysvarS1otHashes111111111111111111111111111' , 'SysvarC1ock11111111111111111111111111111111' , 'Vote111111111111111111111111111111111111111' ], 'header' : { 'numReadonlySignedAccounts' : 0 , 'numReadonlyUnsignedAccounts' : 3 , 'numRequiredSignatures' : 1 }, 'instructions' : [{ 'accounts' : [ 1 , 2 , 3 , 0 ], 'data' : '37u9WtQpcm6ULa3VmTgTKEBCtYMxq84mk82tRvKdFEwj3rALiptAzuMJ1yoVSFAMARMZYp7q' , 'programIdIndex' : 4 }], 'recentBlockhash' : 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2' }, 'signatures' : [ '63jnpMCs7TNnCjnTqUrX7Mvqc5CbJMtVkLxBjPHUQkjXyZrQuZpfhjvzA7A29D9tMqVaiQC3UNP1NeaZKFFHJyQE' ]}}]}, 'id' : 9 } >>> solana_client . get_block ( 1 , encoding = \"base64\" ) { 'jsonrpc' : '2.0' , 'result' : { 'blockTime' : None , 'blockHeight' : 0 , 'blockhash' : '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj' , 'parentSlot' : 0 , 'previousBlockhash' : 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2' , 'rewards' : [], 'transactions' : [{ 'meta' : { 'err' : None , 'fee' : 0 , 'postBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'preBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'status' : { 'Ok' : None }}, 'transaction' : [ 'AfxyKHmHIjXWjkyHODGeAbVxmfQWPj1ydS9nF+ynJHo8I1vCPDp2P9Cj5aA6W1CAHEHCqY0B1FDKomCzRo3qrAsBAAMFBQ6QBWfhQF7rG02xhuEsmmrUtz3AUjBtJKkqaHPJEmvFzziDX0C0robPrl9RbOyXHoc9/Dxa0zoGL6cEjvCjLgan1RcZLwqvxvJl4/t3zHragsUp0L47E24tAFUgAAAABqfVFxjHdMkoVmOYaR1etoteuKObS21cc1VbIQAAAAAHYUgdNXR0u3xNdiTr072z2DVec9EQQ/wNo1OAAAAAAM8NSv7ISDPN9E9XNL9vX7h8LuJHWlopUcX39DxsDx23AQQEAQIDADUCAAAAAQAAAAAAAAAAAAAAAAAAAIWWp5Il3Kg312pzVk6Jt61iyFhTbtmkh/ORbj3JUQRbAA==' , 'base64' ]}]}, 'id' : 10 } Source code in solana/rpc/api.py def get_block ( self , slot : int , encoding : str = \"json\" , commitment : Optional [ Commitment ] = None , rewards : Optional [ bool ] = None , transaction_details : Optional [ str ] = None , max_support_transaction_version : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. commitment:(optional) It can be either \"finalized\", \"confirmed\". \"processed\" is not supported. If parameter not provided, the default is \"finalized\". rewards: (optional) whether to populate the rewards array. If parameter not provided, the default includes rewards. transaction_details: (optional) level of transaction detail to return, either \"full\", \"accounts\", \"signatures\", or \"none\". If parameter not provided, the default detail level is \"full\". max_support_transaction_version: (optional) set the max transaction version to return in responses. If the requested block contains a transaction with a higher version, an error will be returned. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block(1) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockHeight': 0, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': {'message': {'accountKeys': ['LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk', 'EKAar3bMQUZvGSonq7vcPF2nPaCYowbnat44FPafW8Po', 'SysvarS1otHashes111111111111111111111111111', 'SysvarC1ock11111111111111111111111111111111', 'Vote111111111111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 3, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [1, 2, 3, 0], 'data': '37u9WtQpcm6ULa3VmTgTKEBCtYMxq84mk82tRvKdFEwj3rALiptAzuMJ1yoVSFAMARMZYp7q', 'programIdIndex': 4}], 'recentBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2'}, 'signatures': ['63jnpMCs7TNnCjnTqUrX7Mvqc5CbJMtVkLxBjPHUQkjXyZrQuZpfhjvzA7A29D9tMqVaiQC3UNP1NeaZKFFHJyQE']}}]}, 'id': 9} >>> solana_client.get_block(1, encoding=\"base64\") # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockHeight': 0, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': ['AfxyKHmHIjXWjkyHODGeAbVxmfQWPj1ydS9nF+ynJHo8I1vCPDp2P9Cj5aA6W1CAHEHCqY0B1FDKomCzRo3qrAsBAAMFBQ6QBWfhQF7rG02xhuEsmmrUtz3AUjBtJKkqaHPJEmvFzziDX0C0robPrl9RbOyXHoc9/Dxa0zoGL6cEjvCjLgan1RcZLwqvxvJl4/t3zHragsUp0L47E24tAFUgAAAABqfVFxjHdMkoVmOYaR1etoteuKObS21cc1VbIQAAAAAHYUgdNXR0u3xNdiTr072z2DVec9EQQ/wNo1OAAAAAAM8NSv7ISDPN9E9XNL9vX7h8LuJHWlopUcX39DxsDx23AQQEAQIDADUCAAAAAQAAAAAAAAAAAAAAAAAAAIWWp5Il3Kg312pzVk6Jt61iyFhTbtmkh/ORbj3JUQRbAA==', 'base64']}]}, 'id': 10} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_block_args ( slot , encoding , commitment , rewards , transaction_details , max_support_transaction_version , ) return self . _provider . make_request ( * args ) get_block_commitment ( self , slot ) Fetch the commitment for particular block. Parameters: Name Type Description Default slot int Block, identified by Slot. required Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_block_commitment ( 0 ) { 'jsonrpc' : '2.0' , 'result' : { 'commitment' : [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 497717120 ], 'totalStake' : 497717120 }, 'id' : 1 }} Source code in solana/rpc/api.py def get_block_commitment ( self , slot : int ) -> types . RPCResponse : \"\"\"Fetch the commitment for particular block. Args: slot: Block, identified by Slot. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_commitment(0) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'commitment': [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 497717120], 'totalStake': 497717120}, 'id': 1}} \"\"\" args = self . _get_block_commitment_args ( slot ) return self . _provider . make_request ( * args ) get_block_height ( self , commitment = None , min_context_slot = None ) Returns the current block height of the node. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_block_height () { 'jsonrpc' : '2.0' , 'result' : 1233 , 'id' : 1 } Source code in solana/rpc/api.py def get_block_height ( self , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns the current block height of the node. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_height() # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1233, 'id': 1} \"\"\" args = self . _get_block_height_args ( commitment , min_context_slot ) return self . _provider . make_request ( * args ) get_block_production ( self , commitment = None , first_slot = None , last_slot = None , identity = None ) Returns recent block production information from the current or previous epoch. Parameters: Name Type Description Default (optional) first_slot - first slot to return block production information for (inclusive) required (optional) last_slot - last slot to return block production information for (inclusive). If parameter not provided, defaults to the highest slot required (optional) identity - Only return results for this validator identity (base-58 encoded) required Examples: solana_client = Client(\"http://localhost:8899\") solana_client.get_block_production() Source code in solana/rpc/api.py def get_block_production ( self , commitment : Optional [ Commitment ] = None , first_slot : Optional [ int ] = None , last_slot : Optional [ int ] = None , identity : Optional [ str ] = None , ) -> types . RPCResponse : \"\"\"Returns recent block production information from the current or previous epoch. Args: (optional) commitment (optional) first_slot: <u64> - first slot to return block production information for (inclusive) (optional) last_slot: <u64> - last slot to return block production information for (inclusive). If parameter not provided, defaults to the highest slot (optional) identity: <string> - Only return results for this validator identity (base-58 encoded) Example: solana_client = Client(\"http://localhost:8899\") solana_client.get_block_production() \"\"\" args = self . _get_block_production_args ( commitment , first_slot , last_slot , identity , ) return self . _provider . make_request ( * args ) get_block_time ( self , slot ) Fetch the estimated production time of a block. Parameters: Name Type Description Default slot int Block, identified by Slot. required Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_block_time ( 5 ) { 'jsonrpc' : '2.0' , 'result' : 1598400007 , 'id' : 1 } Source code in solana/rpc/api.py def get_block_time ( self , slot : int ) -> types . RPCResponse : \"\"\"Fetch the estimated production time of a block. Args: slot: Block, identified by Slot. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_time(5) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1598400007, 'id': 1} \"\"\" args = self . _get_block_time_args ( slot ) return self . _provider . make_request ( * args ) get_blocks ( self , start_slot , end_slot = None ) Returns a list of confirmed blocks. Parameters: Name Type Description Default start_slot int Start slot, as u64 integer. required end_slot Optional[int] (optional) End slot, as u64 integer. None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_blocks ( 5 , 10 ) { 'jsonrpc' : '2.0' , 'result' : [ 5 , 6 , 7 , 8 , 9 , 10 ], 'id' : 1 } Source code in solana/rpc/api.py def get_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> types . RPCResponse : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_blocks(5, 10) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [5, 6, 7, 8, 9, 10], 'id': 1} \"\"\" args = self . _get_blocks_args ( start_slot , end_slot ) return self . _provider . make_request ( * args ) get_blocks_with_limit ( self , start_slot , limit , commitment = None ) Returns a list of confirmed blocks starting at the given slot Examples: solana_client = Client(\"http://localhost:8899\") solana_client.get_blocks_with_limit(126411503, 5) solana_client.get_blocks_with_limit(126411503, 10, 'confirmed') Source code in solana/rpc/api.py def get_blocks_with_limit ( self , start_slot : int , limit : int , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\" Returns a list of confirmed blocks starting at the given slot Parameters: <u64> - start_slot, as u64 integer <u64> - limit, as u64 integer (optional) Commitment; \"processed\" is not supported. If parameter not provided, the default is \"finalized\". Example: solana_client = Client(\"http://localhost:8899\") solana_client.get_blocks_with_limit(126411503, 5) solana_client.get_blocks_with_limit(126411503, 10, 'confirmed') \"\"\" args = self . _get_blocks_with_limit_args ( start_slot , limit , commitment ) return self . _provider . make_request ( * args ) get_cluster_nodes ( self ) Returns information about all the nodes participating in the cluster. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_cluster_nodes () { 'jsonrpc' : '2.0' , 'result' : [{ 'gossip' : '127.0.0.1:8001' , 'pubkey' : 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk' , 'rpc' : '127.0.0.1:8899' , 'tpu' : '127.0.0.1:8003' , 'version' : '1.4.0 5332fcad' }], 'id' : 1 } Source code in solana/rpc/api.py def get_cluster_nodes ( self ) -> types . RPCResponse : \"\"\"Returns information about all the nodes participating in the cluster. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_cluster_nodes() # doctest: +SKIP {'jsonrpc': '2.0', 'result': [{'gossip': '127.0.0.1:8001', 'pubkey': 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk', 'rpc': '127.0.0.1:8899', 'tpu': '127.0.0.1:8003', 'version': '1.4.0 5332fcad'}], 'id': 1} \"\"\" return self . _provider . make_request ( self . _get_cluster_nodes ) get_confirmed_block ( self , slot , encoding = 'json' , max_support_transaction_version = None ) Returns identity and transaction information about a confirmed block in the ledger. Parameters: Name Type Description Default slot int Slot, as u64 integer. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_confirmed_block ( 1 ) { 'jsonrpc' : '2.0' , 'result' : { 'blockTime' : None , 'blockhash' : '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj' , 'parentSlot' : 0 , 'previousBlockhash' : 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2' , 'rewards' : [], 'transactions' : [{ 'meta' : { 'err' : None , 'fee' : 0 , 'postBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'preBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'status' : { 'Ok' : None }}, 'transaction' : { 'message' : { 'accountKeys' : [ 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk' , 'EKAar3bMQUZvGSonq7vcPF2nPaCYowbnat44FPafW8Po' , 'SysvarS1otHashes111111111111111111111111111' , 'SysvarC1ock11111111111111111111111111111111' , 'Vote111111111111111111111111111111111111111' ], 'header' : { 'numReadonlySignedAccounts' : 0 , 'numReadonlyUnsignedAccounts' : 3 , 'numRequiredSignatures' : 1 }, 'instructions' : [{ 'accounts' : [ 1 , 2 , 3 , 0 ], 'data' : '37u9WtQpcm6ULa3VmTgTKEBCtYMxq84mk82tRvKdFEwj3rALiptAzuMJ1yoVSFAMARMZYp7q' , 'programIdIndex' : 4 }], 'recentBlockhash' : 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2' }, 'signatures' : [ '63jnpMCs7TNnCjnTqUrX7Mvqc5CbJMtVkLxBjPHUQkjXyZrQuZpfhjvzA7A29D9tMqVaiQC3UNP1NeaZKFFHJyQE' ]}}]}, 'id' : 9 } >>> solana_client . get_confirmed_block ( 1 , encoding = \"base64\" ) { 'jsonrpc' : '2.0' , 'result' : { 'blockTime' : None , 'blockhash' : '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj' , 'parentSlot' : 0 , 'previousBlockhash' : 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2' , 'rewards' : [], 'transactions' : [{ 'meta' : { 'err' : None , 'fee' : 0 , 'postBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'preBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'status' : { 'Ok' : None }}, 'transaction' : [ 'AfxyKHmHIjXWjkyHODGeAbVxmfQWPj1ydS9nF+ynJHo8I1vCPDp2P9Cj5aA6W1CAHEHCqY0B1FDKomCzRo3qrAsBAAMFBQ6QBWfhQF7rG02xhuEsmmrUtz3AUjBtJKkqaHPJEmvFzziDX0C0robPrl9RbOyXHoc9/Dxa0zoGL6cEjvCjLgan1RcZLwqvxvJl4/t3zHragsUp0L47E24tAFUgAAAABqfVFxjHdMkoVmOYaR1etoteuKObS21cc1VbIQAAAAAHYUgdNXR0u3xNdiTr072z2DVec9EQQ/wNo1OAAAAAAM8NSv7ISDPN9E9XNL9vX7h8LuJHWlopUcX39DxsDx23AQQEAQIDADUCAAAAAQAAAAAAAAAAAAAAAAAAAIWWp5Il3Kg312pzVk6Jt61iyFhTbtmkh/ORbj3JUQRbAA==' , 'base64' ]}]}, 'id' : 10 } Source code in solana/rpc/api.py def get_confirmed_block ( self , slot : int , encoding : str = \"json\" , max_support_transaction_version = None , ) -> types . RPCResponse : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_confirmed_block(1) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': {'message': {'accountKeys': ['LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk', 'EKAar3bMQUZvGSonq7vcPF2nPaCYowbnat44FPafW8Po', 'SysvarS1otHashes111111111111111111111111111', 'SysvarC1ock11111111111111111111111111111111', 'Vote111111111111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 3, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [1, 2, 3, 0], 'data': '37u9WtQpcm6ULa3VmTgTKEBCtYMxq84mk82tRvKdFEwj3rALiptAzuMJ1yoVSFAMARMZYp7q', 'programIdIndex': 4}], 'recentBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2'}, 'signatures': ['63jnpMCs7TNnCjnTqUrX7Mvqc5CbJMtVkLxBjPHUQkjXyZrQuZpfhjvzA7A29D9tMqVaiQC3UNP1NeaZKFFHJyQE']}}]}, 'id': 9} >>> solana_client.get_confirmed_block(1, encoding=\"base64\") # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': ['AfxyKHmHIjXWjkyHODGeAbVxmfQWPj1ydS9nF+ynJHo8I1vCPDp2P9Cj5aA6W1CAHEHCqY0B1FDKomCzRo3qrAsBAAMFBQ6QBWfhQF7rG02xhuEsmmrUtz3AUjBtJKkqaHPJEmvFzziDX0C0robPrl9RbOyXHoc9/Dxa0zoGL6cEjvCjLgan1RcZLwqvxvJl4/t3zHragsUp0L47E24tAFUgAAAABqfVFxjHdMkoVmOYaR1etoteuKObS21cc1VbIQAAAAAHYUgdNXR0u3xNdiTr072z2DVec9EQQ/wNo1OAAAAAAM8NSv7ISDPN9E9XNL9vX7h8LuJHWlopUcX39DxsDx23AQQEAQIDADUCAAAAAQAAAAAAAAAAAAAAAAAAAIWWp5Il3Kg312pzVk6Jt61iyFhTbtmkh/ORbj3JUQRbAA==', 'base64']}]}, 'id': 10} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_confirmed_block_args ( slot , encoding , max_support_transaction_version , ) return self . _provider . make_request ( * args ) get_confirmed_blocks ( self , start_slot , end_slot = None ) Returns a list of confirmed blocks. Parameters: Name Type Description Default start_slot int Start slot, as u64 integer. required end_slot Optional[int] (optional) End slot, as u64 integer. None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_confirmed_blocks ( 5 , 10 ) { 'jsonrpc' : '2.0' , 'result' : [ 5 , 6 , 7 , 8 , 9 , 10 ], 'id' : 1 } Source code in solana/rpc/api.py def get_confirmed_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> types . RPCResponse : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_confirmed_blocks(5, 10) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [5, 6, 7, 8, 9, 10], 'id': 1} \"\"\" args = self . _get_confirmed_blocks_args ( start_slot , end_slot ) return self . _provider . make_request ( * args ) get_confirmed_signature_for_address2 ( self , account , before = None , until = None , limit = None , commitment = None ) Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Parameters: Name Type Description Default account Union[str, Keypair, PublicKey] Account to be queried. required before Optional[str] (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. None until Optional[str] (optional) Search until this transaction signature, if found before limit reached. None limit Optional[int] (optoinal) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). None commitment Optional[Commitment] (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_confirmed_signature_for_address2 ( \"Vote111111111111111111111111111111111111111\" , limit = 1 ) { 'jsonrpc' : '2.0' , 'result' : [{ 'err' : None , 'memo' : None , 'signature' : 'v1BK8XcaPBzAGd7TB1K53pMdi6TBGe5CLCgx8cmZ4Bj63ZNvA6ca2QaxFpBFdvmpoFQ51VorBjifkBGLTDhwpqN' , 'slot' : 4290 }], 'id' : 2 } Source code in solana/rpc/api.py def get_confirmed_signature_for_address2 ( self , account : Union [ str , Keypair , PublicKey ], before : Optional [ str ] = None , until : Optional [ str ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optoinal) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_confirmed_signature_for_address2(\"Vote111111111111111111111111111111111111111\", limit=1) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [{'err': None, 'memo': None, 'signature': 'v1BK8XcaPBzAGd7TB1K53pMdi6TBGe5CLCgx8cmZ4Bj63ZNvA6ca2QaxFpBFdvmpoFQ51VorBjifkBGLTDhwpqN', 'slot': 4290}], 'id': 2} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_confirmed_signature_for_address2_args ( account , before , until , limit , commitment ) return self . _provider . make_request ( * args ) get_confirmed_transaction ( self , tx_sig , encoding = 'json' ) Returns transaction details for a confirmed transaction. Parameters: Name Type Description Default tx_sig str Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the transaction.message.instructions list. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_confirmed_transaction ( \"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\" ) { 'jsonrpc' : '2.0' , 'result' : { 'meta' : { 'err' : None , 'fee' : 5000 , 'postBalances' : [ 498449233720610510 , 1000001001987940 , 1 ], 'preBalances' : [ 498449233721615510 , 1000001000987940 , 1 ], 'status' : { 'Ok' : None }}, 'slot' : 1659335 , 'transaction' : { 'message' : { 'accountKeys' : [ '9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g' , '2KW2XRd9kwqet15Aha2oK3tYvd3nWbTFH1MBiRAv1BE1' , '11111111111111111111111111111111' ], 'header' : { 'numReadonlySignedAccounts' : 0 , 'numReadonlyUnsignedAccounts' : 1 , 'numRequiredSignatures' : 1 }, 'instructions' : [{ 'accounts' : [ 0 , 1 ], 'data' : '3Bxs4Bc3VYuGVB19' , 'programIdIndex' : 2 }], 'recentBlockhash' : 'FwcsKNptGtMLccXAA9YgnivVFK95mKzECLT1DNPi3SDr' }, 'signatures' : [ '3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy' ]}}, 'id' : 4 } Source code in solana/rpc/api.py def get_confirmed_transaction ( self , tx_sig : str , encoding : str = \"json\" ) -> types . RPCResponse : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_confirmed_transaction(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\") # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'meta': {'err': None, 'fee': 5000, 'postBalances': [498449233720610510, 1000001001987940, 1], 'preBalances': [498449233721615510, 1000001000987940, 1], 'status': {'Ok': None}}, 'slot': 1659335, 'transaction': {'message': {'accountKeys': ['9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g', '2KW2XRd9kwqet15Aha2oK3tYvd3nWbTFH1MBiRAv1BE1', '11111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 1, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [0, 1], 'data': '3Bxs4Bc3VYuGVB19', 'programIdIndex': 2}], 'recentBlockhash': 'FwcsKNptGtMLccXAA9YgnivVFK95mKzECLT1DNPi3SDr'}, 'signatures': ['3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy']}}, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_confirmed_transaction_args ( tx_sig , encoding ) return self . _provider . make_request ( * args ) get_epoch_info ( self , commitment = None , min_context_slot = None ) Returns information about the current epoch. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_epoch_info () { 'jsonrpc' : '2.0' , 'result' : { 'absoluteSlot' : 5150 , 'blockHeight' : 5150 , 'epoch' : 0 , 'slotIndex' : 5150 , 'slotsInEpoch' : 8192 }, 'id' : 5 } Source code in solana/rpc/api.py def get_epoch_info ( self , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns information about the current epoch. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_epoch_info() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'absoluteSlot': 5150, 'blockHeight': 5150, 'epoch': 0, 'slotIndex': 5150, 'slotsInEpoch': 8192}, 'id': 5} \"\"\" args = self . _get_epoch_info_args ( commitment , min_context_slot ) return self . _provider . make_request ( * args ) get_epoch_schedule ( self ) Returns epoch schedule information from this cluster's genesis config. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_epoch_schedule () { 'jsonrpc' : '2.0' , 'result' : { 'firstNormalEpoch' : 0 , 'firstNormalSlot' : 0 , 'leaderScheduleSlotOffset' : 8192 , 'slotsPerEpoch' : 8192 , 'warmup' : False }, 'id' : 6 } Source code in solana/rpc/api.py def get_epoch_schedule ( self ) -> types . RPCResponse : \"\"\"Returns epoch schedule information from this cluster's genesis config. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_epoch_schedule() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'firstNormalEpoch': 0, 'firstNormalSlot': 0, 'leaderScheduleSlotOffset': 8192, 'slotsPerEpoch': 8192, 'warmup': False}, 'id': 6} \"\"\" return self . _provider . make_request ( self . _get_epoch_schedule ) get_fee_calculator_for_blockhash ( self , blockhash , commitment = None ) Returns the fee calculator associated with the query blockhash, or null if the blockhash has expired. Parameters: Name Type Description Default blockhash Union[str, Blockhash] Blockhash to query as a Base58 encoded string. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_fee_calculator_for_blockhash ( \"BaQSR194dC4dZaRxATtxYyEwDkk7VgqUY8NVNkub8HFZ\" ) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 7065 }, 'value' : { 'feeCalculator' : { 'lamportsPerSignature' : 5000 }}}, 'id' : 4 } Source code in solana/rpc/api.py def get_fee_calculator_for_blockhash ( self , blockhash : Union [ str , Blockhash ], commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the fee calculator associated with the query blockhash, or null if the blockhash has expired. Args: blockhash: Blockhash to query as a Base58 encoded string. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_fee_calculator_for_blockhash(\"BaQSR194dC4dZaRxATtxYyEwDkk7VgqUY8NVNkub8HFZ\") # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 7065}, 'value': {'feeCalculator': {'lamportsPerSignature': 5000}}}, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_fee_calculator_for_blockhash_args ( blockhash , commitment ) return self . _provider . make_request ( * args ) get_fee_for_message ( self , message , commitment = None ) Get the fee the network will charge for a particular Message NEW: This method is only available in solana-core v1.9 or newer. Please use getRecentBlockhash for solana-core v1.8 Parameters: Name Type Description Default message str Base-64 encoded Message required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: solana_client = Client(\"http://localhost:8899\") solana_client.get_fee_for_message( 'AQABAgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQAA' ) Source code in solana/rpc/api.py def get_fee_for_message ( self , message : str , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Get the fee the network will charge for a particular Message NEW: This method is only available in solana-core v1.9 or newer. Please use getRecentBlockhash for solana-core v1.8 Args: message: Base-64 encoded Message commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: solana_client = Client(\"http://localhost:8899\") solana_client.get_fee_for_message( 'AQABAgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQAA' ) \"\"\" args = self . _get_fee_for_message_args ( message , commitment ) return self . _provider . make_request ( * args ) get_fee_rate_governor ( self ) Returns the fee rate governor information from the root bank. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_fee_rate_governor () { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 7172 }, 'value' : { 'feeRateGovernor' : { 'burnPercent' : 50 , 'maxLamportsPerSignature' : 100000 , 'minLamportsPerSignature' : 5000 , 'targetLamportsPerSignature' : 10000 , 'targetSignaturesPerSlot' : 20000 }}}, 'id' : 5 } Source code in solana/rpc/api.py def get_fee_rate_governor ( self ) -> types . RPCResponse : \"\"\"Returns the fee rate governor information from the root bank. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_fee_rate_governor() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 7172}, 'value': {'feeRateGovernor': {'burnPercent': 50, 'maxLamportsPerSignature': 100000, 'minLamportsPerSignature': 5000, 'targetLamportsPerSignature': 10000, 'targetSignaturesPerSlot': 20000}}}, 'id': 5} \"\"\" return self . _provider . make_request ( self . _get_fee_rate_governor ) get_fees ( self , commitment = None ) Returns a recent block hash from the ledger, a fee schedule and the last slot the blockhash will be valid. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_fees () { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 7727 }, 'value' : { 'blockhash' : 'GGS6AEDqjF5irU6D6VQNherEZ2hckGaeBiVdfSZKg4gd' , 'feeCalculator' : { 'lamportsPerSignature' : 5000 }, 'lastValidSlot' : 8027 }}, 'id' : 1 } Source code in solana/rpc/api.py def get_fees ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns a recent block hash from the ledger, a fee schedule and the last slot the blockhash will be valid. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_fees() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 7727}, 'value': {'blockhash': 'GGS6AEDqjF5irU6D6VQNherEZ2hckGaeBiVdfSZKg4gd', 'feeCalculator': {'lamportsPerSignature': 5000}, 'lastValidSlot': 8027}}, 'id': 1} \"\"\" args = self . _get_fees_args ( commitment ) return self . _provider . make_request ( * args ) get_first_available_block ( self ) Returns the slot of the lowest confirmed block that has not been purged from the ledger. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_fees () { 'jsonrpc' : '2.0' , 'result' : 1 , 'id' : 2 } Source code in solana/rpc/api.py def get_first_available_block ( self ) -> types . RPCResponse : \"\"\"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_fees() # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1, 'id': 2} \"\"\" return self . _provider . make_request ( self . _get_first_available_block ) get_genesis_hash ( self ) Returns the genesis hash. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_genesis_hash () { 'jsonrpc' : '2.0' , 'result' : 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2' , 'id' : 3 } Source code in solana/rpc/api.py def get_genesis_hash ( self ) -> types . RPCResponse : \"\"\"Returns the genesis hash. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_genesis_hash() # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'id': 3} \"\"\" return self . _provider . make_request ( self . _get_genesis_hash ) get_health ( self ) Returns the current health of the node. solana_client = Client(\"http://localhost:8899\") solana_client.get_health() # doctest: +SKIP Healthy result: {\"jsonrpc\":\"2.0\", \"result\": \"ok\", \"id\":1} Source code in solana/rpc/api.py def get_health ( self ) -> types . RPCResponse : \"\"\"Returns the current health of the node. >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_health() # doctest: +SKIP Healthy result: {\"jsonrpc\":\"2.0\", \"result\": \"ok\", \"id\":1} \"\"\" return self . _provider . make_request ( self . _get_health ) get_highest_snapshot_slot ( self ) Returns the highest slot information that the node has snapshots for. This will find the highest full snapshot slot, and the highest incremental snapshot slot based on the full snapshot slot, if there is one. solana_client = Client(\"http://localhost:8899\") solana_client.get_highest_snapshot_slot() Source code in solana/rpc/api.py def get_highest_snapshot_slot ( self ) -> types . RPCResponse : \"\"\" Returns the highest slot information that the node has snapshots for. This will find the highest full snapshot slot, and the highest incremental snapshot slot based on the full snapshot slot, if there is one. solana_client = Client(\"http://localhost:8899\") solana_client.get_highest_snapshot_slot() \"\"\" return self . _provider . make_request ( types . RPCMethod ( \"getHighestSnapshotSlot\" ), ) get_identity ( self ) Returns the identity pubkey for the current node. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_identity () { 'jsonrpc' : '2.0' , 'result' : { 'identity' : 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk' }, 'id' : 4 } Source code in solana/rpc/api.py def get_identity ( self ) -> types . RPCResponse : \"\"\"Returns the identity pubkey for the current node. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_identity() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'identity': 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk'}, 'id': 4} \"\"\" return self . _provider . make_request ( self . _get_identity ) get_inflation_governor ( self , commitment = None ) Returns the current inflation governor. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_inflation_governor () { 'jsonrpc' : '2.0' , 'result' : { 'foundation' : 0.05 , 'foundationTerm' : 7.0 , 'initial' : 0.15 , 'taper' : 0.15 , 'terminal' : 0.015 }, 'id' : 5 } Source code in solana/rpc/api.py def get_inflation_governor ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the current inflation governor. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_governor() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'foundation': 0.05, 'foundationTerm': 7.0, 'initial': 0.15, 'taper': 0.15, 'terminal': 0.015}, 'id': 5} \"\"\" args = self . _get_inflation_governor_args ( commitment ) return self . _provider . make_request ( * args ) get_inflation_rate ( self ) Returns the specific inflation values for the current epoch. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_inflation_rate () { 'jsonrpc' : '2.0' , 'result' : { 'epoch' : 1 , 'foundation' : 0.007499746885736559 , 'total' : 0.14999493771473116 , 'validator' : 0.1424951908289946 }, 'id' : 1 } Source code in solana/rpc/api.py def get_inflation_rate ( self ) -> types . RPCResponse : \"\"\"Returns the specific inflation values for the current epoch. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_rate() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'epoch': 1, 'foundation': 0.007499746885736559, 'total': 0.14999493771473116, 'validator': 0.1424951908289946}, 'id': 1} \"\"\" return self . _provider . make_request ( self . _get_inflation_rate ) get_inflation_reward ( self , address_list , commitment = None , epoch = None , min_context_slot = None ) Returns the inflation reward for a list of addresses for an epoch. :param address_list: An array of addresses to query, as base-58 encoded strings :param commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". :param epoch: An epoch for which the reward occurs. If omitted, the previous epoch will be used solana_client = Client(\"http://localhost:8899\") solana_client.get_inflation_reward(address_list) # doctest: +SKIP { \"jsonrpc\": \"2.0\", \"result\": [ { \"amount\": 2500, \"effectiveSlot\": 224, \"epoch\": 2, \"postBalance\": 499999442500 }, null ], \"id\": 1 } Source code in solana/rpc/api.py def get_inflation_reward ( self , address_list : List [ Union [ str , PublicKey ]], commitment : Optional [ Commitment ] = None , epoch : Optional [ int ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns the inflation reward for a list of addresses for an epoch. :param address_list: An array of addresses to query, as base-58 encoded strings :param commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". :param epoch: An epoch for which the reward occurs. If omitted, the previous epoch will be used >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_reward(address_list) # doctest: +SKIP { \"jsonrpc\": \"2.0\", \"result\": [ { \"amount\": 2500, \"effectiveSlot\": 224, \"epoch\": 2, \"postBalance\": 499999442500 }, null ], \"id\": 1 } \"\"\" args = self . _get_inflation_reward_args ( address_list = address_list , commitment = commitment , epoch = epoch , min_context_slot = min_context_slot , ) return self . _provider . make_request ( * args ) get_largest_accounts ( self , filter_opt = None , commitment = None ) Returns the 20 largest accounts, by lamport balance. Parameters: Name Type Description Default filter_opt Optional[str] Filter results by account type; currently supported: circulating|nonCirculating. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_largest_accounts () { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 8890 }, 'value' : [{ 'address' : '95L7AsBCLRsqghsi6ksZkzjNbs6rqDgHCzKaGZ7bJi75' , 'lamports' : 500000000000000000 }, { 'address' : 'APnSR52EC1eH676m7qTBHUJ1nrGpHYpV7XKPxgRDD8gX' , 'lamports' : 164511033098290000 }, { 'address' : '13LeFbG6m2EP1fqCj9k66fcXsoTHMMtgr7c78AivUrYD' , 'lamports' : 153333632446109120 }, { 'address' : 'GK2zqSsXLA2rwVZk347RYhh6jJpRsCA69FjLW93ZGi3B' , 'lamports' : 57499999036109120 }, { 'address' : '8HVqyX9jebh31Q9Hp8t5sMVJs665979ZeEr3eCfzitUe' , 'lamports' : 30301031036109120 }, { 'address' : 'HbZ5FfmKWNHC7uwk6TF1hVi6TCs7dtYfdjEcuPGgzFAg' , 'lamports' : 14999999036109120 }, { 'address' : '14FUT96s9swbmH7ZjpDvfEDywnAYy9zaNhv4xvezySGu' , 'lamports' : 4999999036109120 }, { 'address' : '9huDUZfxoJ7wGMTffUE7vh1xePqef7gyrLJu9NApncqA' , 'lamports' : 4999999036109120 }, { 'address' : 'C7C8odR8oashR5Feyrq2tJKaXL18id1dSj2zbkDGL2C2' , 'lamports' : 4999999036109120 }, { 'address' : 'AYgECURrvuX6GtFe4tX7aAj87Xc5r5Znx96ntNk1nCv' , 'lamports' : 2499999518054560 }, { 'address' : 'AogcwQ1ubM76EPMhSD5cw1ES4W5econvQCFmBL6nTW1' , 'lamports' : 2499999518054560 }, { 'address' : 'gWgqQ4udVxE3uNxRHEwvftTHwpEmPHAd8JR9UzaHbR2' , 'lamports' : 2499999518054560 }, { 'address' : '3D91zLQPRLamwJfGR5ZYMKQb4C18gsJNaSdmB6b2wLhw' , 'lamports' : 2499999518054560 }, { 'address' : '3bHbMa5VW3np5AJazuacidrN4xPZgwhcXigmjwHmBg5e' , 'lamports' : 2499999518054560 }, { 'address' : '4U3RFq7X5kLG6tZ9kcksFL8oXeGNjtuUN1YfkVKXbs5x' , 'lamports' : 2499999518054560 }, { 'address' : '5cBVGBKY6kBaiTVmsQpxThJ2oqitBYuCAX9Zm2zMuV4y' , 'lamports' : 2499999518054560 }, { 'address' : '8PjJTv657aeN9p5R2WoM6pPSz385chvTTytUWaEjSjkq' , 'lamports' : 2499999518054560 }, { 'address' : 'AHB94zKUASftTdqgdfiDSdnPJHkEFp7zX3yMrcSxABsv' , 'lamports' : 2499999518054560 }, { 'address' : 'Hc36Wh1ZqYGzGAnsJWNT9r2gY3h9n89uDpxZPsmEsiE3' , 'lamports' : 2499999518054560 }, { 'address' : 'GxyRKP2eVKACaSSnso4VLSAjZKmHsFXHWUfS3A5CtiMA' , 'lamports' : 1940147018054560 }]}, 'id' : 2 } Source code in solana/rpc/api.py def get_largest_accounts ( self , filter_opt : Optional [ str ] = None , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the 20 largest accounts, by lamport balance. Args: filter_opt: Filter results by account type; currently supported: circulating|nonCirculating. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_largest_accounts() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 8890}, 'value': [{'address': '95L7AsBCLRsqghsi6ksZkzjNbs6rqDgHCzKaGZ7bJi75', 'lamports': 500000000000000000}, {'address': 'APnSR52EC1eH676m7qTBHUJ1nrGpHYpV7XKPxgRDD8gX', 'lamports': 164511033098290000}, {'address': '13LeFbG6m2EP1fqCj9k66fcXsoTHMMtgr7c78AivUrYD', 'lamports': 153333632446109120}, {'address': 'GK2zqSsXLA2rwVZk347RYhh6jJpRsCA69FjLW93ZGi3B', 'lamports': 57499999036109120}, {'address': '8HVqyX9jebh31Q9Hp8t5sMVJs665979ZeEr3eCfzitUe', 'lamports': 30301031036109120}, {'address': 'HbZ5FfmKWNHC7uwk6TF1hVi6TCs7dtYfdjEcuPGgzFAg', 'lamports': 14999999036109120}, {'address': '14FUT96s9swbmH7ZjpDvfEDywnAYy9zaNhv4xvezySGu', 'lamports': 4999999036109120}, {'address': '9huDUZfxoJ7wGMTffUE7vh1xePqef7gyrLJu9NApncqA', 'lamports': 4999999036109120}, {'address': 'C7C8odR8oashR5Feyrq2tJKaXL18id1dSj2zbkDGL2C2', 'lamports': 4999999036109120}, {'address': 'AYgECURrvuX6GtFe4tX7aAj87Xc5r5Znx96ntNk1nCv', 'lamports': 2499999518054560}, {'address': 'AogcwQ1ubM76EPMhSD5cw1ES4W5econvQCFmBL6nTW1', 'lamports': 2499999518054560}, {'address': 'gWgqQ4udVxE3uNxRHEwvftTHwpEmPHAd8JR9UzaHbR2', 'lamports': 2499999518054560}, {'address': '3D91zLQPRLamwJfGR5ZYMKQb4C18gsJNaSdmB6b2wLhw', 'lamports': 2499999518054560}, {'address': '3bHbMa5VW3np5AJazuacidrN4xPZgwhcXigmjwHmBg5e', 'lamports': 2499999518054560}, {'address': '4U3RFq7X5kLG6tZ9kcksFL8oXeGNjtuUN1YfkVKXbs5x', 'lamports': 2499999518054560}, {'address': '5cBVGBKY6kBaiTVmsQpxThJ2oqitBYuCAX9Zm2zMuV4y', 'lamports': 2499999518054560}, {'address': '8PjJTv657aeN9p5R2WoM6pPSz385chvTTytUWaEjSjkq', 'lamports': 2499999518054560}, {'address': 'AHB94zKUASftTdqgdfiDSdnPJHkEFp7zX3yMrcSxABsv', 'lamports': 2499999518054560}, {'address': 'Hc36Wh1ZqYGzGAnsJWNT9r2gY3h9n89uDpxZPsmEsiE3', 'lamports': 2499999518054560}, {'address': 'GxyRKP2eVKACaSSnso4VLSAjZKmHsFXHWUfS3A5CtiMA', 'lamports': 1940147018054560}]}, 'id': 2} \"\"\" args = self . _get_largest_accounts_args ( filter_opt , commitment ) return self . _provider . make_request ( * args ) get_latest_blockhash ( self , commitment = None , min_context_slot = None ) Returns the latest block hash from the ledger. Response also includes the last valid block height. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_latest_blockhash () { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 1637 }, 'value' : { 'blockhash' : 'EALChog1mXQ9nEgEUQpWAtmA5UueUZvZiL16ZivmR7eb' , 'lastValidBlockHeight' : 3090 }}, 'id' : 2 } Source code in solana/rpc/api.py def get_latest_blockhash ( self , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns the latest block hash from the ledger. Response also includes the last valid block height. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_latest_blockhash() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 1637}, 'value': {'blockhash': 'EALChog1mXQ9nEgEUQpWAtmA5UueUZvZiL16ZivmR7eb', 'lastValidBlockHeight': 3090}}, 'id': 2} \"\"\" args = self . _get_latest_blockhash_args ( commitment , min_context_slot ) return self . _provider . make_request ( * args ) get_leader_schedule ( self , epoch = None , commitment = None ) Returns the leader schedule for an epoch. Parameters: Name Type Description Default epoch Optional[int] Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_leader_schedule () { 'jsonrpc' : '2.0' , 'result' : { 'EWj2cuEuVhi7RX81cnAY3TzpyFwnHzzVwvuTyfmxmhs3' : [ 0 , 1 , 2 , 3 , 4 , 5 , ... ]}, 'id' : 6 } Source code in solana/rpc/api.py def get_leader_schedule ( self , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the leader schedule for an epoch. Args: epoch: Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_leader_schedule() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'EWj2cuEuVhi7RX81cnAY3TzpyFwnHzzVwvuTyfmxmhs3': [0, 1, 2, 3, 4, 5, ...]}, 'id': 6} \"\"\" args = self . _get_leader_schedule_args ( epoch , commitment ) return self . _provider . make_request ( * args ) get_max_retransmit_slot ( self ) Get the max slot seen from retransmit stage. Examples: solana_client = Client(\"http://localhost:8899\") solana_client.get_max_retransmit_slot() Source code in solana/rpc/api.py def get_max_retransmit_slot ( self ) -> types . RPCResponse : \"\"\" Get the max slot seen from retransmit stage. Example: solana_client = Client(\"http://localhost:8899\") solana_client.get_max_retransmit_slot() \"\"\" return self . _provider . make_request ( types . RPCMethod ( \"getMaxRetransmitSlot\" ), ) get_max_shred_insert_slot ( self ) Get the max slot seen from after shred insert. solana_client = Client(\"http://localhost:8899\") solana_client.get_max_shred_insert_slot() Source code in solana/rpc/api.py def get_max_shred_insert_slot ( self ) -> types . RPCResponse : \"\"\" Get the max slot seen from after shred insert. solana_client = Client(\"http://localhost:8899\") solana_client.get_max_shred_insert_slot() \"\"\" return self . _provider . make_request ( types . RPCMethod ( \"getMaxShredInsertSlot\" ), ) get_minimum_balance_for_rent_exemption ( self , usize , commitment = None ) Returns minimum balance required to make account rent exempt. Parameters: Name Type Description Default usize int Account data length. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_minimum_balance_for_rent_exemption ( 50 ) { 'jsonrpc' : '2.0' , 'result' : 1238880 , 'id' : 7 } Source code in solana/rpc/api.py def get_minimum_balance_for_rent_exemption ( self , usize : int , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns minimum balance required to make account rent exempt. Args: usize: Account data length. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_minimum_balance_for_rent_exemption(50) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1238880, 'id': 7} \"\"\" args = self . _get_minimum_balance_for_rent_exemption_args ( usize , commitment ) return self . _provider . make_request ( * args ) get_minimum_ledger_slot ( self ) Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_minimum_ledger_slot () { 'jsonrpc' : '2.0' , 'result' : 1234 , 'id' : 1 } Source code in solana/rpc/api.py def get_minimum_ledger_slot ( self ) -> types . RPCResponse : \"\"\"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_minimum_ledger_slot() # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1234, 'id': 1} \"\"\" return self . _provider . make_request ( self . _minimum_ledger_slot ) get_multiple_accounts ( self , pubkeys , commitment = None , encoding = 'base64' , data_slice = None , min_context_slot = None ) Returns all the account info for a list of public keys. Parameters: Name Type Description Default pubkeys List[Union[PublicKey, str]] list of Pubkeys to query, as base-58 encoded string or PublicKey object. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding str (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". \"base58\" is limited to Account data of less than 128 bytes. \"base64\" will return base64 encoded data for Account data of any size. \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). 'base64' data_slice Optional[types.DataSliceOpts] (optional) Option to limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None Examples: >>> from solana.publickey import PublicKey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> pubkeys = [ PublicKey ( \"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\" ), PublicKey ( \"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\" )] >>> solana_client . get_multiple_accounts ( pubkeys ) { \"jsonrpc\" : \"2.0\" , \"result\" : { \"context\" : { \"slot\" : 97531946 }, \"value\" : [ { \"data\" : [ \"\" , \"base64\" ], \"executable\" : False , \"lamports\" : 1 , \"owner\" : \"11111111111111111111111111111111\" , \"rentEpoch\" : 225 , }, { \"data\" : [ \"\" , \"base64\" ], \"executable\" : False , \"lamports\" : 809441127 , \"owner\" : \"11111111111111111111111111111111\" , \"rentEpoch\" : 225 , }, ], }, \"id\" : 1 , } Source code in solana/rpc/api.py def get_multiple_accounts ( self , pubkeys : List [ Union [ PublicKey , str ]], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. - \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solana.publickey import PublicKey >>> solana_client = Client(\"http://localhost:8899\") >>> pubkeys = [PublicKey(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), PublicKey(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> solana_client.get_multiple_accounts(pubkeys) # doctest: +SKIP { \"jsonrpc\": \"2.0\", \"result\": { \"context\": {\"slot\": 97531946}, \"value\": [ { \"data\": [\"\", \"base64\"], \"executable\": False, \"lamports\": 1, \"owner\": \"11111111111111111111111111111111\", \"rentEpoch\": 225, }, { \"data\": [\"\", \"base64\"], \"executable\": False, \"lamports\": 809441127, \"owner\": \"11111111111111111111111111111111\", \"rentEpoch\": 225, }, ], }, \"id\": 1, } \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_multiple_accounts_args ( pubkeys = pubkeys , commitment = commitment , encoding = encoding , data_slice = data_slice , min_context_slot = min_context_slot , ) return self . _provider . make_request ( * args ) get_program_accounts ( self , pubkey , commitment = 'finalized' , encoding = None , data_slice = None , data_size = None , memcmp_opts = None , with_context = None , min_context_slot = None ) Returns all accounts owned by the provided program Pubkey. Parameters: Name Type Description Default pubkey Union[str, PublicKey] Pubkey of program, as base-58 encoded string or PublicKey object. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". 'finalized' encoding Optional[str] (optional) Encoding for the returned Transaction, either jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. None data_slice Optional[types.DataSliceOpts] (optional) Limit the returned account data using the provided offset : and None ` length` fields; only available for \"base58\" or \"base64\" encoding. required data_size Optional[int] (optional) Option to compare the program account data length with the provided data size. None memcmp_opts Optional[List[types.MemcmpOpts]] (optional) Options to compare a provided series of bytes with program account data at a particular offset. None with_context Optional[bool] (optional ) Option to wrap the result in an RpcResponse JSON object. None min_context_slot Optional[int] (optional ) set the minimum slot that the request can be evaluated at None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> memcmp_opts = [ ... MemcmpOpt ( offset = 4 , bytes = \"3Mc6vR\" ), ... ] >>> solana_client . get_program_accounts ( \"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\" , data_size = 17 , memcmp_opts = memcmp_opts ) { 'jsonrpc' : \"2.0\" , 'result' :[{ 'account' :{ 'data' : '2R9jLfiAQ9bgdcw6h8s44439' , 'executable' : false , 'lamports' : 15298080 , 'owner' : '4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T' , 'rentEpoch' : 28 }, 'pubkey' : 'CxELquR1gPP8wHe33gZ4QxqGB3sZ9RSwsJ2KshVewkFY' }], 'id' : 1 } Source code in solana/rpc/api.py def get_program_accounts ( # pylint: disable=too-many-arguments self , pubkey : Union [ str , PublicKey ], commitment : Optional [ Commitment ] = Finalized , encoding : Optional [ str ] = None , data_slice : Optional [ types . DataSliceOpts ] = None , data_size : Optional [ int ] = None , memcmp_opts : Optional [ List [ types . MemcmpOpts ]] = None , with_context : Optional [ bool ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for the returned Transaction, either jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and ` length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. data_size: (optional) Option to compare the program account data length with the provided data size. memcmp_opts: (optional) Options to compare a provided series of bytes with program account data at a particular offset. with_context: (optional ) Option to wrap the result in an RpcResponse JSON object. min_context_slot: (optional ) set the minimum slot that the request can be evaluated at Example: >>> solana_client = Client(\"http://localhost:8899\") >>> memcmp_opts = [ ... MemcmpOpt(offset=4, bytes=\"3Mc6vR\"), ... ] >>> solana_client.get_program_accounts(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\", data_size=17, memcmp_opts=memcmp_opts) # doctest: +SKIP {'jsonrpc': \"2.0\", 'result' :[{ 'account' :{ 'data' :'2R9jLfiAQ9bgdcw6h8s44439', 'executable' :false, 'lamports' :15298080, 'owner' :'4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T', 'rentEpoch' :28}, 'pubkey' :'CxELquR1gPP8wHe33gZ4QxqGB3sZ9RSwsJ2KshVewkFY'}], 'id' :1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_program_accounts_args ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , data_size = data_size , memcmp_opts = memcmp_opts , with_context = with_context , min_context_slot = min_context_slot , ) return self . _provider . make_request ( * args ) get_recent_blockhash ( self , commitment = None ) Returns a recent block hash from the ledger. Response also includes a fee schedule that can be used to compute the cost of submitting a transaction using it. Deprecated, please use get_latest_blockhash() instead. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_recent_blockhash () { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 1637 }, 'value' : { 'blockhash' : 'EALChog1mXQ9nEgEUQpWAtmA5UueUZvZiL16ZivmR7eb' , 'feeCalculator' : { 'lamportsPerSignature' : 5000 }}}, 'id' : 2 } Source code in solana/rpc/api.py def get_recent_blockhash ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns a recent block hash from the ledger. Response also includes a fee schedule that can be used to compute the cost of submitting a transaction using it. Deprecated, please use get_latest_blockhash() instead. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_recent_blockhash() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 1637}, 'value': {'blockhash': 'EALChog1mXQ9nEgEUQpWAtmA5UueUZvZiL16ZivmR7eb', 'feeCalculator': {'lamportsPerSignature': 5000}}}, 'id': 2} \"\"\" args = self . _get_recent_blockhash_args ( commitment ) return self . _provider . make_request ( * args ) get_recent_performance_samples ( self , limit = None ) Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Parameters: Name Type Description Default limit Optional[int] - (optional) number of samples to return (maximum 720) None Examples: solana_client = Client(\"http://localhost:8899\") solana_client.get_recent_performance_samples() solana_client.get_recent_performance_samples(5) Source code in solana/rpc/api.py def get_recent_performance_samples ( self , limit : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\" Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Parameters: limit: <usize> - (optional) number of samples to return (maximum 720) Example: solana_client = Client(\"http://localhost:8899\") solana_client.get_recent_performance_samples() solana_client.get_recent_performance_samples(5) \"\"\" args = self . _get_recent_performance_samples_args ( limit ) return self . _provider . make_request ( * args ) get_signature_statuses ( self , signatures , search_transaction_history = False ) Returns the statuses of a list of signatures. Unless the search_transaction_history configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus MAX_RECENT_BLOCKHASHES rooted slots. Parameters: Name Type Description Default signatures List[Union[str, bytes]] An array of transaction signatures to confirm. required search_transaction_history bool If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. False Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> signatures = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\" , ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\" ] >>> solana_client . get_signature_statuses ( signatures ) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 82 }, 'value' : [{ 'slot' : 72 , 'confirmations' : 10 , 'err' : null , 'status' : { 'Ok' : null }}, null ]}, 'id' : 1 } Source code in solana/rpc/api.py def get_signature_statuses ( self , signatures : List [ Union [ str , bytes ]], search_transaction_history : bool = False ) -> types . RPCResponse : \"\"\"Returns the statuses of a list of signatures. Unless the `search_transaction_history` configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus `MAX_RECENT_BLOCKHASHES` rooted slots. Args: signatures: An array of transaction signatures to confirm. search_transaction_history: If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> signatures = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\", ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\"] >>> solana_client.get_signature_statuses(signatures) # doctest: +SKIP {'jsonrpc': '2.0', 'result': { 'context': {'slot':82}, 'value': [{ 'slot': 72, 'confirmations': 10, 'err': null, 'status': {'Ok': null}}, null]}, 'id': 1} \"\"\" args = self . _get_signature_statuses_args ( signatures , search_transaction_history ) return self . _provider . make_request ( * args ) get_signatures_for_address ( self , account , before = None , until = None , limit = None , commitment = None , min_context_slot = None ) Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Parameters: Name Type Description Default account Union[str, Keypair, PublicKey] Account to be queried. required before Optional[str] (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. None until Optional[str] (optional) Search until this transaction signature, if found before limit reached. None limit Optional[int] (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). None commitment Optional[Commitment] (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_signatures_for_address ( \"Vote111111111111111111111111111111111111111\" , limit = 1 ) { 'jsonrpc' : '2.0' , 'result' : [{ 'err' : None , 'memo' : None , 'signature' : 'v1BK8XcaPBzAGd7TB1K53pMdi6TBGe5CLCgx8cmZ4Bj63ZNvA6ca2QaxFpBFdvmpoFQ51VorBjifkBGLTDhwpqN' , 'slot' : 4290 }], 'id' : 2 } Source code in solana/rpc/api.py def get_signatures_for_address ( self , account : Union [ str , Keypair , PublicKey ], before : Optional [ str ] = None , until : Optional [ str ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_signatures_for_address(\"Vote111111111111111111111111111111111111111\", limit=1) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [{'err': None, 'memo': None, 'signature': 'v1BK8XcaPBzAGd7TB1K53pMdi6TBGe5CLCgx8cmZ4Bj63ZNvA6ca2QaxFpBFdvmpoFQ51VorBjifkBGLTDhwpqN', 'slot': 4290}], 'id': 2} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_signatures_for_address_args ( account , before , until , limit , commitment , min_context_slot , ) return self . _provider . make_request ( * args ) get_slot ( self , commitment = None , min_context_slot = None ) Returns the current slot the node is processing. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_slot () { 'jsonrpc' : '2.0' , 'result' : 7515 , 'id' : 1 } Source code in solana/rpc/api.py def get_slot ( self , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns the current slot the node is processing. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_slot() # doctest: +SKIP {'jsonrpc': '2.0', 'result': 7515, 'id': 1} \"\"\" args = self . _get_slot_args ( commitment , min_context_slot ) return self . _provider . make_request ( * args ) get_slot_leader ( self , commitment = None , min_context_slot = None ) Returns the current slot leader. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_slot_leader () { 'jsonrpc' : '2.0' , 'result' : 'EWj2cuEuVhi7RX81cnAY3TzpyFwnHzzVwvuTyfmxmhs3' , 'id' : 1 } Source code in solana/rpc/api.py def get_slot_leader ( self , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns the current slot leader. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_slot_leader() # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'EWj2cuEuVhi7RX81cnAY3TzpyFwnHzzVwvuTyfmxmhs3', 'id': 1} \"\"\" args = self . _get_slot_leader_args ( commitment , min_context_slot ) return self . _provider . make_request ( * args ) get_slot_leaders ( self , start_slot , limit ) Returns the slot leaders for a given slot range Examples: solana_client = Client(\"http://localhost:8899\") solana_client.get_slot_leaders(126411503, 5) Source code in solana/rpc/api.py def get_slot_leaders ( self , start_slot : int , limit : int ) -> types . RPCResponse : \"\"\" Returns the slot leaders for a given slot range Parameters: <u64> - start_slot, as u64 integer <u64> - limit, as u64 integer Example: solana_client = Client(\"http://localhost:8899\") solana_client.get_slot_leaders(126411503, 5) \"\"\" args = self . _get_slot_leaders_args ( start_slot , limit ) return self . _provider . make_request ( * args ) get_stake_activation ( self , pubkey , epoch = None , commitment = None , min_context_slot = None ) Returns epoch activation information for a stake account. Parameters: Name Type Description Default pubkey Union[PublicKey, str] Pubkey of stake account to query, as base-58 encoded string or PublicKey object. required epoch Optional[int] (optional) Epoch for which to calculate activation details. If parameter not provided, defaults to current epoch. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None min_context_slot Optional[int] set the minimum slot that the request can be evaluated at None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_stake_activation () { 'jsonrpc' : '2.0' , 'result' : { 'active' : 124429280 , 'inactive' : 73287840 , 'state' : 'activating' }, 'id' : 1 }} Source code in solana/rpc/api.py def get_stake_activation ( self , pubkey : Union [ PublicKey , str ], epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns epoch activation information for a stake account. Args: pubkey: Pubkey of stake account to query, as base-58 encoded string or PublicKey object. epoch: (optional) Epoch for which to calculate activation details. If parameter not provided, defaults to current epoch. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". min_context_slot: set the minimum slot that the request can be evaluated at Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_stake_activation() # doctest: +SKIP {'jsonrpc': '2.0','result': {'active': 124429280, 'inactive': 73287840, 'state': 'activating'}, 'id': 1}} \"\"\" args = self . _get_stake_activation_args ( pubkey , epoch , commitment , min_context_slot , ) return self . _provider . make_request ( * args ) get_supply ( self , commitment = None ) Returns information about the current supply. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_supply () { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 3846 }, 'value' : { 'circulating' : 683635192454157660 , 'nonCirculating' : 316364808037127120 , 'nonCirculatingAccounts' : [ 'ETfDYz7Cg5p9SDFmdpRerjBN5puKK7xydEBZZGM2V4Ay' , '7cKxv6UznFoWRuJkgw5bWj5rp5PiKTcXZeEaLqyd3Bbm' , 'CV7qh8ZoqeUSTQagosGpkLptXoojf9yCszxkRx1jTD12' , 'FZ9S7X9jMbCaMyJjRfSoBhFyarUMVwvx7HWRe4LnZHsg' , ... ] 'total' : 1000000000491284780 }}, 'id' : 1 } Source code in solana/rpc/api.py def get_supply ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns information about the current supply. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_supply() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 3846}, 'value': {'circulating': 683635192454157660, 'nonCirculating': 316364808037127120, 'nonCirculatingAccounts': ['ETfDYz7Cg5p9SDFmdpRerjBN5puKK7xydEBZZGM2V4Ay', '7cKxv6UznFoWRuJkgw5bWj5rp5PiKTcXZeEaLqyd3Bbm', 'CV7qh8ZoqeUSTQagosGpkLptXoojf9yCszxkRx1jTD12', 'FZ9S7X9jMbCaMyJjRfSoBhFyarUMVwvx7HWRe4LnZHsg', ...] 'total': 1000000000491284780}}, 'id': 1} \"\"\" args = self . _get_supply_args ( commitment ) return self . _provider . make_request ( * args ) get_token_account_balance ( self , pubkey , commitment = None ) Returns the token balance of an SPL Token account (UNSTABLE). Parameters: Name Type Description Default pubkey Union[str, PublicKey] Pubkey of Token account to query, as base-58 encoded string or PublicKey object. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_token_account_balance ( \"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\" ) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 1114 }, 'value' : { 'uiAmount' : 98.64 , 'amount' : '9864' , 'decimals' : 2 }, 'id' : 1 } Source code in solana/rpc/api.py def get_token_account_balance ( self , pubkey : Union [ str , PublicKey ], commitment : Optional [ Commitment ] = None ): \"\"\"Returns the token balance of an SPL Token account (UNSTABLE). Args: pubkey: Pubkey of Token account to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_token_account_balance(\"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\") # doctest: +SKIP {'jsonrpc': '2.0','result': { 'context': {'slot':1114}, 'value': { 'uiAmount': 98.64, 'amount': '9864', 'decimals': 2}, 'id' :1} \"\"\" args = self . _get_token_account_balance_args ( pubkey , commitment ) return self . _provider . make_request ( * args ) get_token_accounts_by_delegate ( self , delegate , opts = None , commitment = None ) Returns all SPL Token accounts by approved Delegate (UNSTABLE). Parameters: Name Type Description Default delegate PublicKey Public key of the delegate owner to query. required opts Optional[types.TokenAccountOpts] Token account option specifying at least one of mint or program_id . None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/api.py def get_token_accounts_by_delegate ( self , delegate : PublicKey , opts : Optional [ types . TokenAccountOpts ] = None , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" args = self . _get_token_accounts_by_delegate_args ( delegate , opts , commitment ) return self . __get_token_accounts ( * args ) get_token_accounts_by_owner ( self , owner , opts , commitment = None ) Returns all SPL Token accounts by token owner (UNSTABLE). Parameters: Name Type Description Default owner PublicKey Public key of the account owner to query. required opts types.TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/api.py def get_token_accounts_by_owner ( self , owner : PublicKey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Returns all SPL Token accounts by token owner (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" args = self . _get_token_accounts_by_owner_args ( owner , opts , commitment ) return self . __get_token_accounts ( * args ) get_token_largest_accounts ( self , pubkey , commitment = None ) Returns the 20 largest accounts of a particular SPL Token type. Source code in solana/rpc/api.py def get_token_largest_accounts ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the 20 largest accounts of a particular SPL Token type.\"\"\" args = self . _get_token_largest_account_args ( pubkey , commitment ) return self . _provider . make_request ( * args ) get_token_supply ( self , pubkey , commitment = None ) Returns the total supply of an SPL Token type. Source code in solana/rpc/api.py def get_token_supply ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the total supply of an SPL Token type.\"\"\" args = self . _get_token_supply_args ( pubkey , commitment ) return self . _provider . make_request ( * args ) get_transaction ( self , tx_sig , encoding = 'json' , commitment = None , max_support_transaction_version = None ) Returns transaction details for a confirmed transaction. Parameters: Name Type Description Default tx_sig str Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the transaction.message.instructions list. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None max_support_transaction_version Optional[int] (optional) set the max transaction version to return in responses. If the requested block contains a transaction with a higher version, an error will be returned. None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_transaction ( \"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\" ) { 'jsonrpc' : '2.0' , 'result' : { 'meta' : { 'err' : None , 'fee' : 5000 , 'rewards' : [], 'postBalances' : [ 498449233720610510 , 1000001001987940 , 1 ], 'preBalances' : [ 498449233721615510 , 1000001000987940 , 1 ], 'status' : { 'Ok' : None }}, 'slot' : 1659335 , 'transaction' : { 'message' : { 'accountKeys' : [ '9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g' , '2KW2XRd9kwqet15Aha2oK3tYvd3nWbTFH1MBiRAv1BE1' , '11111111111111111111111111111111' ], 'header' : { 'numReadonlySignedAccounts' : 0 , 'numReadonlyUnsignedAccounts' : 1 , 'numRequiredSignatures' : 1 }, 'instructions' : [{ 'accounts' : [ 0 , 1 ], 'data' : '3Bxs4Bc3VYuGVB19' , 'programIdIndex' : 2 }], 'recentBlockhash' : 'FwcsKNptGtMLccXAA9YgnivVFK95mKzECLT1DNPi3SDr' }, 'signatures' : [ '3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy' ]}}, 'id' : 4 } Source code in solana/rpc/api.py def get_transaction ( self , tx_sig : str , encoding : str = \"json\" , commitment : Optional [ Commitment ] = None , max_support_transaction_version : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". max_support_transaction_version: (optional) set the max transaction version to return in responses. If the requested block contains a transaction with a higher version, an error will be returned. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_transaction(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\") # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'meta': {'err': None, 'fee': 5000, 'rewards': [], 'postBalances': [498449233720610510, 1000001001987940, 1], 'preBalances': [498449233721615510, 1000001000987940, 1], 'status': {'Ok': None}}, 'slot': 1659335, 'transaction': {'message': {'accountKeys': ['9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g', '2KW2XRd9kwqet15Aha2oK3tYvd3nWbTFH1MBiRAv1BE1', '11111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 1, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [0, 1], 'data': '3Bxs4Bc3VYuGVB19', 'programIdIndex': 2}], 'recentBlockhash': 'FwcsKNptGtMLccXAA9YgnivVFK95mKzECLT1DNPi3SDr'}, 'signatures': ['3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy']}}, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_transaction_args ( tx_sig , encoding , commitment , max_support_transaction_version ) return self . _provider . make_request ( * args ) get_transaction_count ( self , commitment = None , min_context_slot = None ) Returns the current Transaction count from the ledger. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_transaction_count () { 'jsonrpc' : '2.0' , 'result' : 4554 , 'id' : 1 } Source code in solana/rpc/api.py def get_transaction_count ( self , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns the current Transaction count from the ledger. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_transaction_count() # doctest: +SKIP {'jsonrpc': '2.0', 'result': 4554, 'id': 1} \"\"\" args = self . _get_transaction_count_args ( commitment , min_context_slot ) return self . _provider . make_request ( * args ) get_version ( self ) Returns the current solana versions running on the node. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_version () { 'jsonrpc' : '2.0' , 'result' : { 'solana-core' : '1.4.0 5332fcad' }, 'id' : 1 } Source code in solana/rpc/api.py def get_version ( self ) -> types . RPCResponse : \"\"\"Returns the current solana versions running on the node. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_version() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'solana-core': '1.4.0 5332fcad'}, 'id': 1} \"\"\" return self . _provider . make_request ( self . _get_version ) get_vote_accounts ( self , commitment = None ) Returns the account info and associated stake for all the voting accounts in the current bank. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_vote_accounts () { 'jsonrpc' : '2.0' , 'result' : { 'current' : [{ 'activatedStake' : 0 , 'commission' : 100 , 'epochCredits' : [[ 165 , 714644 , 707372 ], [ 166 , 722092 , 714644 ], [ 167 , 730285 , 722092 ], [ 168 , 738476 , 730285 ], ... ] 'epochVoteAccount' : True , 'lastVote' : 1872294 , 'nodePubkey' : 'J7v9ndmcoBuo9to2MnHegLnBkC9x3SAVbQBJo5MMJrN1' , 'rootSlot' : 1872263 , 'votePubkey' : 'HiFjzpR7e5Kv2tdU9jtE4FbH1X8Z9Syia3Uadadx18b5' }, { 'activatedStake' : 500029968930560 , 'commission' : 100 , 'epochCredits' : [[ 165 , 1359689 , 1351498 ], [ 166 , 1367881 , 1359689 ], [ 167 , 1376073 , 1367881 ], [ 168 , 1384265 , 1376073 ], ... ], 'epochVoteAccount' : True , 'lastVote' : 1872295 , 'nodePubkey' : 'dv1LfzJvDF7S1fBKpFgKoKXK5yoSosmkAdfbxBo1GqJ' , 'rootSlot' : 1872264 , 'votePubkey' : '5MMCR4NbTZqjthjLGywmeT66iwE9J9f7kjtxzJjwfUx2' }, { 'activatedStake' : 0 , 'commission' : 100 , 'epochCredits' : [[ 227 , 2751 , 0 ], [ 228 , 7188 , 2751 ]], 'epochVoteAccount' : True , 'lastVote' : 1872295 , 'nodePubkey' : 'H1wDvJ5HJc1SzhHoWtaycpzQpFbsL7g8peaRV3obKShs' , 'rootSlot' : 1872264 , 'votePubkey' : 'DPqpgoLQVU3aq72HEqSMsB9qh4KoXc9fGEpvgEuiwnp6' }], 'delinquent' : []}, 'id' : 1 } Source code in solana/rpc/api.py def get_vote_accounts ( self , commitment : Optional [ Commitment ] = None ): \"\"\"Returns the account info and associated stake for all the voting accounts in the current bank. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_vote_accounts() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'current': [{'activatedStake': 0, 'commission': 100, 'epochCredits': [[165, 714644, 707372], [166, 722092, 714644], [167, 730285, 722092], [168, 738476, 730285], ...] 'epochVoteAccount': True, 'lastVote': 1872294, 'nodePubkey': 'J7v9ndmcoBuo9to2MnHegLnBkC9x3SAVbQBJo5MMJrN1', 'rootSlot': 1872263, 'votePubkey': 'HiFjzpR7e5Kv2tdU9jtE4FbH1X8Z9Syia3Uadadx18b5'}, {'activatedStake': 500029968930560, 'commission': 100, 'epochCredits': [[165, 1359689, 1351498], [166, 1367881, 1359689], [167, 1376073, 1367881], [168, 1384265, 1376073], ...], 'epochVoteAccount': True, 'lastVote': 1872295, 'nodePubkey': 'dv1LfzJvDF7S1fBKpFgKoKXK5yoSosmkAdfbxBo1GqJ', 'rootSlot': 1872264, 'votePubkey': '5MMCR4NbTZqjthjLGywmeT66iwE9J9f7kjtxzJjwfUx2'}, {'activatedStake': 0, 'commission': 100, 'epochCredits': [[227, 2751, 0], [228, 7188, 2751]], 'epochVoteAccount': True, 'lastVote': 1872295, 'nodePubkey': 'H1wDvJ5HJc1SzhHoWtaycpzQpFbsL7g8peaRV3obKShs', 'rootSlot': 1872264, 'votePubkey': 'DPqpgoLQVU3aq72HEqSMsB9qh4KoXc9fGEpvgEuiwnp6'}], 'delinquent': []}, 'id': 1} \"\"\" args = self . _get_vote_accounts_args ( commitment ) return self . _provider . make_request ( * args ) is_blockhash_valid ( self , blockhash , commitment = None , min_context_slot = None ) Returns whether a blockhash is still valid or not NEW: This method is only available in solana-core v1.9 or newer. Please use getRecentBlockhash for solana-core v1.8 Parameters: Name Type Description Default blockhash str the blockhash of this block, as base-58 encoded string required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None min_context_slot Optional[int] set the minimum slot that the request can be evaluated at None Examples: solana_client = Client(\"http://localhost:8899\") solana_client.is_blockhash_valid( 'J7rBdM6AecPDEZp8aPq5iPSNKVkU5Q76F3oAV4eW5wsW' ) Source code in solana/rpc/api.py def is_blockhash_valid ( self , blockhash : str , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns whether a blockhash is still valid or not NEW: This method is only available in solana-core v1.9 or newer. Please use getRecentBlockhash for solana-core v1.8 Args: blockhash: the blockhash of this block, as base-58 encoded string commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". min_context_slot: set the minimum slot that the request can be evaluated at Example: solana_client = Client(\"http://localhost:8899\") solana_client.is_blockhash_valid( 'J7rBdM6AecPDEZp8aPq5iPSNKVkU5Q76F3oAV4eW5wsW' ) \"\"\" args = self . _get_is_blockhash_valid_args ( blockhash , commitment , min_context_slot , ) return self . _provider . make_request ( * args ) is_connected ( self ) Health check. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . is_connected () True Returns: Type Description bool True if the client is connected. Source code in solana/rpc/api.py def is_connected ( self ) -> bool : \"\"\"Health check. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.is_connected() # doctest: +SKIP True Returns: True if the client is connected. \"\"\" return self . _provider . is_connected () request_airdrop ( self , pubkey , lamports , commitment = None ) Requests an airdrop of lamports to a Pubkey. Parameters: Name Type Description Default pubkey Union[PublicKey, str] Pubkey of account to receive lamports, as base-58 encoded string or public key object. required lamports int Amout of lamports. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solana.publickey import PublicKey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . request_airdrop ( PublicKey ( 1 ), 10000 ) { 'jsonrpc' : '2.0' , 'result' : 'uK6gbLbhnTEgjgmwn36D5BRTRkG4AT8r7Q162TLnJzQnHUZVL9r6BYZVfRttrhmkmno6Fp4VQELzL4AiriCo61U' , 'id' : 1 } Source code in solana/rpc/api.py def request_airdrop ( self , pubkey : Union [ PublicKey , str ], lamports : int , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Requests an airdrop of lamports to a Pubkey. Args: pubkey: Pubkey of account to receive lamports, as base-58 encoded string or public key object. lamports: Amout of lamports. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solana.publickey import PublicKey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.request_airdrop(PublicKey(1), 10000) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'uK6gbLbhnTEgjgmwn36D5BRTRkG4AT8r7Q162TLnJzQnHUZVL9r6BYZVfRttrhmkmno6Fp4VQELzL4AiriCo61U', 'id': 1} \"\"\" args = self . _request_airdrop_args ( pubkey , lamports , commitment ) return self . _provider . make_request ( * args ) send_raw_transaction ( self , txn , opts = None ) Send a transaction that has already been signed and serialized into the wire format. Parameters: Name Type Description Default txn Union[bytes, str] Fully-signed Transaction object, a fully sign transaction in wire format, or a fully transaction as base-64 encoded string. required opts Optional[types.TxOpts] (optional) Transaction options. None Before submitting, the following preflight checks are performed (unless disabled with the skip_preflight option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> full_signed_tx_str = ( ... \"AbN5XM+qw+7oOLsFw7goQSLBis7c1kXJFP6OF4w7YmQNhhbQYcyBiybKuOzzhV7McvoRP3Mey9AhXojtwDCdbwoBAAEDE5j2\" ... \"LG0aRXxRumpLXz29L2n8qTIWIY3ImX5Ba9F9k8poq0Z3/7HyiU3QphU8Ix1F7ENq5TrmAUnb4V8y5LhwPwAAAAAAAAAAAAAA\" ... \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAg5YY9wG6fpuieuWYJd1ta7ZtFPbV0OriFRYdcYUaEGkBAgIAAQwCAAAAQEIPAAAAAAA=\" ) >>> solana_client . send_raw_transaction ( full_signed_tx_str ) { 'jsonrpc' : '2.0' , 'result' : 'CMwyESM2NE74mghfbvsHJDERF7xMYKshwwm6VgH6GFqXzx8LfBFuP5ruccumfhTguha6seUHPpiHzzHUQXzq2kN' , 'id' : 1 } Source code in solana/rpc/api.py def send_raw_transaction ( self , txn : Union [ bytes , str ], opts : Optional [ types . TxOpts ] = None , ) -> types . RPCResponse : \"\"\"Send a transaction that has already been signed and serialized into the wire format. Args: txn: Fully-signed Transaction object, a fully sign transaction in wire format, or a fully transaction as base-64 encoded string. opts: (optional) Transaction options. Before submitting, the following preflight checks are performed (unless disabled with the `skip_preflight` option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> full_signed_tx_str = ( ... \"AbN5XM+qw+7oOLsFw7goQSLBis7c1kXJFP6OF4w7YmQNhhbQYcyBiybKuOzzhV7McvoRP3Mey9AhXojtwDCdbwoBAAEDE5j2\" ... \"LG0aRXxRumpLXz29L2n8qTIWIY3ImX5Ba9F9k8poq0Z3/7HyiU3QphU8Ix1F7ENq5TrmAUnb4V8y5LhwPwAAAAAAAAAAAAAA\" ... \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAg5YY9wG6fpuieuWYJd1ta7ZtFPbV0OriFRYdcYUaEGkBAgIAAQwCAAAAQEIPAAAAAAA=\") >>> solana_client.send_raw_transaction(full_signed_tx_str) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'CMwyESM2NE74mghfbvsHJDERF7xMYKshwwm6VgH6GFqXzx8LfBFuP5ruccumfhTguha6seUHPpiHzzHUQXzq2kN', 'id': 1} \"\"\" # noqa: E501 # pylint: disable=line-too-long opts_to_use = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts args = self . _send_raw_transaction_args ( txn , opts_to_use ) resp = self . _provider . make_request ( * args ) if opts_to_use . skip_confirmation : return self . _post_send ( resp ) post_send_args = self . _send_raw_transaction_post_send_args ( resp , opts_to_use ) return self . __post_send_with_confirm ( * post_send_args ) send_transaction ( self , txn , * signers , * , opts = None , recent_blockhash = None ) Send a transaction. Parameters: Name Type Description Default txn Transaction Transaction object. required signers Keypair Signers to sign the transaction. () opts Optional[types.TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) Pass a valid recent blockhash here if you want to skip fetching the recent blockhash or relying on the cache. None Examples: >>> from solana.keypair import Keypair >>> from solana.publickey import PublicKey >>> from solana.rpc.api import Client >>> from solana.system_program import TransferParams , transfer >>> from solana.transaction import Transaction >>> sender , receiver = Keypair . from_seed ( bytes ( PublicKey ( 1 ))), Keypair . from_seed ( bytes ( PublicKey ( 2 ))) >>> txn = Transaction () . add ( transfer ( TransferParams ( ... from_pubkey = sender . public_key , to_pubkey = receiver . public_key , lamports = 1000 ))) >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . send_transaction ( txn , sender ) { 'jsonrpc' : '2.0' , 'result' : '236zSA5w4NaVuLXXHK1mqiBuBxkNBu84X6cfLBh1v6zjPrLfyECz4zdedofBaZFhs4gdwzSmij9VkaSo2tR5LTgG' , 'id' : 12 } Source code in solana/rpc/api.py def send_transaction ( self , txn : Transaction , * signers : Keypair , opts : Optional [ types . TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> types . RPCResponse : \"\"\"Send a transaction. Args: txn: Transaction object. signers: Signers to sign the transaction. opts: (optional) Transaction options. recent_blockhash: (optional) Pass a valid recent blockhash here if you want to skip fetching the recent blockhash or relying on the cache. Example: >>> from solana.keypair import Keypair >>> from solana.publickey import PublicKey >>> from solana.rpc.api import Client >>> from solana.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> sender, receiver = Keypair.from_seed(bytes(PublicKey(1))), Keypair.from_seed(bytes(PublicKey(2))) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.public_key, to_pubkey=receiver.public_key, lamports=1000))) >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.send_transaction(txn, sender) # doctest: +SKIP {'jsonrpc': '2.0', 'result': '236zSA5w4NaVuLXXHK1mqiBuBxkNBu84X6cfLBh1v6zjPrLfyECz4zdedofBaZFhs4gdwzSmij9VkaSo2tR5LTgG', 'id': 12} \"\"\" last_valid_block_height = None if recent_blockhash is None : if self . blockhash_cache : try : recent_blockhash = self . blockhash_cache . get () except ValueError : blockhash_resp = self . get_latest_blockhash ( Finalized ) recent_blockhash = self . _process_blockhash_resp ( blockhash_resp , used_immediately = True ) last_valid_block_height = blockhash_resp [ \"result\" ][ \"value\" ][ \"lastValidBlockHeight\" ] else : blockhash_resp = self . get_latest_blockhash ( Finalized ) recent_blockhash = self . parse_recent_blockhash ( blockhash_resp ) last_valid_block_height = blockhash_resp [ \"result\" ][ \"value\" ][ \"lastValidBlockHeight\" ] txn . recent_blockhash = recent_blockhash txn . sign ( * signers ) opts_to_use = ( types . TxOpts ( preflight_commitment = self . _commitment , last_valid_block_height = last_valid_block_height ) if opts is None else opts ) txn_resp = self . send_raw_transaction ( txn . serialize (), opts = opts_to_use ) if self . blockhash_cache : blockhash_resp = self . get_recent_blockhash ( Finalized ) self . _process_blockhash_resp ( blockhash_resp , used_immediately = False ) return txn_resp set_log_filter ( self , log_filter ) Sets the log filter on the validator. Parameters: Name Type Description Default log_filter str The new log filter to use. required Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . set_log_filter ( \"solana_core=debug\" ) { 'jsonrpc' : '2.0' , 'result' : None , 'id' : 1 } Source code in solana/rpc/api.py def set_log_filter ( self , log_filter : str ) -> types . RPCResponse : \"\"\"Sets the log filter on the validator. Args: log_filter: The new log filter to use. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.set_log_filter(\"solana_core=debug\") # doctest: +SKIP {'jsonrpc': '2.0', 'result': None, 'id': 1} \"\"\" args = self . _set_log_filter_args ( log_filter ) return self . _provider . make_request ( * args ) simulate_transaction ( self , txn , sig_verify = False , commitment = None , min_context_slot = None ) Simulate sending a transaction. Parameters: Name Type Description Default txn Union[bytes, str, Transaction] A Transaction object, a transaction in wire format, or a transaction as base-64 encoded string The transaction must have a valid blockhash, but is not required to be signed. required sig_verify bool If true the transaction signatures will be verified (default: false). False commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> tx_str = ( ... \"4hXTCkRzt9WyecNzV1XPgCDfGAZzQKNxLXgynz5QDuWWPSAZBZSHptvWRL3BjCvzUXRdKvHL2b7yGrRQcWyaqsaBCncVG7BF\" ... \"ggS8w9snUts67BSh3EqKpXLUm5UMHfD7ZBe9GhARjbNQMLJ1QD3Spr6oMTBU6EhdB4RD8CP2xUxr2u3d6fos36PD98XS6oX8\" ... \"TQjLpsMwncs5DAMiD4nNnR8NBfyghGCWvCVifVwvA8B8TJxE1aiyiv2L429BCWfyzAme5sZW8rDb14NeCQHhZbtNqfXhcp2t\" ... ) >>> solana_client . simulate_transaction ( tx_str ) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 218 }, 'value' : { 'err' : null , 'logs' : [ 'BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success' ]}, 'id' : 1 } Source code in solana/rpc/api.py def simulate_transaction ( self , txn : Union [ bytes , str , Transaction ], sig_verify : bool = False , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Simulate sending a transaction. Args: txn: A Transaction object, a transaction in wire format, or a transaction as base-64 encoded string The transaction must have a valid blockhash, but is not required to be signed. sig_verify: If true the transaction signatures will be verified (default: false). commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> tx_str = ( ... \"4hXTCkRzt9WyecNzV1XPgCDfGAZzQKNxLXgynz5QDuWWPSAZBZSHptvWRL3BjCvzUXRdKvHL2b7yGrRQcWyaqsaBCncVG7BF\" ... \"ggS8w9snUts67BSh3EqKpXLUm5UMHfD7ZBe9GhARjbNQMLJ1QD3Spr6oMTBU6EhdB4RD8CP2xUxr2u3d6fos36PD98XS6oX8\" ... \"TQjLpsMwncs5DAMiD4nNnR8NBfyghGCWvCVifVwvA8B8TJxE1aiyiv2L429BCWfyzAme5sZW8rDb14NeCQHhZbtNqfXhcp2t\" ... ) >>> solana_client.simulate_transaction(tx_str) # doctest: +SKIP {'jsonrpc' :'2.0', 'result': {'context': {'slot': 218}, 'value': { 'err': null, 'logs': ['BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success']}, 'id':1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _simulate_transaction_args ( txn , sig_verify , commitment , min_context_slot , ) return self . _provider . make_request ( * args ) validator_exit ( self ) Request to have the validator exit. Validator must have booted with RPC exit enabled ( --enable-rpc-exit parameter). Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . validator_exit () { 'jsonrpc' : '2.0' , 'result' : true , 'id' : 1 } Source code in solana/rpc/api.py def validator_exit ( self ) -> types . RPCResponse : \"\"\"Request to have the validator exit. Validator must have booted with RPC exit enabled (`--enable-rpc-exit` parameter). Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.validator_exit() # doctest: +SKIP {'jsonrpc': '2.0', 'result': true, 'id': 1} \"\"\" return self . _provider . make_request ( self . _validator_exit ) DataSliceOpt ( * args , ** kwargs ) Option to limit the returned account data, only available for \"base58\" or \"base64\" encoding. Source code in solana/rpc/api.py def DataSliceOpt ( * args , ** kwargs ) -> types . DataSliceOpts : # pylint: disable=invalid-name \"\"\"Option to limit the returned account data, only available for \"base58\" or \"base64\" encoding.\"\"\" warn ( \"solana.rpc.api.DataSliceOpt is deprecated, please use solana.rpc.types.DataSliceOpts\" , category = DeprecationWarning , ) return types . DataSliceOpts ( * args , ** kwargs ) MemcmpOpt ( * args , ** kwargs ) Option to compare a provided series of bytes with program account data at a particular offset. Source code in solana/rpc/api.py def MemcmpOpt ( * args , ** kwargs ) -> types . MemcmpOpts : # pylint: disable=invalid-name \"\"\"Option to compare a provided series of bytes with program account data at a particular offset.\"\"\" warn ( \"solana.rpc.api.MemcmpOpt is deprecated, please use solana.rpc.types.MemcmpOpts\" , category = DeprecationWarning ) return types . MemcmpOpts ( * args , ** kwargs )","title":"API Client"},{"location":"rpc/api/#api-client","text":"","title":"API Client"},{"location":"rpc/api/#solana.rpc.api","text":"API client to interact with the Solana JSON RPC Endpoint.","title":"api"},{"location":"rpc/api/#solana.rpc.api.Client","text":"Client class. Parameters: Name Type Description Default endpoint Optional[str] URL of the RPC endpoint. None commitment Optional[Commitment] Default bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None blockhash_cache Union[BlockhashCache, bool] (Experimental) If True, keep a cache of recent blockhashes to make send_transaction calls faster. You can also pass your own BlockhashCache object to customize its parameters. The cache works as follows: Retrieve the oldest unused cached blockhash that is younger than ttl seconds, where ttl is defined in the BlockhashCache (we prefer unused blockhashes because reusing blockhashes can cause errors in some edge cases, and we prefer slightly older blockhashes because they're more likely to be accepted by every validator). If there are no unused blockhashes in the cache, take the oldest used blockhash that is younger than ttl seconds. Fetch a new recent blockhash after sending the transaction. This is to keep the cache up-to-date. If you want something tailored to your use case, run your own loop that fetches the recent blockhash, and pass that value in your .send_transaction calls. False timeout float HTTP request timeout in seconds. 10 Source code in solana/rpc/api.py class Client ( _ClientCore ): # pylint: disable=too-many-public-methods \"\"\"Client class. Args: endpoint: URL of the RPC endpoint. commitment: Default bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". blockhash_cache: (Experimental) If True, keep a cache of recent blockhashes to make `send_transaction` calls faster. You can also pass your own BlockhashCache object to customize its parameters. The cache works as follows: 1. Retrieve the oldest unused cached blockhash that is younger than `ttl` seconds, where `ttl` is defined in the BlockhashCache (we prefer unused blockhashes because reusing blockhashes can cause errors in some edge cases, and we prefer slightly older blockhashes because they're more likely to be accepted by every validator). 2. If there are no unused blockhashes in the cache, take the oldest used blockhash that is younger than `ttl` seconds. 3. Fetch a new recent blockhash *after* sending the transaction. This is to keep the cache up-to-date. If you want something tailored to your use case, run your own loop that fetches the recent blockhash, and pass that value in your `.send_transaction` calls. timeout: HTTP request timeout in seconds. \"\"\" def __init__ ( self , endpoint : Optional [ str ] = None , commitment : Optional [ Commitment ] = None , blockhash_cache : Union [ BlockhashCache , bool ] = False , timeout : float = 10 , ): \"\"\"Init API client.\"\"\" super () . __init__ ( commitment , blockhash_cache ) self . _provider = http . HTTPProvider ( endpoint , timeout = timeout ) @property def request ( self ): if getattr ( self , '_provider' ): request_raw = self . _provider . content return self . _provider . json_decode ( request_raw ) return None @property def response_headers ( self ): return self . _provider . response_headers if getattr ( self , '_provider' ) else None def is_connected ( self ) -> bool : \"\"\"Health check. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.is_connected() # doctest: +SKIP True Returns: True if the client is connected. \"\"\" return self . _provider . is_connected () def get_balance ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns the balance of the account of provided Pubkey. Args: pubkey: Pubkey of account to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". min_context_slot: set the minimum slot that the request can be evaluated at Example: >>> from solana.publickey import PublicKey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_balance(PublicKey(1)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 228}, 'value': 0}, 'id': 1} \"\"\" args = self . _get_balance_args ( pubkey , commitment , min_context_slot ) return self . _provider . make_request ( * args ) def get_account_info ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns all the account info for the specified public key. Args: pubkey: Pubkey of account to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. - \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. min_context_slot: set the minimum slot that the request can be evaluated at Example: >>> from solana.publickey import PublicKey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_account_info(PublicKey(1)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 33265073}, 'value': {'data': '', 'executable': False, 'lamports': 4459816188034584, 'owner': '11111111111111111111111111111111', 'rentEpoch': 90}}, 'id': 1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_account_info_args ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , min_context_slot = min_context_slot , ) return self . _provider . make_request ( * args ) def get_block_commitment ( self , slot : int ) -> types . RPCResponse : \"\"\"Fetch the commitment for particular block. Args: slot: Block, identified by Slot. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_commitment(0) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'commitment': [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 497717120], 'totalStake': 497717120}, 'id': 1}} \"\"\" args = self . _get_block_commitment_args ( slot ) return self . _provider . make_request ( * args ) def get_block_time ( self , slot : int ) -> types . RPCResponse : \"\"\"Fetch the estimated production time of a block. Args: slot: Block, identified by Slot. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_time(5) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1598400007, 'id': 1} \"\"\" args = self . _get_block_time_args ( slot ) return self . _provider . make_request ( * args ) def get_cluster_nodes ( self ) -> types . RPCResponse : \"\"\"Returns information about all the nodes participating in the cluster. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_cluster_nodes() # doctest: +SKIP {'jsonrpc': '2.0', 'result': [{'gossip': '127.0.0.1:8001', 'pubkey': 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk', 'rpc': '127.0.0.1:8899', 'tpu': '127.0.0.1:8003', 'version': '1.4.0 5332fcad'}], 'id': 1} \"\"\" return self . _provider . make_request ( self . _get_cluster_nodes ) def get_confirmed_block ( self , slot : int , encoding : str = \"json\" , max_support_transaction_version = None , ) -> types . RPCResponse : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_confirmed_block(1) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': {'message': {'accountKeys': ['LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk', 'EKAar3bMQUZvGSonq7vcPF2nPaCYowbnat44FPafW8Po', 'SysvarS1otHashes111111111111111111111111111', 'SysvarC1ock11111111111111111111111111111111', 'Vote111111111111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 3, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [1, 2, 3, 0], 'data': '37u9WtQpcm6ULa3VmTgTKEBCtYMxq84mk82tRvKdFEwj3rALiptAzuMJ1yoVSFAMARMZYp7q', 'programIdIndex': 4}], 'recentBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2'}, 'signatures': ['63jnpMCs7TNnCjnTqUrX7Mvqc5CbJMtVkLxBjPHUQkjXyZrQuZpfhjvzA7A29D9tMqVaiQC3UNP1NeaZKFFHJyQE']}}]}, 'id': 9} >>> solana_client.get_confirmed_block(1, encoding=\"base64\") # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': ['AfxyKHmHIjXWjkyHODGeAbVxmfQWPj1ydS9nF+ynJHo8I1vCPDp2P9Cj5aA6W1CAHEHCqY0B1FDKomCzRo3qrAsBAAMFBQ6QBWfhQF7rG02xhuEsmmrUtz3AUjBtJKkqaHPJEmvFzziDX0C0robPrl9RbOyXHoc9/Dxa0zoGL6cEjvCjLgan1RcZLwqvxvJl4/t3zHragsUp0L47E24tAFUgAAAABqfVFxjHdMkoVmOYaR1etoteuKObS21cc1VbIQAAAAAHYUgdNXR0u3xNdiTr072z2DVec9EQQ/wNo1OAAAAAAM8NSv7ISDPN9E9XNL9vX7h8LuJHWlopUcX39DxsDx23AQQEAQIDADUCAAAAAQAAAAAAAAAAAAAAAAAAAIWWp5Il3Kg312pzVk6Jt61iyFhTbtmkh/ORbj3JUQRbAA==', 'base64']}]}, 'id': 10} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_confirmed_block_args ( slot , encoding , max_support_transaction_version , ) return self . _provider . make_request ( * args ) def get_recent_performance_samples ( self , limit : Optional [ int ] = None ) -> types . RPCResponse : \"\"\"Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Args: limit: Limit (optional) number of samples to return (maximum 720) Examples: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_recent_performance_samples(4) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [ { 'numSlots': 126, 'numTransactions': 126, 'samplePeriodSecs': 60, 'slot': 348125 }, { 'numSlots': 126, 'numTransactions': 126, 'samplePeriodSecs': 60, 'slot': 347999 }, { 'numSlots': 125, 'numTransactions': 125, 'samplePeriodSecs': 60, 'slot': 347873 }, { 'numSlots': 125, 'numTransactions': 125, 'samplePeriodSecs': 60, 'slot': 347748 } ], 'id': 1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_recent_performance_samples_args ( limit ) return self . _provider . make_request ( * args ) def get_block ( self , slot : int , encoding : str = \"json\" , commitment : Optional [ Commitment ] = None , rewards : Optional [ bool ] = None , transaction_details : Optional [ str ] = None , max_support_transaction_version : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. commitment:(optional) It can be either \"finalized\", \"confirmed\". \"processed\" is not supported. If parameter not provided, the default is \"finalized\". rewards: (optional) whether to populate the rewards array. If parameter not provided, the default includes rewards. transaction_details: (optional) level of transaction detail to return, either \"full\", \"accounts\", \"signatures\", or \"none\". If parameter not provided, the default detail level is \"full\". max_support_transaction_version: (optional) set the max transaction version to return in responses. If the requested block contains a transaction with a higher version, an error will be returned. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block(1) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockHeight': 0, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': {'message': {'accountKeys': ['LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk', 'EKAar3bMQUZvGSonq7vcPF2nPaCYowbnat44FPafW8Po', 'SysvarS1otHashes111111111111111111111111111', 'SysvarC1ock11111111111111111111111111111111', 'Vote111111111111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 3, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [1, 2, 3, 0], 'data': '37u9WtQpcm6ULa3VmTgTKEBCtYMxq84mk82tRvKdFEwj3rALiptAzuMJ1yoVSFAMARMZYp7q', 'programIdIndex': 4}], 'recentBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2'}, 'signatures': ['63jnpMCs7TNnCjnTqUrX7Mvqc5CbJMtVkLxBjPHUQkjXyZrQuZpfhjvzA7A29D9tMqVaiQC3UNP1NeaZKFFHJyQE']}}]}, 'id': 9} >>> solana_client.get_block(1, encoding=\"base64\") # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockHeight': 0, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': ['AfxyKHmHIjXWjkyHODGeAbVxmfQWPj1ydS9nF+ynJHo8I1vCPDp2P9Cj5aA6W1CAHEHCqY0B1FDKomCzRo3qrAsBAAMFBQ6QBWfhQF7rG02xhuEsmmrUtz3AUjBtJKkqaHPJEmvFzziDX0C0robPrl9RbOyXHoc9/Dxa0zoGL6cEjvCjLgan1RcZLwqvxvJl4/t3zHragsUp0L47E24tAFUgAAAABqfVFxjHdMkoVmOYaR1etoteuKObS21cc1VbIQAAAAAHYUgdNXR0u3xNdiTr072z2DVec9EQQ/wNo1OAAAAAAM8NSv7ISDPN9E9XNL9vX7h8LuJHWlopUcX39DxsDx23AQQEAQIDADUCAAAAAQAAAAAAAAAAAAAAAAAAAIWWp5Il3Kg312pzVk6Jt61iyFhTbtmkh/ORbj3JUQRbAA==', 'base64']}]}, 'id': 10} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_block_args ( slot , encoding , commitment , rewards , transaction_details , max_support_transaction_version , ) return self . _provider . make_request ( * args ) def get_block_height ( self , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns the current block height of the node. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_height() # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1233, 'id': 1} \"\"\" args = self . _get_block_height_args ( commitment , min_context_slot ) return self . _provider . make_request ( * args ) def get_confirmed_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> types . RPCResponse : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_confirmed_blocks(5, 10) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [5, 6, 7, 8, 9, 10], 'id': 1} \"\"\" args = self . _get_confirmed_blocks_args ( start_slot , end_slot ) return self . _provider . make_request ( * args ) def get_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> types . RPCResponse : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_blocks(5, 10) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [5, 6, 7, 8, 9, 10], 'id': 1} \"\"\" args = self . _get_blocks_args ( start_slot , end_slot ) return self . _provider . make_request ( * args ) def get_confirmed_signature_for_address2 ( self , account : Union [ str , Keypair , PublicKey ], before : Optional [ str ] = None , until : Optional [ str ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optoinal) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_confirmed_signature_for_address2(\"Vote111111111111111111111111111111111111111\", limit=1) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [{'err': None, 'memo': None, 'signature': 'v1BK8XcaPBzAGd7TB1K53pMdi6TBGe5CLCgx8cmZ4Bj63ZNvA6ca2QaxFpBFdvmpoFQ51VorBjifkBGLTDhwpqN', 'slot': 4290}], 'id': 2} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_confirmed_signature_for_address2_args ( account , before , until , limit , commitment ) return self . _provider . make_request ( * args ) def get_signatures_for_address ( self , account : Union [ str , Keypair , PublicKey ], before : Optional [ str ] = None , until : Optional [ str ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_signatures_for_address(\"Vote111111111111111111111111111111111111111\", limit=1) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [{'err': None, 'memo': None, 'signature': 'v1BK8XcaPBzAGd7TB1K53pMdi6TBGe5CLCgx8cmZ4Bj63ZNvA6ca2QaxFpBFdvmpoFQ51VorBjifkBGLTDhwpqN', 'slot': 4290}], 'id': 2} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_signatures_for_address_args ( account , before , until , limit , commitment , min_context_slot , ) return self . _provider . make_request ( * args ) def get_confirmed_transaction ( self , tx_sig : str , encoding : str = \"json\" ) -> types . RPCResponse : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_confirmed_transaction(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\") # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'meta': {'err': None, 'fee': 5000, 'postBalances': [498449233720610510, 1000001001987940, 1], 'preBalances': [498449233721615510, 1000001000987940, 1], 'status': {'Ok': None}}, 'slot': 1659335, 'transaction': {'message': {'accountKeys': ['9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g', '2KW2XRd9kwqet15Aha2oK3tYvd3nWbTFH1MBiRAv1BE1', '11111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 1, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [0, 1], 'data': '3Bxs4Bc3VYuGVB19', 'programIdIndex': 2}], 'recentBlockhash': 'FwcsKNptGtMLccXAA9YgnivVFK95mKzECLT1DNPi3SDr'}, 'signatures': ['3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy']}}, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_confirmed_transaction_args ( tx_sig , encoding ) return self . _provider . make_request ( * args ) def get_transaction ( self , tx_sig : str , encoding : str = \"json\" , commitment : Optional [ Commitment ] = None , max_support_transaction_version : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". max_support_transaction_version: (optional) set the max transaction version to return in responses. If the requested block contains a transaction with a higher version, an error will be returned. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_transaction(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\") # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'meta': {'err': None, 'fee': 5000, 'rewards': [], 'postBalances': [498449233720610510, 1000001001987940, 1], 'preBalances': [498449233721615510, 1000001000987940, 1], 'status': {'Ok': None}}, 'slot': 1659335, 'transaction': {'message': {'accountKeys': ['9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g', '2KW2XRd9kwqet15Aha2oK3tYvd3nWbTFH1MBiRAv1BE1', '11111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 1, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [0, 1], 'data': '3Bxs4Bc3VYuGVB19', 'programIdIndex': 2}], 'recentBlockhash': 'FwcsKNptGtMLccXAA9YgnivVFK95mKzECLT1DNPi3SDr'}, 'signatures': ['3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy']}}, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_transaction_args ( tx_sig , encoding , commitment , max_support_transaction_version ) return self . _provider . make_request ( * args ) def get_epoch_info ( self , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns information about the current epoch. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_epoch_info() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'absoluteSlot': 5150, 'blockHeight': 5150, 'epoch': 0, 'slotIndex': 5150, 'slotsInEpoch': 8192}, 'id': 5} \"\"\" args = self . _get_epoch_info_args ( commitment , min_context_slot ) return self . _provider . make_request ( * args ) def get_epoch_schedule ( self ) -> types . RPCResponse : \"\"\"Returns epoch schedule information from this cluster's genesis config. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_epoch_schedule() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'firstNormalEpoch': 0, 'firstNormalSlot': 0, 'leaderScheduleSlotOffset': 8192, 'slotsPerEpoch': 8192, 'warmup': False}, 'id': 6} \"\"\" return self . _provider . make_request ( self . _get_epoch_schedule ) def get_fee_calculator_for_blockhash ( self , blockhash : Union [ str , Blockhash ], commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the fee calculator associated with the query blockhash, or null if the blockhash has expired. Args: blockhash: Blockhash to query as a Base58 encoded string. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_fee_calculator_for_blockhash(\"BaQSR194dC4dZaRxATtxYyEwDkk7VgqUY8NVNkub8HFZ\") # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 7065}, 'value': {'feeCalculator': {'lamportsPerSignature': 5000}}}, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_fee_calculator_for_blockhash_args ( blockhash , commitment ) return self . _provider . make_request ( * args ) def get_fee_for_message ( self , message : Message , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the fee for a message. Args: message: Message that the fee is requested for. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solana.keypair import Keypair >>> from solana.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> sender, receiver = Keypair.from_seed(bytes(PublicKey(1))), Keypair.from_seed(bytes(PublicKey(2))) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.public_key, to_pubkey=receiver.public_key, lamports=1000))) >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_fee_for_message(txn.compile_message()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': { 'context': { 'slot': 5068 }, 'value': 5000 }, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long if isinstance ( message , Transaction ): raise TransactionUncompiledError ( \"Transaction uncompiled, please compile to message first.\" ) args = self . _get_fee_for_message_args ( message , commitment ) return self . _provider . make_request ( * args ) def get_fee_rate_governor ( self ) -> types . RPCResponse : \"\"\"Returns the fee rate governor information from the root bank. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_fee_rate_governor() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 7172}, 'value': {'feeRateGovernor': {'burnPercent': 50, 'maxLamportsPerSignature': 100000, 'minLamportsPerSignature': 5000, 'targetLamportsPerSignature': 10000, 'targetSignaturesPerSlot': 20000}}}, 'id': 5} \"\"\" return self . _provider . make_request ( self . _get_fee_rate_governor ) def get_fees ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns a recent block hash from the ledger, a fee schedule and the last slot the blockhash will be valid. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_fees() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 7727}, 'value': {'blockhash': 'GGS6AEDqjF5irU6D6VQNherEZ2hckGaeBiVdfSZKg4gd', 'feeCalculator': {'lamportsPerSignature': 5000}, 'lastValidSlot': 8027}}, 'id': 1} \"\"\" args = self . _get_fees_args ( commitment ) return self . _provider . make_request ( * args ) def get_first_available_block ( self ) -> types . RPCResponse : \"\"\"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_fees() # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1, 'id': 2} \"\"\" return self . _provider . make_request ( self . _get_first_available_block ) def get_genesis_hash ( self ) -> types . RPCResponse : \"\"\"Returns the genesis hash. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_genesis_hash() # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'id': 3} \"\"\" return self . _provider . make_request ( self . _get_genesis_hash ) def get_health ( self ) -> types . RPCResponse : \"\"\"Returns the current health of the node. >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_health() # doctest: +SKIP Healthy result: {\"jsonrpc\":\"2.0\", \"result\": \"ok\", \"id\":1} \"\"\" return self . _provider . make_request ( self . _get_health ) def get_identity ( self ) -> types . RPCResponse : \"\"\"Returns the identity pubkey for the current node. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_identity() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'identity': 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk'}, 'id': 4} \"\"\" return self . _provider . make_request ( self . _get_identity ) def get_inflation_governor ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the current inflation governor. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_governor() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'foundation': 0.05, 'foundationTerm': 7.0, 'initial': 0.15, 'taper': 0.15, 'terminal': 0.015}, 'id': 5} \"\"\" args = self . _get_inflation_governor_args ( commitment ) return self . _provider . make_request ( * args ) def get_inflation_rate ( self ) -> types . RPCResponse : \"\"\"Returns the specific inflation values for the current epoch. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_rate() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'epoch': 1, 'foundation': 0.007499746885736559, 'total': 0.14999493771473116, 'validator': 0.1424951908289946}, 'id': 1} \"\"\" return self . _provider . make_request ( self . _get_inflation_rate ) def get_inflation_reward ( self , address_list : List [ Union [ str , PublicKey ]], commitment : Optional [ Commitment ] = None , epoch : Optional [ int ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns the inflation reward for a list of addresses for an epoch. :param address_list: An array of addresses to query, as base-58 encoded strings :param commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". :param epoch: An epoch for which the reward occurs. If omitted, the previous epoch will be used >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_reward(address_list) # doctest: +SKIP { \"jsonrpc\": \"2.0\", \"result\": [ { \"amount\": 2500, \"effectiveSlot\": 224, \"epoch\": 2, \"postBalance\": 499999442500 }, null ], \"id\": 1 } \"\"\" args = self . _get_inflation_reward_args ( address_list = address_list , commitment = commitment , epoch = epoch , min_context_slot = min_context_slot , ) return self . _provider . make_request ( * args ) def get_largest_accounts ( self , filter_opt : Optional [ str ] = None , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the 20 largest accounts, by lamport balance. Args: filter_opt: Filter results by account type; currently supported: circulating|nonCirculating. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_largest_accounts() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 8890}, 'value': [{'address': '95L7AsBCLRsqghsi6ksZkzjNbs6rqDgHCzKaGZ7bJi75', 'lamports': 500000000000000000}, {'address': 'APnSR52EC1eH676m7qTBHUJ1nrGpHYpV7XKPxgRDD8gX', 'lamports': 164511033098290000}, {'address': '13LeFbG6m2EP1fqCj9k66fcXsoTHMMtgr7c78AivUrYD', 'lamports': 153333632446109120}, {'address': 'GK2zqSsXLA2rwVZk347RYhh6jJpRsCA69FjLW93ZGi3B', 'lamports': 57499999036109120}, {'address': '8HVqyX9jebh31Q9Hp8t5sMVJs665979ZeEr3eCfzitUe', 'lamports': 30301031036109120}, {'address': 'HbZ5FfmKWNHC7uwk6TF1hVi6TCs7dtYfdjEcuPGgzFAg', 'lamports': 14999999036109120}, {'address': '14FUT96s9swbmH7ZjpDvfEDywnAYy9zaNhv4xvezySGu', 'lamports': 4999999036109120}, {'address': '9huDUZfxoJ7wGMTffUE7vh1xePqef7gyrLJu9NApncqA', 'lamports': 4999999036109120}, {'address': 'C7C8odR8oashR5Feyrq2tJKaXL18id1dSj2zbkDGL2C2', 'lamports': 4999999036109120}, {'address': 'AYgECURrvuX6GtFe4tX7aAj87Xc5r5Znx96ntNk1nCv', 'lamports': 2499999518054560}, {'address': 'AogcwQ1ubM76EPMhSD5cw1ES4W5econvQCFmBL6nTW1', 'lamports': 2499999518054560}, {'address': 'gWgqQ4udVxE3uNxRHEwvftTHwpEmPHAd8JR9UzaHbR2', 'lamports': 2499999518054560}, {'address': '3D91zLQPRLamwJfGR5ZYMKQb4C18gsJNaSdmB6b2wLhw', 'lamports': 2499999518054560}, {'address': '3bHbMa5VW3np5AJazuacidrN4xPZgwhcXigmjwHmBg5e', 'lamports': 2499999518054560}, {'address': '4U3RFq7X5kLG6tZ9kcksFL8oXeGNjtuUN1YfkVKXbs5x', 'lamports': 2499999518054560}, {'address': '5cBVGBKY6kBaiTVmsQpxThJ2oqitBYuCAX9Zm2zMuV4y', 'lamports': 2499999518054560}, {'address': '8PjJTv657aeN9p5R2WoM6pPSz385chvTTytUWaEjSjkq', 'lamports': 2499999518054560}, {'address': 'AHB94zKUASftTdqgdfiDSdnPJHkEFp7zX3yMrcSxABsv', 'lamports': 2499999518054560}, {'address': 'Hc36Wh1ZqYGzGAnsJWNT9r2gY3h9n89uDpxZPsmEsiE3', 'lamports': 2499999518054560}, {'address': 'GxyRKP2eVKACaSSnso4VLSAjZKmHsFXHWUfS3A5CtiMA', 'lamports': 1940147018054560}]}, 'id': 2} \"\"\" args = self . _get_largest_accounts_args ( filter_opt , commitment ) return self . _provider . make_request ( * args ) def get_leader_schedule ( self , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the leader schedule for an epoch. Args: epoch: Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_leader_schedule() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'EWj2cuEuVhi7RX81cnAY3TzpyFwnHzzVwvuTyfmxmhs3': [0, 1, 2, 3, 4, 5, ...]}, 'id': 6} \"\"\" args = self . _get_leader_schedule_args ( epoch , commitment ) return self . _provider . make_request ( * args ) def get_minimum_balance_for_rent_exemption ( self , usize : int , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns minimum balance required to make account rent exempt. Args: usize: Account data length. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_minimum_balance_for_rent_exemption(50) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1238880, 'id': 7} \"\"\" args = self . _get_minimum_balance_for_rent_exemption_args ( usize , commitment ) return self . _provider . make_request ( * args ) def get_multiple_accounts ( self , pubkeys : List [ Union [ PublicKey , str ]], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. - \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solana.publickey import PublicKey >>> solana_client = Client(\"http://localhost:8899\") >>> pubkeys = [PublicKey(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), PublicKey(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> solana_client.get_multiple_accounts(pubkeys) # doctest: +SKIP { \"jsonrpc\": \"2.0\", \"result\": { \"context\": {\"slot\": 97531946}, \"value\": [ { \"data\": [\"\", \"base64\"], \"executable\": False, \"lamports\": 1, \"owner\": \"11111111111111111111111111111111\", \"rentEpoch\": 225, }, { \"data\": [\"\", \"base64\"], \"executable\": False, \"lamports\": 809441127, \"owner\": \"11111111111111111111111111111111\", \"rentEpoch\": 225, }, ], }, \"id\": 1, } \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_multiple_accounts_args ( pubkeys = pubkeys , commitment = commitment , encoding = encoding , data_slice = data_slice , min_context_slot = min_context_slot , ) return self . _provider . make_request ( * args ) def get_program_accounts ( # pylint: disable=too-many-arguments self , pubkey : Union [ str , PublicKey ], commitment : Optional [ Commitment ] = Finalized , encoding : Optional [ str ] = None , data_slice : Optional [ types . DataSliceOpts ] = None , data_size : Optional [ int ] = None , memcmp_opts : Optional [ List [ types . MemcmpOpts ]] = None , with_context : Optional [ bool ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for the returned Transaction, either jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and ` length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. data_size: (optional) Option to compare the program account data length with the provided data size. memcmp_opts: (optional) Options to compare a provided series of bytes with program account data at a particular offset. with_context: (optional ) Option to wrap the result in an RpcResponse JSON object. min_context_slot: (optional ) set the minimum slot that the request can be evaluated at Example: >>> solana_client = Client(\"http://localhost:8899\") >>> memcmp_opts = [ ... MemcmpOpt(offset=4, bytes=\"3Mc6vR\"), ... ] >>> solana_client.get_program_accounts(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\", data_size=17, memcmp_opts=memcmp_opts) # doctest: +SKIP {'jsonrpc': \"2.0\", 'result' :[{ 'account' :{ 'data' :'2R9jLfiAQ9bgdcw6h8s44439', 'executable' :false, 'lamports' :15298080, 'owner' :'4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T', 'rentEpoch' :28}, 'pubkey' :'CxELquR1gPP8wHe33gZ4QxqGB3sZ9RSwsJ2KshVewkFY'}], 'id' :1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_program_accounts_args ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , data_size = data_size , memcmp_opts = memcmp_opts , with_context = with_context , min_context_slot = min_context_slot , ) return self . _provider . make_request ( * args ) def get_recent_performance_samples ( self , limit : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\" Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Parameters: limit: <usize> - (optional) number of samples to return (maximum 720) Example: solana_client = Client(\"http://localhost:8899\") solana_client.get_recent_performance_samples() solana_client.get_recent_performance_samples(5) \"\"\" args = self . _get_recent_performance_samples_args ( limit ) return self . _provider . make_request ( * args ) def get_max_shred_insert_slot ( self ) -> types . RPCResponse : \"\"\" Get the max slot seen from after shred insert. solana_client = Client(\"http://localhost:8899\") solana_client.get_max_shred_insert_slot() \"\"\" return self . _provider . make_request ( types . RPCMethod ( \"getMaxShredInsertSlot\" ), ) def get_blocks_with_limit ( self , start_slot : int , limit : int , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\" Returns a list of confirmed blocks starting at the given slot Parameters: <u64> - start_slot, as u64 integer <u64> - limit, as u64 integer (optional) Commitment; \"processed\" is not supported. If parameter not provided, the default is \"finalized\". Example: solana_client = Client(\"http://localhost:8899\") solana_client.get_blocks_with_limit(126411503, 5) solana_client.get_blocks_with_limit(126411503, 10, 'confirmed') \"\"\" args = self . _get_blocks_with_limit_args ( start_slot , limit , commitment ) return self . _provider . make_request ( * args ) def get_recent_blockhash ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns a recent block hash from the ledger. Response also includes a fee schedule that can be used to compute the cost of submitting a transaction using it. Deprecated, please use get_latest_blockhash() instead. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_recent_blockhash() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 1637}, 'value': {'blockhash': 'EALChog1mXQ9nEgEUQpWAtmA5UueUZvZiL16ZivmR7eb', 'feeCalculator': {'lamportsPerSignature': 5000}}}, 'id': 2} \"\"\" args = self . _get_recent_blockhash_args ( commitment ) return self . _provider . make_request ( * args ) def get_latest_blockhash ( self , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns the latest block hash from the ledger. Response also includes the last valid block height. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_latest_blockhash() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 1637}, 'value': {'blockhash': 'EALChog1mXQ9nEgEUQpWAtmA5UueUZvZiL16ZivmR7eb', 'lastValidBlockHeight': 3090}}, 'id': 2} \"\"\" args = self . _get_latest_blockhash_args ( commitment , min_context_slot ) return self . _provider . make_request ( * args ) def get_fee_for_message ( self , message : str , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Get the fee the network will charge for a particular Message NEW: This method is only available in solana-core v1.9 or newer. Please use getRecentBlockhash for solana-core v1.8 Args: message: Base-64 encoded Message commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: solana_client = Client(\"http://localhost:8899\") solana_client.get_fee_for_message( 'AQABAgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQAA' ) \"\"\" args = self . _get_fee_for_message_args ( message , commitment ) return self . _provider . make_request ( * args ) def is_blockhash_valid ( self , blockhash : str , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns whether a blockhash is still valid or not NEW: This method is only available in solana-core v1.9 or newer. Please use getRecentBlockhash for solana-core v1.8 Args: blockhash: the blockhash of this block, as base-58 encoded string commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". min_context_slot: set the minimum slot that the request can be evaluated at Example: solana_client = Client(\"http://localhost:8899\") solana_client.is_blockhash_valid( 'J7rBdM6AecPDEZp8aPq5iPSNKVkU5Q76F3oAV4eW5wsW' ) \"\"\" args = self . _get_is_blockhash_valid_args ( blockhash , commitment , min_context_slot , ) return self . _provider . make_request ( * args ) def get_slot_leaders ( self , start_slot : int , limit : int ) -> types . RPCResponse : \"\"\" Returns the slot leaders for a given slot range Parameters: <u64> - start_slot, as u64 integer <u64> - limit, as u64 integer Example: solana_client = Client(\"http://localhost:8899\") solana_client.get_slot_leaders(126411503, 5) \"\"\" args = self . _get_slot_leaders_args ( start_slot , limit ) return self . _provider . make_request ( * args ) def get_highest_snapshot_slot ( self ) -> types . RPCResponse : \"\"\" Returns the highest slot information that the node has snapshots for. This will find the highest full snapshot slot, and the highest incremental snapshot slot based on the full snapshot slot, if there is one. solana_client = Client(\"http://localhost:8899\") solana_client.get_highest_snapshot_slot() \"\"\" return self . _provider . make_request ( types . RPCMethod ( \"getHighestSnapshotSlot\" ), ) def get_max_retransmit_slot ( self ) -> types . RPCResponse : \"\"\" Get the max slot seen from retransmit stage. Example: solana_client = Client(\"http://localhost:8899\") solana_client.get_max_retransmit_slot() \"\"\" return self . _provider . make_request ( types . RPCMethod ( \"getMaxRetransmitSlot\" ), ) def get_block_production ( self , commitment : Optional [ Commitment ] = None , first_slot : Optional [ int ] = None , last_slot : Optional [ int ] = None , identity : Optional [ str ] = None , ) -> types . RPCResponse : \"\"\"Returns recent block production information from the current or previous epoch. Args: (optional) commitment (optional) first_slot: <u64> - first slot to return block production information for (inclusive) (optional) last_slot: <u64> - last slot to return block production information for (inclusive). If parameter not provided, defaults to the highest slot (optional) identity: <string> - Only return results for this validator identity (base-58 encoded) Example: solana_client = Client(\"http://localhost:8899\") solana_client.get_block_production() \"\"\" args = self . _get_block_production_args ( commitment , first_slot , last_slot , identity , ) return self . _provider . make_request ( * args ) def get_signature_statuses ( self , signatures : List [ Union [ str , bytes ]], search_transaction_history : bool = False ) -> types . RPCResponse : \"\"\"Returns the statuses of a list of signatures. Unless the `search_transaction_history` configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus `MAX_RECENT_BLOCKHASHES` rooted slots. Args: signatures: An array of transaction signatures to confirm. search_transaction_history: If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> signatures = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\", ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\"] >>> solana_client.get_signature_statuses(signatures) # doctest: +SKIP {'jsonrpc': '2.0', 'result': { 'context': {'slot':82}, 'value': [{ 'slot': 72, 'confirmations': 10, 'err': null, 'status': {'Ok': null}}, null]}, 'id': 1} \"\"\" args = self . _get_signature_statuses_args ( signatures , search_transaction_history ) return self . _provider . make_request ( * args ) def get_slot ( self , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns the current slot the node is processing. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_slot() # doctest: +SKIP {'jsonrpc': '2.0', 'result': 7515, 'id': 1} \"\"\" args = self . _get_slot_args ( commitment , min_context_slot ) return self . _provider . make_request ( * args ) def get_slot_leader ( self , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns the current slot leader. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_slot_leader() # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'EWj2cuEuVhi7RX81cnAY3TzpyFwnHzzVwvuTyfmxmhs3', 'id': 1} \"\"\" args = self . _get_slot_leader_args ( commitment , min_context_slot ) return self . _provider . make_request ( * args ) def get_stake_activation ( self , pubkey : Union [ PublicKey , str ], epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns epoch activation information for a stake account. Args: pubkey: Pubkey of stake account to query, as base-58 encoded string or PublicKey object. epoch: (optional) Epoch for which to calculate activation details. If parameter not provided, defaults to current epoch. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". min_context_slot: set the minimum slot that the request can be evaluated at Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_stake_activation() # doctest: +SKIP {'jsonrpc': '2.0','result': {'active': 124429280, 'inactive': 73287840, 'state': 'activating'}, 'id': 1}} \"\"\" args = self . _get_stake_activation_args ( pubkey , epoch , commitment , min_context_slot , ) return self . _provider . make_request ( * args ) def get_supply ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns information about the current supply. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_supply() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 3846}, 'value': {'circulating': 683635192454157660, 'nonCirculating': 316364808037127120, 'nonCirculatingAccounts': ['ETfDYz7Cg5p9SDFmdpRerjBN5puKK7xydEBZZGM2V4Ay', '7cKxv6UznFoWRuJkgw5bWj5rp5PiKTcXZeEaLqyd3Bbm', 'CV7qh8ZoqeUSTQagosGpkLptXoojf9yCszxkRx1jTD12', 'FZ9S7X9jMbCaMyJjRfSoBhFyarUMVwvx7HWRe4LnZHsg', ...] 'total': 1000000000491284780}}, 'id': 1} \"\"\" args = self . _get_supply_args ( commitment ) return self . _provider . make_request ( * args ) def get_token_account_balance ( self , pubkey : Union [ str , PublicKey ], commitment : Optional [ Commitment ] = None ): \"\"\"Returns the token balance of an SPL Token account (UNSTABLE). Args: pubkey: Pubkey of Token account to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_token_account_balance(\"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\") # doctest: +SKIP {'jsonrpc': '2.0','result': { 'context': {'slot':1114}, 'value': { 'uiAmount': 98.64, 'amount': '9864', 'decimals': 2}, 'id' :1} \"\"\" args = self . _get_token_account_balance_args ( pubkey , commitment ) return self . _provider . make_request ( * args ) def get_token_accounts_by_delegate ( self , delegate : PublicKey , opts : Optional [ types . TokenAccountOpts ] = None , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" args = self . _get_token_accounts_by_delegate_args ( delegate , opts , commitment ) return self . __get_token_accounts ( * args ) def get_token_accounts_by_owner ( self , owner : PublicKey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Returns all SPL Token accounts by token owner (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" args = self . _get_token_accounts_by_owner_args ( owner , opts , commitment ) return self . __get_token_accounts ( * args ) def __get_token_accounts ( self , method : types . RPCMethod , pubkey : str , opts : types . TokenAccountOpts , commitment : Commitment , ) -> types . RPCResponse : args = self . _get_token_accounts_args ( method , pubkey , opts , commitment ) return self . _provider . make_request ( * args ) def get_token_largest_accounts ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the 20 largest accounts of a particular SPL Token type.\"\"\" args = self . _get_token_largest_account_args ( pubkey , commitment ) return self . _provider . make_request ( * args ) def get_token_supply ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the total supply of an SPL Token type.\"\"\" args = self . _get_token_supply_args ( pubkey , commitment ) return self . _provider . make_request ( * args ) def get_transaction_count ( self , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns the current Transaction count from the ledger. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_transaction_count() # doctest: +SKIP {'jsonrpc': '2.0', 'result': 4554, 'id': 1} \"\"\" args = self . _get_transaction_count_args ( commitment , min_context_slot ) return self . _provider . make_request ( * args ) def get_minimum_ledger_slot ( self ) -> types . RPCResponse : \"\"\"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_minimum_ledger_slot() # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1234, 'id': 1} \"\"\" return self . _provider . make_request ( self . _minimum_ledger_slot ) def get_version ( self ) -> types . RPCResponse : \"\"\"Returns the current solana versions running on the node. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_version() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'solana-core': '1.4.0 5332fcad'}, 'id': 1} \"\"\" return self . _provider . make_request ( self . _get_version ) def get_vote_accounts ( self , commitment : Optional [ Commitment ] = None ): \"\"\"Returns the account info and associated stake for all the voting accounts in the current bank. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_vote_accounts() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'current': [{'activatedStake': 0, 'commission': 100, 'epochCredits': [[165, 714644, 707372], [166, 722092, 714644], [167, 730285, 722092], [168, 738476, 730285], ...] 'epochVoteAccount': True, 'lastVote': 1872294, 'nodePubkey': 'J7v9ndmcoBuo9to2MnHegLnBkC9x3SAVbQBJo5MMJrN1', 'rootSlot': 1872263, 'votePubkey': 'HiFjzpR7e5Kv2tdU9jtE4FbH1X8Z9Syia3Uadadx18b5'}, {'activatedStake': 500029968930560, 'commission': 100, 'epochCredits': [[165, 1359689, 1351498], [166, 1367881, 1359689], [167, 1376073, 1367881], [168, 1384265, 1376073], ...], 'epochVoteAccount': True, 'lastVote': 1872295, 'nodePubkey': 'dv1LfzJvDF7S1fBKpFgKoKXK5yoSosmkAdfbxBo1GqJ', 'rootSlot': 1872264, 'votePubkey': '5MMCR4NbTZqjthjLGywmeT66iwE9J9f7kjtxzJjwfUx2'}, {'activatedStake': 0, 'commission': 100, 'epochCredits': [[227, 2751, 0], [228, 7188, 2751]], 'epochVoteAccount': True, 'lastVote': 1872295, 'nodePubkey': 'H1wDvJ5HJc1SzhHoWtaycpzQpFbsL7g8peaRV3obKShs', 'rootSlot': 1872264, 'votePubkey': 'DPqpgoLQVU3aq72HEqSMsB9qh4KoXc9fGEpvgEuiwnp6'}], 'delinquent': []}, 'id': 1} \"\"\" args = self . _get_vote_accounts_args ( commitment ) return self . _provider . make_request ( * args ) def request_airdrop ( self , pubkey : Union [ PublicKey , str ], lamports : int , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Requests an airdrop of lamports to a Pubkey. Args: pubkey: Pubkey of account to receive lamports, as base-58 encoded string or public key object. lamports: Amout of lamports. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solana.publickey import PublicKey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.request_airdrop(PublicKey(1), 10000) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'uK6gbLbhnTEgjgmwn36D5BRTRkG4AT8r7Q162TLnJzQnHUZVL9r6BYZVfRttrhmkmno6Fp4VQELzL4AiriCo61U', 'id': 1} \"\"\" args = self . _request_airdrop_args ( pubkey , lamports , commitment ) return self . _provider . make_request ( * args ) def send_raw_transaction ( self , txn : Union [ bytes , str ], opts : Optional [ types . TxOpts ] = None , ) -> types . RPCResponse : \"\"\"Send a transaction that has already been signed and serialized into the wire format. Args: txn: Fully-signed Transaction object, a fully sign transaction in wire format, or a fully transaction as base-64 encoded string. opts: (optional) Transaction options. Before submitting, the following preflight checks are performed (unless disabled with the `skip_preflight` option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> full_signed_tx_str = ( ... \"AbN5XM+qw+7oOLsFw7goQSLBis7c1kXJFP6OF4w7YmQNhhbQYcyBiybKuOzzhV7McvoRP3Mey9AhXojtwDCdbwoBAAEDE5j2\" ... \"LG0aRXxRumpLXz29L2n8qTIWIY3ImX5Ba9F9k8poq0Z3/7HyiU3QphU8Ix1F7ENq5TrmAUnb4V8y5LhwPwAAAAAAAAAAAAAA\" ... \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAg5YY9wG6fpuieuWYJd1ta7ZtFPbV0OriFRYdcYUaEGkBAgIAAQwCAAAAQEIPAAAAAAA=\") >>> solana_client.send_raw_transaction(full_signed_tx_str) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'CMwyESM2NE74mghfbvsHJDERF7xMYKshwwm6VgH6GFqXzx8LfBFuP5ruccumfhTguha6seUHPpiHzzHUQXzq2kN', 'id': 1} \"\"\" # noqa: E501 # pylint: disable=line-too-long opts_to_use = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts args = self . _send_raw_transaction_args ( txn , opts_to_use ) resp = self . _provider . make_request ( * args ) if opts_to_use . skip_confirmation : return self . _post_send ( resp ) post_send_args = self . _send_raw_transaction_post_send_args ( resp , opts_to_use ) return self . __post_send_with_confirm ( * post_send_args ) def send_transaction ( self , txn : Transaction , * signers : Keypair , opts : Optional [ types . TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> types . RPCResponse : \"\"\"Send a transaction. Args: txn: Transaction object. signers: Signers to sign the transaction. opts: (optional) Transaction options. recent_blockhash: (optional) Pass a valid recent blockhash here if you want to skip fetching the recent blockhash or relying on the cache. Example: >>> from solana.keypair import Keypair >>> from solana.publickey import PublicKey >>> from solana.rpc.api import Client >>> from solana.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> sender, receiver = Keypair.from_seed(bytes(PublicKey(1))), Keypair.from_seed(bytes(PublicKey(2))) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.public_key, to_pubkey=receiver.public_key, lamports=1000))) >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.send_transaction(txn, sender) # doctest: +SKIP {'jsonrpc': '2.0', 'result': '236zSA5w4NaVuLXXHK1mqiBuBxkNBu84X6cfLBh1v6zjPrLfyECz4zdedofBaZFhs4gdwzSmij9VkaSo2tR5LTgG', 'id': 12} \"\"\" last_valid_block_height = None if recent_blockhash is None : if self . blockhash_cache : try : recent_blockhash = self . blockhash_cache . get () except ValueError : blockhash_resp = self . get_latest_blockhash ( Finalized ) recent_blockhash = self . _process_blockhash_resp ( blockhash_resp , used_immediately = True ) last_valid_block_height = blockhash_resp [ \"result\" ][ \"value\" ][ \"lastValidBlockHeight\" ] else : blockhash_resp = self . get_latest_blockhash ( Finalized ) recent_blockhash = self . parse_recent_blockhash ( blockhash_resp ) last_valid_block_height = blockhash_resp [ \"result\" ][ \"value\" ][ \"lastValidBlockHeight\" ] txn . recent_blockhash = recent_blockhash txn . sign ( * signers ) opts_to_use = ( types . TxOpts ( preflight_commitment = self . _commitment , last_valid_block_height = last_valid_block_height ) if opts is None else opts ) txn_resp = self . send_raw_transaction ( txn . serialize (), opts = opts_to_use ) if self . blockhash_cache : blockhash_resp = self . get_recent_blockhash ( Finalized ) self . _process_blockhash_resp ( blockhash_resp , used_immediately = False ) return txn_resp def simulate_transaction ( self , txn : Union [ bytes , str , Transaction ], sig_verify : bool = False , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Simulate sending a transaction. Args: txn: A Transaction object, a transaction in wire format, or a transaction as base-64 encoded string The transaction must have a valid blockhash, but is not required to be signed. sig_verify: If true the transaction signatures will be verified (default: false). commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> tx_str = ( ... \"4hXTCkRzt9WyecNzV1XPgCDfGAZzQKNxLXgynz5QDuWWPSAZBZSHptvWRL3BjCvzUXRdKvHL2b7yGrRQcWyaqsaBCncVG7BF\" ... \"ggS8w9snUts67BSh3EqKpXLUm5UMHfD7ZBe9GhARjbNQMLJ1QD3Spr6oMTBU6EhdB4RD8CP2xUxr2u3d6fos36PD98XS6oX8\" ... \"TQjLpsMwncs5DAMiD4nNnR8NBfyghGCWvCVifVwvA8B8TJxE1aiyiv2L429BCWfyzAme5sZW8rDb14NeCQHhZbtNqfXhcp2t\" ... ) >>> solana_client.simulate_transaction(tx_str) # doctest: +SKIP {'jsonrpc' :'2.0', 'result': {'context': {'slot': 218}, 'value': { 'err': null, 'logs': ['BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success']}, 'id':1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _simulate_transaction_args ( txn , sig_verify , commitment , min_context_slot , ) return self . _provider . make_request ( * args ) def set_log_filter ( self , log_filter : str ) -> types . RPCResponse : \"\"\"Sets the log filter on the validator. Args: log_filter: The new log filter to use. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.set_log_filter(\"solana_core=debug\") # doctest: +SKIP {'jsonrpc': '2.0', 'result': None, 'id': 1} \"\"\" args = self . _set_log_filter_args ( log_filter ) return self . _provider . make_request ( * args ) def validator_exit ( self ) -> types . RPCResponse : \"\"\"Request to have the validator exit. Validator must have booted with RPC exit enabled (`--enable-rpc-exit` parameter). Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.validator_exit() # doctest: +SKIP {'jsonrpc': '2.0', 'result': true, 'id': 1} \"\"\" return self . _provider . make_request ( self . _validator_exit ) def __post_send_with_confirm ( self , resp : types . RPCResponse , conf_comm : Commitment , last_valid_block_height : Optional [ int ] ) -> types . RPCResponse : resp = self . _post_send ( resp ) self . _provider . logger . info ( \"Transaction sent to %s . Signature %s : \" , self . _provider . endpoint_uri , resp [ \"result\" ] ) self . confirm_transaction ( resp [ \"result\" ], conf_comm ) return resp def confirm_transaction ( self , tx_sig : str , commitment : Optional [ Commitment ] = None , sleep_seconds : float = 0.5 , last_valid_block_height : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Confirm the transaction identified by the specified signature. Args: tx_sig: the transaction signature to confirm. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". sleep_seconds: The number of seconds to sleep when polling the signature status. \"\"\" timeout = time () + 90 commitment_to_use = self . _commitment if commitment is None else commitment commitment_rank = COMMITMENT_RANKS [ commitment_to_use ] if last_valid_block_height : # pylint: disable=no-else-return current_blockheight = ( self . get_block_height ( commitment ))[ \"result\" ] while current_blockheight <= last_valid_block_height : resp = self . get_signature_statuses ([ tx_sig ]) maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) resp_value = resp [ \"result\" ][ \"value\" ][ 0 ] if resp_value is not None : confirmation_status = resp_value [ \"confirmationStatus\" ] confirmation_rank = COMMITMENT_RANKS [ confirmation_status ] if confirmation_rank >= commitment_rank : break current_blockheight = ( self . get_block_height ( commitment ))[ \"result\" ] sleep ( sleep_seconds ) else : maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) raise TransactionExpiredBlockheightExceededError ( f \" { tx_sig } has expired: block height exceeded\" ) return resp else : while time () < timeout : resp = self . get_signature_statuses ([ tx_sig ]) maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) resp_value = resp [ \"result\" ][ \"value\" ][ 0 ] if resp_value is not None : confirmation_status = resp_value [ \"confirmationStatus\" ] confirmation_rank = COMMITMENT_RANKS [ confirmation_status ] if confirmation_rank >= commitment_rank : break sleep ( sleep_seconds ) else : maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) raise UnconfirmedTxError ( f \"Unable to confirm transaction { tx_sig } \" ) return resp","title":"Client"},{"location":"rpc/api/#solana.rpc.api.Client.__init__","text":"Init API client. Source code in solana/rpc/api.py def __init__ ( self , endpoint : Optional [ str ] = None , commitment : Optional [ Commitment ] = None , blockhash_cache : Union [ BlockhashCache , bool ] = False , timeout : float = 10 , ): \"\"\"Init API client.\"\"\" super () . __init__ ( commitment , blockhash_cache ) self . _provider = http . HTTPProvider ( endpoint , timeout = timeout )","title":"__init__()"},{"location":"rpc/api/#solana.rpc.api.Client.confirm_transaction","text":"Confirm the transaction identified by the specified signature. Parameters: Name Type Description Default tx_sig str the transaction signature to confirm. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None sleep_seconds float The number of seconds to sleep when polling the signature status. 0.5 Source code in solana/rpc/api.py def confirm_transaction ( self , tx_sig : str , commitment : Optional [ Commitment ] = None , sleep_seconds : float = 0.5 , last_valid_block_height : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Confirm the transaction identified by the specified signature. Args: tx_sig: the transaction signature to confirm. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". sleep_seconds: The number of seconds to sleep when polling the signature status. \"\"\" timeout = time () + 90 commitment_to_use = self . _commitment if commitment is None else commitment commitment_rank = COMMITMENT_RANKS [ commitment_to_use ] if last_valid_block_height : # pylint: disable=no-else-return current_blockheight = ( self . get_block_height ( commitment ))[ \"result\" ] while current_blockheight <= last_valid_block_height : resp = self . get_signature_statuses ([ tx_sig ]) maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) resp_value = resp [ \"result\" ][ \"value\" ][ 0 ] if resp_value is not None : confirmation_status = resp_value [ \"confirmationStatus\" ] confirmation_rank = COMMITMENT_RANKS [ confirmation_status ] if confirmation_rank >= commitment_rank : break current_blockheight = ( self . get_block_height ( commitment ))[ \"result\" ] sleep ( sleep_seconds ) else : maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) raise TransactionExpiredBlockheightExceededError ( f \" { tx_sig } has expired: block height exceeded\" ) return resp else : while time () < timeout : resp = self . get_signature_statuses ([ tx_sig ]) maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) resp_value = resp [ \"result\" ][ \"value\" ][ 0 ] if resp_value is not None : confirmation_status = resp_value [ \"confirmationStatus\" ] confirmation_rank = COMMITMENT_RANKS [ confirmation_status ] if confirmation_rank >= commitment_rank : break sleep ( sleep_seconds ) else : maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) raise UnconfirmedTxError ( f \"Unable to confirm transaction { tx_sig } \" ) return resp","title":"confirm_transaction()"},{"location":"rpc/api/#solana.rpc.api.Client.get_account_info","text":"Returns all the account info for the specified public key. Parameters: Name Type Description Default pubkey Union[PublicKey, str] Pubkey of account to query, as base-58 encoded string or PublicKey object. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding str (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". \"base58\" is limited to Account data of less than 128 bytes. \"base64\" will return base64 encoded data for Account data of any size. \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). 'base64' data_slice Optional[types.DataSliceOpts] (optional) Option to limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None min_context_slot Optional[int] set the minimum slot that the request can be evaluated at None Examples: >>> from solana.publickey import PublicKey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_account_info ( PublicKey ( 1 )) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 33265073 }, 'value' : { 'data' : '' , 'executable' : False , 'lamports' : 4459816188034584 , 'owner' : '11111111111111111111111111111111' , 'rentEpoch' : 90 }}, 'id' : 1 } Source code in solana/rpc/api.py def get_account_info ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns all the account info for the specified public key. Args: pubkey: Pubkey of account to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. - \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. min_context_slot: set the minimum slot that the request can be evaluated at Example: >>> from solana.publickey import PublicKey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_account_info(PublicKey(1)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 33265073}, 'value': {'data': '', 'executable': False, 'lamports': 4459816188034584, 'owner': '11111111111111111111111111111111', 'rentEpoch': 90}}, 'id': 1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_account_info_args ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , min_context_slot = min_context_slot , ) return self . _provider . make_request ( * args )","title":"get_account_info()"},{"location":"rpc/api/#solana.rpc.api.Client.get_balance","text":"Returns the balance of the account of provided Pubkey. Parameters: Name Type Description Default pubkey Union[PublicKey, str] Pubkey of account to query, as base-58 encoded string or PublicKey object. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None min_context_slot Optional[int] set the minimum slot that the request can be evaluated at None Examples: >>> from solana.publickey import PublicKey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_balance ( PublicKey ( 1 )) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 228 }, 'value' : 0 }, 'id' : 1 } Source code in solana/rpc/api.py def get_balance ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns the balance of the account of provided Pubkey. Args: pubkey: Pubkey of account to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". min_context_slot: set the minimum slot that the request can be evaluated at Example: >>> from solana.publickey import PublicKey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_balance(PublicKey(1)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 228}, 'value': 0}, 'id': 1} \"\"\" args = self . _get_balance_args ( pubkey , commitment , min_context_slot ) return self . _provider . make_request ( * args )","title":"get_balance()"},{"location":"rpc/api/#solana.rpc.api.Client.get_block","text":"Returns identity and transaction information about a confirmed block in the ledger. Parameters: Name Type Description Default slot int Slot, as u64 integer. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' commitment Optional[Commitment] (optional) It can be either \"finalized\", \"confirmed\". \"processed\" is not supported. If parameter not provided, the default is \"finalized\". None rewards Optional[bool] (optional) whether to populate the rewards array. If parameter not provided, the default includes rewards. None transaction_details Optional[str] (optional) level of transaction detail to return, either \"full\", \"accounts\", \"signatures\", or \"none\". If parameter not provided, the default detail level is \"full\". None max_support_transaction_version Optional[int] (optional) set the max transaction version to return in responses. If the requested block contains a transaction with a higher version, an error will be returned. None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_block ( 1 ) { 'jsonrpc' : '2.0' , 'result' : { 'blockTime' : None , 'blockHeight' : 0 , 'blockhash' : '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj' , 'parentSlot' : 0 , 'previousBlockhash' : 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2' , 'rewards' : [], 'transactions' : [{ 'meta' : { 'err' : None , 'fee' : 0 , 'postBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'preBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'status' : { 'Ok' : None }}, 'transaction' : { 'message' : { 'accountKeys' : [ 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk' , 'EKAar3bMQUZvGSonq7vcPF2nPaCYowbnat44FPafW8Po' , 'SysvarS1otHashes111111111111111111111111111' , 'SysvarC1ock11111111111111111111111111111111' , 'Vote111111111111111111111111111111111111111' ], 'header' : { 'numReadonlySignedAccounts' : 0 , 'numReadonlyUnsignedAccounts' : 3 , 'numRequiredSignatures' : 1 }, 'instructions' : [{ 'accounts' : [ 1 , 2 , 3 , 0 ], 'data' : '37u9WtQpcm6ULa3VmTgTKEBCtYMxq84mk82tRvKdFEwj3rALiptAzuMJ1yoVSFAMARMZYp7q' , 'programIdIndex' : 4 }], 'recentBlockhash' : 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2' }, 'signatures' : [ '63jnpMCs7TNnCjnTqUrX7Mvqc5CbJMtVkLxBjPHUQkjXyZrQuZpfhjvzA7A29D9tMqVaiQC3UNP1NeaZKFFHJyQE' ]}}]}, 'id' : 9 } >>> solana_client . get_block ( 1 , encoding = \"base64\" ) { 'jsonrpc' : '2.0' , 'result' : { 'blockTime' : None , 'blockHeight' : 0 , 'blockhash' : '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj' , 'parentSlot' : 0 , 'previousBlockhash' : 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2' , 'rewards' : [], 'transactions' : [{ 'meta' : { 'err' : None , 'fee' : 0 , 'postBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'preBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'status' : { 'Ok' : None }}, 'transaction' : [ 'AfxyKHmHIjXWjkyHODGeAbVxmfQWPj1ydS9nF+ynJHo8I1vCPDp2P9Cj5aA6W1CAHEHCqY0B1FDKomCzRo3qrAsBAAMFBQ6QBWfhQF7rG02xhuEsmmrUtz3AUjBtJKkqaHPJEmvFzziDX0C0robPrl9RbOyXHoc9/Dxa0zoGL6cEjvCjLgan1RcZLwqvxvJl4/t3zHragsUp0L47E24tAFUgAAAABqfVFxjHdMkoVmOYaR1etoteuKObS21cc1VbIQAAAAAHYUgdNXR0u3xNdiTr072z2DVec9EQQ/wNo1OAAAAAAM8NSv7ISDPN9E9XNL9vX7h8LuJHWlopUcX39DxsDx23AQQEAQIDADUCAAAAAQAAAAAAAAAAAAAAAAAAAIWWp5Il3Kg312pzVk6Jt61iyFhTbtmkh/ORbj3JUQRbAA==' , 'base64' ]}]}, 'id' : 10 } Source code in solana/rpc/api.py def get_block ( self , slot : int , encoding : str = \"json\" , commitment : Optional [ Commitment ] = None , rewards : Optional [ bool ] = None , transaction_details : Optional [ str ] = None , max_support_transaction_version : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. commitment:(optional) It can be either \"finalized\", \"confirmed\". \"processed\" is not supported. If parameter not provided, the default is \"finalized\". rewards: (optional) whether to populate the rewards array. If parameter not provided, the default includes rewards. transaction_details: (optional) level of transaction detail to return, either \"full\", \"accounts\", \"signatures\", or \"none\". If parameter not provided, the default detail level is \"full\". max_support_transaction_version: (optional) set the max transaction version to return in responses. If the requested block contains a transaction with a higher version, an error will be returned. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block(1) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockHeight': 0, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': {'message': {'accountKeys': ['LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk', 'EKAar3bMQUZvGSonq7vcPF2nPaCYowbnat44FPafW8Po', 'SysvarS1otHashes111111111111111111111111111', 'SysvarC1ock11111111111111111111111111111111', 'Vote111111111111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 3, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [1, 2, 3, 0], 'data': '37u9WtQpcm6ULa3VmTgTKEBCtYMxq84mk82tRvKdFEwj3rALiptAzuMJ1yoVSFAMARMZYp7q', 'programIdIndex': 4}], 'recentBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2'}, 'signatures': ['63jnpMCs7TNnCjnTqUrX7Mvqc5CbJMtVkLxBjPHUQkjXyZrQuZpfhjvzA7A29D9tMqVaiQC3UNP1NeaZKFFHJyQE']}}]}, 'id': 9} >>> solana_client.get_block(1, encoding=\"base64\") # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockHeight': 0, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': ['AfxyKHmHIjXWjkyHODGeAbVxmfQWPj1ydS9nF+ynJHo8I1vCPDp2P9Cj5aA6W1CAHEHCqY0B1FDKomCzRo3qrAsBAAMFBQ6QBWfhQF7rG02xhuEsmmrUtz3AUjBtJKkqaHPJEmvFzziDX0C0robPrl9RbOyXHoc9/Dxa0zoGL6cEjvCjLgan1RcZLwqvxvJl4/t3zHragsUp0L47E24tAFUgAAAABqfVFxjHdMkoVmOYaR1etoteuKObS21cc1VbIQAAAAAHYUgdNXR0u3xNdiTr072z2DVec9EQQ/wNo1OAAAAAAM8NSv7ISDPN9E9XNL9vX7h8LuJHWlopUcX39DxsDx23AQQEAQIDADUCAAAAAQAAAAAAAAAAAAAAAAAAAIWWp5Il3Kg312pzVk6Jt61iyFhTbtmkh/ORbj3JUQRbAA==', 'base64']}]}, 'id': 10} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_block_args ( slot , encoding , commitment , rewards , transaction_details , max_support_transaction_version , ) return self . _provider . make_request ( * args )","title":"get_block()"},{"location":"rpc/api/#solana.rpc.api.Client.get_block_commitment","text":"Fetch the commitment for particular block. Parameters: Name Type Description Default slot int Block, identified by Slot. required Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_block_commitment ( 0 ) { 'jsonrpc' : '2.0' , 'result' : { 'commitment' : [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 497717120 ], 'totalStake' : 497717120 }, 'id' : 1 }} Source code in solana/rpc/api.py def get_block_commitment ( self , slot : int ) -> types . RPCResponse : \"\"\"Fetch the commitment for particular block. Args: slot: Block, identified by Slot. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_commitment(0) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'commitment': [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 497717120], 'totalStake': 497717120}, 'id': 1}} \"\"\" args = self . _get_block_commitment_args ( slot ) return self . _provider . make_request ( * args )","title":"get_block_commitment()"},{"location":"rpc/api/#solana.rpc.api.Client.get_block_height","text":"Returns the current block height of the node. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_block_height () { 'jsonrpc' : '2.0' , 'result' : 1233 , 'id' : 1 } Source code in solana/rpc/api.py def get_block_height ( self , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns the current block height of the node. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_height() # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1233, 'id': 1} \"\"\" args = self . _get_block_height_args ( commitment , min_context_slot ) return self . _provider . make_request ( * args )","title":"get_block_height()"},{"location":"rpc/api/#solana.rpc.api.Client.get_block_production","text":"Returns recent block production information from the current or previous epoch. Parameters: Name Type Description Default (optional) first_slot - first slot to return block production information for (inclusive) required (optional) last_slot - last slot to return block production information for (inclusive). If parameter not provided, defaults to the highest slot required (optional) identity - Only return results for this validator identity (base-58 encoded) required Examples: solana_client = Client(\"http://localhost:8899\") solana_client.get_block_production() Source code in solana/rpc/api.py def get_block_production ( self , commitment : Optional [ Commitment ] = None , first_slot : Optional [ int ] = None , last_slot : Optional [ int ] = None , identity : Optional [ str ] = None , ) -> types . RPCResponse : \"\"\"Returns recent block production information from the current or previous epoch. Args: (optional) commitment (optional) first_slot: <u64> - first slot to return block production information for (inclusive) (optional) last_slot: <u64> - last slot to return block production information for (inclusive). If parameter not provided, defaults to the highest slot (optional) identity: <string> - Only return results for this validator identity (base-58 encoded) Example: solana_client = Client(\"http://localhost:8899\") solana_client.get_block_production() \"\"\" args = self . _get_block_production_args ( commitment , first_slot , last_slot , identity , ) return self . _provider . make_request ( * args )","title":"get_block_production()"},{"location":"rpc/api/#solana.rpc.api.Client.get_block_time","text":"Fetch the estimated production time of a block. Parameters: Name Type Description Default slot int Block, identified by Slot. required Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_block_time ( 5 ) { 'jsonrpc' : '2.0' , 'result' : 1598400007 , 'id' : 1 } Source code in solana/rpc/api.py def get_block_time ( self , slot : int ) -> types . RPCResponse : \"\"\"Fetch the estimated production time of a block. Args: slot: Block, identified by Slot. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_time(5) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1598400007, 'id': 1} \"\"\" args = self . _get_block_time_args ( slot ) return self . _provider . make_request ( * args )","title":"get_block_time()"},{"location":"rpc/api/#solana.rpc.api.Client.get_blocks","text":"Returns a list of confirmed blocks. Parameters: Name Type Description Default start_slot int Start slot, as u64 integer. required end_slot Optional[int] (optional) End slot, as u64 integer. None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_blocks ( 5 , 10 ) { 'jsonrpc' : '2.0' , 'result' : [ 5 , 6 , 7 , 8 , 9 , 10 ], 'id' : 1 } Source code in solana/rpc/api.py def get_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> types . RPCResponse : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_blocks(5, 10) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [5, 6, 7, 8, 9, 10], 'id': 1} \"\"\" args = self . _get_blocks_args ( start_slot , end_slot ) return self . _provider . make_request ( * args )","title":"get_blocks()"},{"location":"rpc/api/#solana.rpc.api.Client.get_blocks_with_limit","text":"Returns a list of confirmed blocks starting at the given slot Examples: solana_client = Client(\"http://localhost:8899\") solana_client.get_blocks_with_limit(126411503, 5) solana_client.get_blocks_with_limit(126411503, 10, 'confirmed') Source code in solana/rpc/api.py def get_blocks_with_limit ( self , start_slot : int , limit : int , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\" Returns a list of confirmed blocks starting at the given slot Parameters: <u64> - start_slot, as u64 integer <u64> - limit, as u64 integer (optional) Commitment; \"processed\" is not supported. If parameter not provided, the default is \"finalized\". Example: solana_client = Client(\"http://localhost:8899\") solana_client.get_blocks_with_limit(126411503, 5) solana_client.get_blocks_with_limit(126411503, 10, 'confirmed') \"\"\" args = self . _get_blocks_with_limit_args ( start_slot , limit , commitment ) return self . _provider . make_request ( * args )","title":"get_blocks_with_limit()"},{"location":"rpc/api/#solana.rpc.api.Client.get_cluster_nodes","text":"Returns information about all the nodes participating in the cluster. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_cluster_nodes () { 'jsonrpc' : '2.0' , 'result' : [{ 'gossip' : '127.0.0.1:8001' , 'pubkey' : 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk' , 'rpc' : '127.0.0.1:8899' , 'tpu' : '127.0.0.1:8003' , 'version' : '1.4.0 5332fcad' }], 'id' : 1 } Source code in solana/rpc/api.py def get_cluster_nodes ( self ) -> types . RPCResponse : \"\"\"Returns information about all the nodes participating in the cluster. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_cluster_nodes() # doctest: +SKIP {'jsonrpc': '2.0', 'result': [{'gossip': '127.0.0.1:8001', 'pubkey': 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk', 'rpc': '127.0.0.1:8899', 'tpu': '127.0.0.1:8003', 'version': '1.4.0 5332fcad'}], 'id': 1} \"\"\" return self . _provider . make_request ( self . _get_cluster_nodes )","title":"get_cluster_nodes()"},{"location":"rpc/api/#solana.rpc.api.Client.get_confirmed_block","text":"Returns identity and transaction information about a confirmed block in the ledger. Parameters: Name Type Description Default slot int Slot, as u64 integer. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_confirmed_block ( 1 ) { 'jsonrpc' : '2.0' , 'result' : { 'blockTime' : None , 'blockhash' : '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj' , 'parentSlot' : 0 , 'previousBlockhash' : 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2' , 'rewards' : [], 'transactions' : [{ 'meta' : { 'err' : None , 'fee' : 0 , 'postBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'preBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'status' : { 'Ok' : None }}, 'transaction' : { 'message' : { 'accountKeys' : [ 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk' , 'EKAar3bMQUZvGSonq7vcPF2nPaCYowbnat44FPafW8Po' , 'SysvarS1otHashes111111111111111111111111111' , 'SysvarC1ock11111111111111111111111111111111' , 'Vote111111111111111111111111111111111111111' ], 'header' : { 'numReadonlySignedAccounts' : 0 , 'numReadonlyUnsignedAccounts' : 3 , 'numRequiredSignatures' : 1 }, 'instructions' : [{ 'accounts' : [ 1 , 2 , 3 , 0 ], 'data' : '37u9WtQpcm6ULa3VmTgTKEBCtYMxq84mk82tRvKdFEwj3rALiptAzuMJ1yoVSFAMARMZYp7q' , 'programIdIndex' : 4 }], 'recentBlockhash' : 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2' }, 'signatures' : [ '63jnpMCs7TNnCjnTqUrX7Mvqc5CbJMtVkLxBjPHUQkjXyZrQuZpfhjvzA7A29D9tMqVaiQC3UNP1NeaZKFFHJyQE' ]}}]}, 'id' : 9 } >>> solana_client . get_confirmed_block ( 1 , encoding = \"base64\" ) { 'jsonrpc' : '2.0' , 'result' : { 'blockTime' : None , 'blockhash' : '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj' , 'parentSlot' : 0 , 'previousBlockhash' : 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2' , 'rewards' : [], 'transactions' : [{ 'meta' : { 'err' : None , 'fee' : 0 , 'postBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'preBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'status' : { 'Ok' : None }}, 'transaction' : [ 'AfxyKHmHIjXWjkyHODGeAbVxmfQWPj1ydS9nF+ynJHo8I1vCPDp2P9Cj5aA6W1CAHEHCqY0B1FDKomCzRo3qrAsBAAMFBQ6QBWfhQF7rG02xhuEsmmrUtz3AUjBtJKkqaHPJEmvFzziDX0C0robPrl9RbOyXHoc9/Dxa0zoGL6cEjvCjLgan1RcZLwqvxvJl4/t3zHragsUp0L47E24tAFUgAAAABqfVFxjHdMkoVmOYaR1etoteuKObS21cc1VbIQAAAAAHYUgdNXR0u3xNdiTr072z2DVec9EQQ/wNo1OAAAAAAM8NSv7ISDPN9E9XNL9vX7h8LuJHWlopUcX39DxsDx23AQQEAQIDADUCAAAAAQAAAAAAAAAAAAAAAAAAAIWWp5Il3Kg312pzVk6Jt61iyFhTbtmkh/ORbj3JUQRbAA==' , 'base64' ]}]}, 'id' : 10 } Source code in solana/rpc/api.py def get_confirmed_block ( self , slot : int , encoding : str = \"json\" , max_support_transaction_version = None , ) -> types . RPCResponse : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_confirmed_block(1) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': {'message': {'accountKeys': ['LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk', 'EKAar3bMQUZvGSonq7vcPF2nPaCYowbnat44FPafW8Po', 'SysvarS1otHashes111111111111111111111111111', 'SysvarC1ock11111111111111111111111111111111', 'Vote111111111111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 3, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [1, 2, 3, 0], 'data': '37u9WtQpcm6ULa3VmTgTKEBCtYMxq84mk82tRvKdFEwj3rALiptAzuMJ1yoVSFAMARMZYp7q', 'programIdIndex': 4}], 'recentBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2'}, 'signatures': ['63jnpMCs7TNnCjnTqUrX7Mvqc5CbJMtVkLxBjPHUQkjXyZrQuZpfhjvzA7A29D9tMqVaiQC3UNP1NeaZKFFHJyQE']}}]}, 'id': 9} >>> solana_client.get_confirmed_block(1, encoding=\"base64\") # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': ['AfxyKHmHIjXWjkyHODGeAbVxmfQWPj1ydS9nF+ynJHo8I1vCPDp2P9Cj5aA6W1CAHEHCqY0B1FDKomCzRo3qrAsBAAMFBQ6QBWfhQF7rG02xhuEsmmrUtz3AUjBtJKkqaHPJEmvFzziDX0C0robPrl9RbOyXHoc9/Dxa0zoGL6cEjvCjLgan1RcZLwqvxvJl4/t3zHragsUp0L47E24tAFUgAAAABqfVFxjHdMkoVmOYaR1etoteuKObS21cc1VbIQAAAAAHYUgdNXR0u3xNdiTr072z2DVec9EQQ/wNo1OAAAAAAM8NSv7ISDPN9E9XNL9vX7h8LuJHWlopUcX39DxsDx23AQQEAQIDADUCAAAAAQAAAAAAAAAAAAAAAAAAAIWWp5Il3Kg312pzVk6Jt61iyFhTbtmkh/ORbj3JUQRbAA==', 'base64']}]}, 'id': 10} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_confirmed_block_args ( slot , encoding , max_support_transaction_version , ) return self . _provider . make_request ( * args )","title":"get_confirmed_block()"},{"location":"rpc/api/#solana.rpc.api.Client.get_confirmed_blocks","text":"Returns a list of confirmed blocks. Parameters: Name Type Description Default start_slot int Start slot, as u64 integer. required end_slot Optional[int] (optional) End slot, as u64 integer. None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_confirmed_blocks ( 5 , 10 ) { 'jsonrpc' : '2.0' , 'result' : [ 5 , 6 , 7 , 8 , 9 , 10 ], 'id' : 1 } Source code in solana/rpc/api.py def get_confirmed_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> types . RPCResponse : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_confirmed_blocks(5, 10) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [5, 6, 7, 8, 9, 10], 'id': 1} \"\"\" args = self . _get_confirmed_blocks_args ( start_slot , end_slot ) return self . _provider . make_request ( * args )","title":"get_confirmed_blocks()"},{"location":"rpc/api/#solana.rpc.api.Client.get_confirmed_signature_for_address2","text":"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Parameters: Name Type Description Default account Union[str, Keypair, PublicKey] Account to be queried. required before Optional[str] (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. None until Optional[str] (optional) Search until this transaction signature, if found before limit reached. None limit Optional[int] (optoinal) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). None commitment Optional[Commitment] (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_confirmed_signature_for_address2 ( \"Vote111111111111111111111111111111111111111\" , limit = 1 ) { 'jsonrpc' : '2.0' , 'result' : [{ 'err' : None , 'memo' : None , 'signature' : 'v1BK8XcaPBzAGd7TB1K53pMdi6TBGe5CLCgx8cmZ4Bj63ZNvA6ca2QaxFpBFdvmpoFQ51VorBjifkBGLTDhwpqN' , 'slot' : 4290 }], 'id' : 2 } Source code in solana/rpc/api.py def get_confirmed_signature_for_address2 ( self , account : Union [ str , Keypair , PublicKey ], before : Optional [ str ] = None , until : Optional [ str ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optoinal) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_confirmed_signature_for_address2(\"Vote111111111111111111111111111111111111111\", limit=1) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [{'err': None, 'memo': None, 'signature': 'v1BK8XcaPBzAGd7TB1K53pMdi6TBGe5CLCgx8cmZ4Bj63ZNvA6ca2QaxFpBFdvmpoFQ51VorBjifkBGLTDhwpqN', 'slot': 4290}], 'id': 2} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_confirmed_signature_for_address2_args ( account , before , until , limit , commitment ) return self . _provider . make_request ( * args )","title":"get_confirmed_signature_for_address2()"},{"location":"rpc/api/#solana.rpc.api.Client.get_confirmed_transaction","text":"Returns transaction details for a confirmed transaction. Parameters: Name Type Description Default tx_sig str Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the transaction.message.instructions list. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_confirmed_transaction ( \"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\" ) { 'jsonrpc' : '2.0' , 'result' : { 'meta' : { 'err' : None , 'fee' : 5000 , 'postBalances' : [ 498449233720610510 , 1000001001987940 , 1 ], 'preBalances' : [ 498449233721615510 , 1000001000987940 , 1 ], 'status' : { 'Ok' : None }}, 'slot' : 1659335 , 'transaction' : { 'message' : { 'accountKeys' : [ '9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g' , '2KW2XRd9kwqet15Aha2oK3tYvd3nWbTFH1MBiRAv1BE1' , '11111111111111111111111111111111' ], 'header' : { 'numReadonlySignedAccounts' : 0 , 'numReadonlyUnsignedAccounts' : 1 , 'numRequiredSignatures' : 1 }, 'instructions' : [{ 'accounts' : [ 0 , 1 ], 'data' : '3Bxs4Bc3VYuGVB19' , 'programIdIndex' : 2 }], 'recentBlockhash' : 'FwcsKNptGtMLccXAA9YgnivVFK95mKzECLT1DNPi3SDr' }, 'signatures' : [ '3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy' ]}}, 'id' : 4 } Source code in solana/rpc/api.py def get_confirmed_transaction ( self , tx_sig : str , encoding : str = \"json\" ) -> types . RPCResponse : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_confirmed_transaction(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\") # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'meta': {'err': None, 'fee': 5000, 'postBalances': [498449233720610510, 1000001001987940, 1], 'preBalances': [498449233721615510, 1000001000987940, 1], 'status': {'Ok': None}}, 'slot': 1659335, 'transaction': {'message': {'accountKeys': ['9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g', '2KW2XRd9kwqet15Aha2oK3tYvd3nWbTFH1MBiRAv1BE1', '11111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 1, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [0, 1], 'data': '3Bxs4Bc3VYuGVB19', 'programIdIndex': 2}], 'recentBlockhash': 'FwcsKNptGtMLccXAA9YgnivVFK95mKzECLT1DNPi3SDr'}, 'signatures': ['3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy']}}, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_confirmed_transaction_args ( tx_sig , encoding ) return self . _provider . make_request ( * args )","title":"get_confirmed_transaction()"},{"location":"rpc/api/#solana.rpc.api.Client.get_epoch_info","text":"Returns information about the current epoch. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_epoch_info () { 'jsonrpc' : '2.0' , 'result' : { 'absoluteSlot' : 5150 , 'blockHeight' : 5150 , 'epoch' : 0 , 'slotIndex' : 5150 , 'slotsInEpoch' : 8192 }, 'id' : 5 } Source code in solana/rpc/api.py def get_epoch_info ( self , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns information about the current epoch. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_epoch_info() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'absoluteSlot': 5150, 'blockHeight': 5150, 'epoch': 0, 'slotIndex': 5150, 'slotsInEpoch': 8192}, 'id': 5} \"\"\" args = self . _get_epoch_info_args ( commitment , min_context_slot ) return self . _provider . make_request ( * args )","title":"get_epoch_info()"},{"location":"rpc/api/#solana.rpc.api.Client.get_epoch_schedule","text":"Returns epoch schedule information from this cluster's genesis config. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_epoch_schedule () { 'jsonrpc' : '2.0' , 'result' : { 'firstNormalEpoch' : 0 , 'firstNormalSlot' : 0 , 'leaderScheduleSlotOffset' : 8192 , 'slotsPerEpoch' : 8192 , 'warmup' : False }, 'id' : 6 } Source code in solana/rpc/api.py def get_epoch_schedule ( self ) -> types . RPCResponse : \"\"\"Returns epoch schedule information from this cluster's genesis config. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_epoch_schedule() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'firstNormalEpoch': 0, 'firstNormalSlot': 0, 'leaderScheduleSlotOffset': 8192, 'slotsPerEpoch': 8192, 'warmup': False}, 'id': 6} \"\"\" return self . _provider . make_request ( self . _get_epoch_schedule )","title":"get_epoch_schedule()"},{"location":"rpc/api/#solana.rpc.api.Client.get_fee_calculator_for_blockhash","text":"Returns the fee calculator associated with the query blockhash, or null if the blockhash has expired. Parameters: Name Type Description Default blockhash Union[str, Blockhash] Blockhash to query as a Base58 encoded string. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_fee_calculator_for_blockhash ( \"BaQSR194dC4dZaRxATtxYyEwDkk7VgqUY8NVNkub8HFZ\" ) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 7065 }, 'value' : { 'feeCalculator' : { 'lamportsPerSignature' : 5000 }}}, 'id' : 4 } Source code in solana/rpc/api.py def get_fee_calculator_for_blockhash ( self , blockhash : Union [ str , Blockhash ], commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the fee calculator associated with the query blockhash, or null if the blockhash has expired. Args: blockhash: Blockhash to query as a Base58 encoded string. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_fee_calculator_for_blockhash(\"BaQSR194dC4dZaRxATtxYyEwDkk7VgqUY8NVNkub8HFZ\") # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 7065}, 'value': {'feeCalculator': {'lamportsPerSignature': 5000}}}, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_fee_calculator_for_blockhash_args ( blockhash , commitment ) return self . _provider . make_request ( * args )","title":"get_fee_calculator_for_blockhash()"},{"location":"rpc/api/#solana.rpc.api.Client.get_fee_for_message","text":"Get the fee the network will charge for a particular Message NEW: This method is only available in solana-core v1.9 or newer. Please use getRecentBlockhash for solana-core v1.8 Parameters: Name Type Description Default message str Base-64 encoded Message required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: solana_client = Client(\"http://localhost:8899\") solana_client.get_fee_for_message( 'AQABAgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQAA' ) Source code in solana/rpc/api.py def get_fee_for_message ( self , message : str , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Get the fee the network will charge for a particular Message NEW: This method is only available in solana-core v1.9 or newer. Please use getRecentBlockhash for solana-core v1.8 Args: message: Base-64 encoded Message commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: solana_client = Client(\"http://localhost:8899\") solana_client.get_fee_for_message( 'AQABAgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQAA' ) \"\"\" args = self . _get_fee_for_message_args ( message , commitment ) return self . _provider . make_request ( * args )","title":"get_fee_for_message()"},{"location":"rpc/api/#solana.rpc.api.Client.get_fee_rate_governor","text":"Returns the fee rate governor information from the root bank. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_fee_rate_governor () { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 7172 }, 'value' : { 'feeRateGovernor' : { 'burnPercent' : 50 , 'maxLamportsPerSignature' : 100000 , 'minLamportsPerSignature' : 5000 , 'targetLamportsPerSignature' : 10000 , 'targetSignaturesPerSlot' : 20000 }}}, 'id' : 5 } Source code in solana/rpc/api.py def get_fee_rate_governor ( self ) -> types . RPCResponse : \"\"\"Returns the fee rate governor information from the root bank. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_fee_rate_governor() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 7172}, 'value': {'feeRateGovernor': {'burnPercent': 50, 'maxLamportsPerSignature': 100000, 'minLamportsPerSignature': 5000, 'targetLamportsPerSignature': 10000, 'targetSignaturesPerSlot': 20000}}}, 'id': 5} \"\"\" return self . _provider . make_request ( self . _get_fee_rate_governor )","title":"get_fee_rate_governor()"},{"location":"rpc/api/#solana.rpc.api.Client.get_fees","text":"Returns a recent block hash from the ledger, a fee schedule and the last slot the blockhash will be valid. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_fees () { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 7727 }, 'value' : { 'blockhash' : 'GGS6AEDqjF5irU6D6VQNherEZ2hckGaeBiVdfSZKg4gd' , 'feeCalculator' : { 'lamportsPerSignature' : 5000 }, 'lastValidSlot' : 8027 }}, 'id' : 1 } Source code in solana/rpc/api.py def get_fees ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns a recent block hash from the ledger, a fee schedule and the last slot the blockhash will be valid. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_fees() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 7727}, 'value': {'blockhash': 'GGS6AEDqjF5irU6D6VQNherEZ2hckGaeBiVdfSZKg4gd', 'feeCalculator': {'lamportsPerSignature': 5000}, 'lastValidSlot': 8027}}, 'id': 1} \"\"\" args = self . _get_fees_args ( commitment ) return self . _provider . make_request ( * args )","title":"get_fees()"},{"location":"rpc/api/#solana.rpc.api.Client.get_first_available_block","text":"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_fees () { 'jsonrpc' : '2.0' , 'result' : 1 , 'id' : 2 } Source code in solana/rpc/api.py def get_first_available_block ( self ) -> types . RPCResponse : \"\"\"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_fees() # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1, 'id': 2} \"\"\" return self . _provider . make_request ( self . _get_first_available_block )","title":"get_first_available_block()"},{"location":"rpc/api/#solana.rpc.api.Client.get_genesis_hash","text":"Returns the genesis hash. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_genesis_hash () { 'jsonrpc' : '2.0' , 'result' : 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2' , 'id' : 3 } Source code in solana/rpc/api.py def get_genesis_hash ( self ) -> types . RPCResponse : \"\"\"Returns the genesis hash. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_genesis_hash() # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'id': 3} \"\"\" return self . _provider . make_request ( self . _get_genesis_hash )","title":"get_genesis_hash()"},{"location":"rpc/api/#solana.rpc.api.Client.get_health","text":"Returns the current health of the node. solana_client = Client(\"http://localhost:8899\") solana_client.get_health() # doctest: +SKIP Healthy result: {\"jsonrpc\":\"2.0\", \"result\": \"ok\", \"id\":1} Source code in solana/rpc/api.py def get_health ( self ) -> types . RPCResponse : \"\"\"Returns the current health of the node. >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_health() # doctest: +SKIP Healthy result: {\"jsonrpc\":\"2.0\", \"result\": \"ok\", \"id\":1} \"\"\" return self . _provider . make_request ( self . _get_health )","title":"get_health()"},{"location":"rpc/api/#solana.rpc.api.Client.get_highest_snapshot_slot","text":"Returns the highest slot information that the node has snapshots for. This will find the highest full snapshot slot, and the highest incremental snapshot slot based on the full snapshot slot, if there is one. solana_client = Client(\"http://localhost:8899\") solana_client.get_highest_snapshot_slot() Source code in solana/rpc/api.py def get_highest_snapshot_slot ( self ) -> types . RPCResponse : \"\"\" Returns the highest slot information that the node has snapshots for. This will find the highest full snapshot slot, and the highest incremental snapshot slot based on the full snapshot slot, if there is one. solana_client = Client(\"http://localhost:8899\") solana_client.get_highest_snapshot_slot() \"\"\" return self . _provider . make_request ( types . RPCMethod ( \"getHighestSnapshotSlot\" ), )","title":"get_highest_snapshot_slot()"},{"location":"rpc/api/#solana.rpc.api.Client.get_identity","text":"Returns the identity pubkey for the current node. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_identity () { 'jsonrpc' : '2.0' , 'result' : { 'identity' : 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk' }, 'id' : 4 } Source code in solana/rpc/api.py def get_identity ( self ) -> types . RPCResponse : \"\"\"Returns the identity pubkey for the current node. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_identity() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'identity': 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk'}, 'id': 4} \"\"\" return self . _provider . make_request ( self . _get_identity )","title":"get_identity()"},{"location":"rpc/api/#solana.rpc.api.Client.get_inflation_governor","text":"Returns the current inflation governor. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_inflation_governor () { 'jsonrpc' : '2.0' , 'result' : { 'foundation' : 0.05 , 'foundationTerm' : 7.0 , 'initial' : 0.15 , 'taper' : 0.15 , 'terminal' : 0.015 }, 'id' : 5 } Source code in solana/rpc/api.py def get_inflation_governor ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the current inflation governor. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_governor() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'foundation': 0.05, 'foundationTerm': 7.0, 'initial': 0.15, 'taper': 0.15, 'terminal': 0.015}, 'id': 5} \"\"\" args = self . _get_inflation_governor_args ( commitment ) return self . _provider . make_request ( * args )","title":"get_inflation_governor()"},{"location":"rpc/api/#solana.rpc.api.Client.get_inflation_rate","text":"Returns the specific inflation values for the current epoch. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_inflation_rate () { 'jsonrpc' : '2.0' , 'result' : { 'epoch' : 1 , 'foundation' : 0.007499746885736559 , 'total' : 0.14999493771473116 , 'validator' : 0.1424951908289946 }, 'id' : 1 } Source code in solana/rpc/api.py def get_inflation_rate ( self ) -> types . RPCResponse : \"\"\"Returns the specific inflation values for the current epoch. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_rate() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'epoch': 1, 'foundation': 0.007499746885736559, 'total': 0.14999493771473116, 'validator': 0.1424951908289946}, 'id': 1} \"\"\" return self . _provider . make_request ( self . _get_inflation_rate )","title":"get_inflation_rate()"},{"location":"rpc/api/#solana.rpc.api.Client.get_inflation_reward","text":"Returns the inflation reward for a list of addresses for an epoch. :param address_list: An array of addresses to query, as base-58 encoded strings :param commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". :param epoch: An epoch for which the reward occurs. If omitted, the previous epoch will be used solana_client = Client(\"http://localhost:8899\") solana_client.get_inflation_reward(address_list) # doctest: +SKIP { \"jsonrpc\": \"2.0\", \"result\": [ { \"amount\": 2500, \"effectiveSlot\": 224, \"epoch\": 2, \"postBalance\": 499999442500 }, null ], \"id\": 1 } Source code in solana/rpc/api.py def get_inflation_reward ( self , address_list : List [ Union [ str , PublicKey ]], commitment : Optional [ Commitment ] = None , epoch : Optional [ int ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns the inflation reward for a list of addresses for an epoch. :param address_list: An array of addresses to query, as base-58 encoded strings :param commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". :param epoch: An epoch for which the reward occurs. If omitted, the previous epoch will be used >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_reward(address_list) # doctest: +SKIP { \"jsonrpc\": \"2.0\", \"result\": [ { \"amount\": 2500, \"effectiveSlot\": 224, \"epoch\": 2, \"postBalance\": 499999442500 }, null ], \"id\": 1 } \"\"\" args = self . _get_inflation_reward_args ( address_list = address_list , commitment = commitment , epoch = epoch , min_context_slot = min_context_slot , ) return self . _provider . make_request ( * args )","title":"get_inflation_reward()"},{"location":"rpc/api/#solana.rpc.api.Client.get_largest_accounts","text":"Returns the 20 largest accounts, by lamport balance. Parameters: Name Type Description Default filter_opt Optional[str] Filter results by account type; currently supported: circulating|nonCirculating. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_largest_accounts () { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 8890 }, 'value' : [{ 'address' : '95L7AsBCLRsqghsi6ksZkzjNbs6rqDgHCzKaGZ7bJi75' , 'lamports' : 500000000000000000 }, { 'address' : 'APnSR52EC1eH676m7qTBHUJ1nrGpHYpV7XKPxgRDD8gX' , 'lamports' : 164511033098290000 }, { 'address' : '13LeFbG6m2EP1fqCj9k66fcXsoTHMMtgr7c78AivUrYD' , 'lamports' : 153333632446109120 }, { 'address' : 'GK2zqSsXLA2rwVZk347RYhh6jJpRsCA69FjLW93ZGi3B' , 'lamports' : 57499999036109120 }, { 'address' : '8HVqyX9jebh31Q9Hp8t5sMVJs665979ZeEr3eCfzitUe' , 'lamports' : 30301031036109120 }, { 'address' : 'HbZ5FfmKWNHC7uwk6TF1hVi6TCs7dtYfdjEcuPGgzFAg' , 'lamports' : 14999999036109120 }, { 'address' : '14FUT96s9swbmH7ZjpDvfEDywnAYy9zaNhv4xvezySGu' , 'lamports' : 4999999036109120 }, { 'address' : '9huDUZfxoJ7wGMTffUE7vh1xePqef7gyrLJu9NApncqA' , 'lamports' : 4999999036109120 }, { 'address' : 'C7C8odR8oashR5Feyrq2tJKaXL18id1dSj2zbkDGL2C2' , 'lamports' : 4999999036109120 }, { 'address' : 'AYgECURrvuX6GtFe4tX7aAj87Xc5r5Znx96ntNk1nCv' , 'lamports' : 2499999518054560 }, { 'address' : 'AogcwQ1ubM76EPMhSD5cw1ES4W5econvQCFmBL6nTW1' , 'lamports' : 2499999518054560 }, { 'address' : 'gWgqQ4udVxE3uNxRHEwvftTHwpEmPHAd8JR9UzaHbR2' , 'lamports' : 2499999518054560 }, { 'address' : '3D91zLQPRLamwJfGR5ZYMKQb4C18gsJNaSdmB6b2wLhw' , 'lamports' : 2499999518054560 }, { 'address' : '3bHbMa5VW3np5AJazuacidrN4xPZgwhcXigmjwHmBg5e' , 'lamports' : 2499999518054560 }, { 'address' : '4U3RFq7X5kLG6tZ9kcksFL8oXeGNjtuUN1YfkVKXbs5x' , 'lamports' : 2499999518054560 }, { 'address' : '5cBVGBKY6kBaiTVmsQpxThJ2oqitBYuCAX9Zm2zMuV4y' , 'lamports' : 2499999518054560 }, { 'address' : '8PjJTv657aeN9p5R2WoM6pPSz385chvTTytUWaEjSjkq' , 'lamports' : 2499999518054560 }, { 'address' : 'AHB94zKUASftTdqgdfiDSdnPJHkEFp7zX3yMrcSxABsv' , 'lamports' : 2499999518054560 }, { 'address' : 'Hc36Wh1ZqYGzGAnsJWNT9r2gY3h9n89uDpxZPsmEsiE3' , 'lamports' : 2499999518054560 }, { 'address' : 'GxyRKP2eVKACaSSnso4VLSAjZKmHsFXHWUfS3A5CtiMA' , 'lamports' : 1940147018054560 }]}, 'id' : 2 } Source code in solana/rpc/api.py def get_largest_accounts ( self , filter_opt : Optional [ str ] = None , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the 20 largest accounts, by lamport balance. Args: filter_opt: Filter results by account type; currently supported: circulating|nonCirculating. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_largest_accounts() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 8890}, 'value': [{'address': '95L7AsBCLRsqghsi6ksZkzjNbs6rqDgHCzKaGZ7bJi75', 'lamports': 500000000000000000}, {'address': 'APnSR52EC1eH676m7qTBHUJ1nrGpHYpV7XKPxgRDD8gX', 'lamports': 164511033098290000}, {'address': '13LeFbG6m2EP1fqCj9k66fcXsoTHMMtgr7c78AivUrYD', 'lamports': 153333632446109120}, {'address': 'GK2zqSsXLA2rwVZk347RYhh6jJpRsCA69FjLW93ZGi3B', 'lamports': 57499999036109120}, {'address': '8HVqyX9jebh31Q9Hp8t5sMVJs665979ZeEr3eCfzitUe', 'lamports': 30301031036109120}, {'address': 'HbZ5FfmKWNHC7uwk6TF1hVi6TCs7dtYfdjEcuPGgzFAg', 'lamports': 14999999036109120}, {'address': '14FUT96s9swbmH7ZjpDvfEDywnAYy9zaNhv4xvezySGu', 'lamports': 4999999036109120}, {'address': '9huDUZfxoJ7wGMTffUE7vh1xePqef7gyrLJu9NApncqA', 'lamports': 4999999036109120}, {'address': 'C7C8odR8oashR5Feyrq2tJKaXL18id1dSj2zbkDGL2C2', 'lamports': 4999999036109120}, {'address': 'AYgECURrvuX6GtFe4tX7aAj87Xc5r5Znx96ntNk1nCv', 'lamports': 2499999518054560}, {'address': 'AogcwQ1ubM76EPMhSD5cw1ES4W5econvQCFmBL6nTW1', 'lamports': 2499999518054560}, {'address': 'gWgqQ4udVxE3uNxRHEwvftTHwpEmPHAd8JR9UzaHbR2', 'lamports': 2499999518054560}, {'address': '3D91zLQPRLamwJfGR5ZYMKQb4C18gsJNaSdmB6b2wLhw', 'lamports': 2499999518054560}, {'address': '3bHbMa5VW3np5AJazuacidrN4xPZgwhcXigmjwHmBg5e', 'lamports': 2499999518054560}, {'address': '4U3RFq7X5kLG6tZ9kcksFL8oXeGNjtuUN1YfkVKXbs5x', 'lamports': 2499999518054560}, {'address': '5cBVGBKY6kBaiTVmsQpxThJ2oqitBYuCAX9Zm2zMuV4y', 'lamports': 2499999518054560}, {'address': '8PjJTv657aeN9p5R2WoM6pPSz385chvTTytUWaEjSjkq', 'lamports': 2499999518054560}, {'address': 'AHB94zKUASftTdqgdfiDSdnPJHkEFp7zX3yMrcSxABsv', 'lamports': 2499999518054560}, {'address': 'Hc36Wh1ZqYGzGAnsJWNT9r2gY3h9n89uDpxZPsmEsiE3', 'lamports': 2499999518054560}, {'address': 'GxyRKP2eVKACaSSnso4VLSAjZKmHsFXHWUfS3A5CtiMA', 'lamports': 1940147018054560}]}, 'id': 2} \"\"\" args = self . _get_largest_accounts_args ( filter_opt , commitment ) return self . _provider . make_request ( * args )","title":"get_largest_accounts()"},{"location":"rpc/api/#solana.rpc.api.Client.get_latest_blockhash","text":"Returns the latest block hash from the ledger. Response also includes the last valid block height. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_latest_blockhash () { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 1637 }, 'value' : { 'blockhash' : 'EALChog1mXQ9nEgEUQpWAtmA5UueUZvZiL16ZivmR7eb' , 'lastValidBlockHeight' : 3090 }}, 'id' : 2 } Source code in solana/rpc/api.py def get_latest_blockhash ( self , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns the latest block hash from the ledger. Response also includes the last valid block height. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_latest_blockhash() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 1637}, 'value': {'blockhash': 'EALChog1mXQ9nEgEUQpWAtmA5UueUZvZiL16ZivmR7eb', 'lastValidBlockHeight': 3090}}, 'id': 2} \"\"\" args = self . _get_latest_blockhash_args ( commitment , min_context_slot ) return self . _provider . make_request ( * args )","title":"get_latest_blockhash()"},{"location":"rpc/api/#solana.rpc.api.Client.get_leader_schedule","text":"Returns the leader schedule for an epoch. Parameters: Name Type Description Default epoch Optional[int] Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_leader_schedule () { 'jsonrpc' : '2.0' , 'result' : { 'EWj2cuEuVhi7RX81cnAY3TzpyFwnHzzVwvuTyfmxmhs3' : [ 0 , 1 , 2 , 3 , 4 , 5 , ... ]}, 'id' : 6 } Source code in solana/rpc/api.py def get_leader_schedule ( self , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the leader schedule for an epoch. Args: epoch: Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_leader_schedule() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'EWj2cuEuVhi7RX81cnAY3TzpyFwnHzzVwvuTyfmxmhs3': [0, 1, 2, 3, 4, 5, ...]}, 'id': 6} \"\"\" args = self . _get_leader_schedule_args ( epoch , commitment ) return self . _provider . make_request ( * args )","title":"get_leader_schedule()"},{"location":"rpc/api/#solana.rpc.api.Client.get_max_retransmit_slot","text":"Get the max slot seen from retransmit stage. Examples: solana_client = Client(\"http://localhost:8899\") solana_client.get_max_retransmit_slot() Source code in solana/rpc/api.py def get_max_retransmit_slot ( self ) -> types . RPCResponse : \"\"\" Get the max slot seen from retransmit stage. Example: solana_client = Client(\"http://localhost:8899\") solana_client.get_max_retransmit_slot() \"\"\" return self . _provider . make_request ( types . RPCMethod ( \"getMaxRetransmitSlot\" ), )","title":"get_max_retransmit_slot()"},{"location":"rpc/api/#solana.rpc.api.Client.get_max_shred_insert_slot","text":"Get the max slot seen from after shred insert. solana_client = Client(\"http://localhost:8899\") solana_client.get_max_shred_insert_slot() Source code in solana/rpc/api.py def get_max_shred_insert_slot ( self ) -> types . RPCResponse : \"\"\" Get the max slot seen from after shred insert. solana_client = Client(\"http://localhost:8899\") solana_client.get_max_shred_insert_slot() \"\"\" return self . _provider . make_request ( types . RPCMethod ( \"getMaxShredInsertSlot\" ), )","title":"get_max_shred_insert_slot()"},{"location":"rpc/api/#solana.rpc.api.Client.get_minimum_balance_for_rent_exemption","text":"Returns minimum balance required to make account rent exempt. Parameters: Name Type Description Default usize int Account data length. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_minimum_balance_for_rent_exemption ( 50 ) { 'jsonrpc' : '2.0' , 'result' : 1238880 , 'id' : 7 } Source code in solana/rpc/api.py def get_minimum_balance_for_rent_exemption ( self , usize : int , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns minimum balance required to make account rent exempt. Args: usize: Account data length. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_minimum_balance_for_rent_exemption(50) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1238880, 'id': 7} \"\"\" args = self . _get_minimum_balance_for_rent_exemption_args ( usize , commitment ) return self . _provider . make_request ( * args )","title":"get_minimum_balance_for_rent_exemption()"},{"location":"rpc/api/#solana.rpc.api.Client.get_minimum_ledger_slot","text":"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_minimum_ledger_slot () { 'jsonrpc' : '2.0' , 'result' : 1234 , 'id' : 1 } Source code in solana/rpc/api.py def get_minimum_ledger_slot ( self ) -> types . RPCResponse : \"\"\"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_minimum_ledger_slot() # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1234, 'id': 1} \"\"\" return self . _provider . make_request ( self . _minimum_ledger_slot )","title":"get_minimum_ledger_slot()"},{"location":"rpc/api/#solana.rpc.api.Client.get_multiple_accounts","text":"Returns all the account info for a list of public keys. Parameters: Name Type Description Default pubkeys List[Union[PublicKey, str]] list of Pubkeys to query, as base-58 encoded string or PublicKey object. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding str (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". \"base58\" is limited to Account data of less than 128 bytes. \"base64\" will return base64 encoded data for Account data of any size. \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). 'base64' data_slice Optional[types.DataSliceOpts] (optional) Option to limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None Examples: >>> from solana.publickey import PublicKey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> pubkeys = [ PublicKey ( \"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\" ), PublicKey ( \"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\" )] >>> solana_client . get_multiple_accounts ( pubkeys ) { \"jsonrpc\" : \"2.0\" , \"result\" : { \"context\" : { \"slot\" : 97531946 }, \"value\" : [ { \"data\" : [ \"\" , \"base64\" ], \"executable\" : False , \"lamports\" : 1 , \"owner\" : \"11111111111111111111111111111111\" , \"rentEpoch\" : 225 , }, { \"data\" : [ \"\" , \"base64\" ], \"executable\" : False , \"lamports\" : 809441127 , \"owner\" : \"11111111111111111111111111111111\" , \"rentEpoch\" : 225 , }, ], }, \"id\" : 1 , } Source code in solana/rpc/api.py def get_multiple_accounts ( self , pubkeys : List [ Union [ PublicKey , str ]], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. - \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solana.publickey import PublicKey >>> solana_client = Client(\"http://localhost:8899\") >>> pubkeys = [PublicKey(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), PublicKey(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> solana_client.get_multiple_accounts(pubkeys) # doctest: +SKIP { \"jsonrpc\": \"2.0\", \"result\": { \"context\": {\"slot\": 97531946}, \"value\": [ { \"data\": [\"\", \"base64\"], \"executable\": False, \"lamports\": 1, \"owner\": \"11111111111111111111111111111111\", \"rentEpoch\": 225, }, { \"data\": [\"\", \"base64\"], \"executable\": False, \"lamports\": 809441127, \"owner\": \"11111111111111111111111111111111\", \"rentEpoch\": 225, }, ], }, \"id\": 1, } \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_multiple_accounts_args ( pubkeys = pubkeys , commitment = commitment , encoding = encoding , data_slice = data_slice , min_context_slot = min_context_slot , ) return self . _provider . make_request ( * args )","title":"get_multiple_accounts()"},{"location":"rpc/api/#solana.rpc.api.Client.get_program_accounts","text":"Returns all accounts owned by the provided program Pubkey. Parameters: Name Type Description Default pubkey Union[str, PublicKey] Pubkey of program, as base-58 encoded string or PublicKey object. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". 'finalized' encoding Optional[str] (optional) Encoding for the returned Transaction, either jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. None data_slice Optional[types.DataSliceOpts] (optional) Limit the returned account data using the provided offset : and None ` length` fields; only available for \"base58\" or \"base64\" encoding. required data_size Optional[int] (optional) Option to compare the program account data length with the provided data size. None memcmp_opts Optional[List[types.MemcmpOpts]] (optional) Options to compare a provided series of bytes with program account data at a particular offset. None with_context Optional[bool] (optional ) Option to wrap the result in an RpcResponse JSON object. None min_context_slot Optional[int] (optional ) set the minimum slot that the request can be evaluated at None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> memcmp_opts = [ ... MemcmpOpt ( offset = 4 , bytes = \"3Mc6vR\" ), ... ] >>> solana_client . get_program_accounts ( \"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\" , data_size = 17 , memcmp_opts = memcmp_opts ) { 'jsonrpc' : \"2.0\" , 'result' :[{ 'account' :{ 'data' : '2R9jLfiAQ9bgdcw6h8s44439' , 'executable' : false , 'lamports' : 15298080 , 'owner' : '4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T' , 'rentEpoch' : 28 }, 'pubkey' : 'CxELquR1gPP8wHe33gZ4QxqGB3sZ9RSwsJ2KshVewkFY' }], 'id' : 1 } Source code in solana/rpc/api.py def get_program_accounts ( # pylint: disable=too-many-arguments self , pubkey : Union [ str , PublicKey ], commitment : Optional [ Commitment ] = Finalized , encoding : Optional [ str ] = None , data_slice : Optional [ types . DataSliceOpts ] = None , data_size : Optional [ int ] = None , memcmp_opts : Optional [ List [ types . MemcmpOpts ]] = None , with_context : Optional [ bool ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for the returned Transaction, either jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and ` length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. data_size: (optional) Option to compare the program account data length with the provided data size. memcmp_opts: (optional) Options to compare a provided series of bytes with program account data at a particular offset. with_context: (optional ) Option to wrap the result in an RpcResponse JSON object. min_context_slot: (optional ) set the minimum slot that the request can be evaluated at Example: >>> solana_client = Client(\"http://localhost:8899\") >>> memcmp_opts = [ ... MemcmpOpt(offset=4, bytes=\"3Mc6vR\"), ... ] >>> solana_client.get_program_accounts(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\", data_size=17, memcmp_opts=memcmp_opts) # doctest: +SKIP {'jsonrpc': \"2.0\", 'result' :[{ 'account' :{ 'data' :'2R9jLfiAQ9bgdcw6h8s44439', 'executable' :false, 'lamports' :15298080, 'owner' :'4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T', 'rentEpoch' :28}, 'pubkey' :'CxELquR1gPP8wHe33gZ4QxqGB3sZ9RSwsJ2KshVewkFY'}], 'id' :1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_program_accounts_args ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , data_size = data_size , memcmp_opts = memcmp_opts , with_context = with_context , min_context_slot = min_context_slot , ) return self . _provider . make_request ( * args )","title":"get_program_accounts()"},{"location":"rpc/api/#solana.rpc.api.Client.get_recent_blockhash","text":"Returns a recent block hash from the ledger. Response also includes a fee schedule that can be used to compute the cost of submitting a transaction using it. Deprecated, please use get_latest_blockhash() instead. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_recent_blockhash () { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 1637 }, 'value' : { 'blockhash' : 'EALChog1mXQ9nEgEUQpWAtmA5UueUZvZiL16ZivmR7eb' , 'feeCalculator' : { 'lamportsPerSignature' : 5000 }}}, 'id' : 2 } Source code in solana/rpc/api.py def get_recent_blockhash ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns a recent block hash from the ledger. Response also includes a fee schedule that can be used to compute the cost of submitting a transaction using it. Deprecated, please use get_latest_blockhash() instead. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_recent_blockhash() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 1637}, 'value': {'blockhash': 'EALChog1mXQ9nEgEUQpWAtmA5UueUZvZiL16ZivmR7eb', 'feeCalculator': {'lamportsPerSignature': 5000}}}, 'id': 2} \"\"\" args = self . _get_recent_blockhash_args ( commitment ) return self . _provider . make_request ( * args )","title":"get_recent_blockhash()"},{"location":"rpc/api/#solana.rpc.api.Client.get_recent_performance_samples","text":"Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Parameters: Name Type Description Default limit Optional[int] - (optional) number of samples to return (maximum 720) None Examples: solana_client = Client(\"http://localhost:8899\") solana_client.get_recent_performance_samples() solana_client.get_recent_performance_samples(5) Source code in solana/rpc/api.py def get_recent_performance_samples ( self , limit : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\" Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Parameters: limit: <usize> - (optional) number of samples to return (maximum 720) Example: solana_client = Client(\"http://localhost:8899\") solana_client.get_recent_performance_samples() solana_client.get_recent_performance_samples(5) \"\"\" args = self . _get_recent_performance_samples_args ( limit ) return self . _provider . make_request ( * args )","title":"get_recent_performance_samples()"},{"location":"rpc/api/#solana.rpc.api.Client.get_signature_statuses","text":"Returns the statuses of a list of signatures. Unless the search_transaction_history configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus MAX_RECENT_BLOCKHASHES rooted slots. Parameters: Name Type Description Default signatures List[Union[str, bytes]] An array of transaction signatures to confirm. required search_transaction_history bool If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. False Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> signatures = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\" , ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\" ] >>> solana_client . get_signature_statuses ( signatures ) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 82 }, 'value' : [{ 'slot' : 72 , 'confirmations' : 10 , 'err' : null , 'status' : { 'Ok' : null }}, null ]}, 'id' : 1 } Source code in solana/rpc/api.py def get_signature_statuses ( self , signatures : List [ Union [ str , bytes ]], search_transaction_history : bool = False ) -> types . RPCResponse : \"\"\"Returns the statuses of a list of signatures. Unless the `search_transaction_history` configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus `MAX_RECENT_BLOCKHASHES` rooted slots. Args: signatures: An array of transaction signatures to confirm. search_transaction_history: If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> signatures = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\", ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\"] >>> solana_client.get_signature_statuses(signatures) # doctest: +SKIP {'jsonrpc': '2.0', 'result': { 'context': {'slot':82}, 'value': [{ 'slot': 72, 'confirmations': 10, 'err': null, 'status': {'Ok': null}}, null]}, 'id': 1} \"\"\" args = self . _get_signature_statuses_args ( signatures , search_transaction_history ) return self . _provider . make_request ( * args )","title":"get_signature_statuses()"},{"location":"rpc/api/#solana.rpc.api.Client.get_signatures_for_address","text":"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Parameters: Name Type Description Default account Union[str, Keypair, PublicKey] Account to be queried. required before Optional[str] (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. None until Optional[str] (optional) Search until this transaction signature, if found before limit reached. None limit Optional[int] (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). None commitment Optional[Commitment] (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_signatures_for_address ( \"Vote111111111111111111111111111111111111111\" , limit = 1 ) { 'jsonrpc' : '2.0' , 'result' : [{ 'err' : None , 'memo' : None , 'signature' : 'v1BK8XcaPBzAGd7TB1K53pMdi6TBGe5CLCgx8cmZ4Bj63ZNvA6ca2QaxFpBFdvmpoFQ51VorBjifkBGLTDhwpqN' , 'slot' : 4290 }], 'id' : 2 } Source code in solana/rpc/api.py def get_signatures_for_address ( self , account : Union [ str , Keypair , PublicKey ], before : Optional [ str ] = None , until : Optional [ str ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_signatures_for_address(\"Vote111111111111111111111111111111111111111\", limit=1) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [{'err': None, 'memo': None, 'signature': 'v1BK8XcaPBzAGd7TB1K53pMdi6TBGe5CLCgx8cmZ4Bj63ZNvA6ca2QaxFpBFdvmpoFQ51VorBjifkBGLTDhwpqN', 'slot': 4290}], 'id': 2} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_signatures_for_address_args ( account , before , until , limit , commitment , min_context_slot , ) return self . _provider . make_request ( * args )","title":"get_signatures_for_address()"},{"location":"rpc/api/#solana.rpc.api.Client.get_slot","text":"Returns the current slot the node is processing. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_slot () { 'jsonrpc' : '2.0' , 'result' : 7515 , 'id' : 1 } Source code in solana/rpc/api.py def get_slot ( self , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns the current slot the node is processing. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_slot() # doctest: +SKIP {'jsonrpc': '2.0', 'result': 7515, 'id': 1} \"\"\" args = self . _get_slot_args ( commitment , min_context_slot ) return self . _provider . make_request ( * args )","title":"get_slot()"},{"location":"rpc/api/#solana.rpc.api.Client.get_slot_leader","text":"Returns the current slot leader. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_slot_leader () { 'jsonrpc' : '2.0' , 'result' : 'EWj2cuEuVhi7RX81cnAY3TzpyFwnHzzVwvuTyfmxmhs3' , 'id' : 1 } Source code in solana/rpc/api.py def get_slot_leader ( self , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns the current slot leader. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_slot_leader() # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'EWj2cuEuVhi7RX81cnAY3TzpyFwnHzzVwvuTyfmxmhs3', 'id': 1} \"\"\" args = self . _get_slot_leader_args ( commitment , min_context_slot ) return self . _provider . make_request ( * args )","title":"get_slot_leader()"},{"location":"rpc/api/#solana.rpc.api.Client.get_slot_leaders","text":"Returns the slot leaders for a given slot range Examples: solana_client = Client(\"http://localhost:8899\") solana_client.get_slot_leaders(126411503, 5) Source code in solana/rpc/api.py def get_slot_leaders ( self , start_slot : int , limit : int ) -> types . RPCResponse : \"\"\" Returns the slot leaders for a given slot range Parameters: <u64> - start_slot, as u64 integer <u64> - limit, as u64 integer Example: solana_client = Client(\"http://localhost:8899\") solana_client.get_slot_leaders(126411503, 5) \"\"\" args = self . _get_slot_leaders_args ( start_slot , limit ) return self . _provider . make_request ( * args )","title":"get_slot_leaders()"},{"location":"rpc/api/#solana.rpc.api.Client.get_stake_activation","text":"Returns epoch activation information for a stake account. Parameters: Name Type Description Default pubkey Union[PublicKey, str] Pubkey of stake account to query, as base-58 encoded string or PublicKey object. required epoch Optional[int] (optional) Epoch for which to calculate activation details. If parameter not provided, defaults to current epoch. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None min_context_slot Optional[int] set the minimum slot that the request can be evaluated at None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_stake_activation () { 'jsonrpc' : '2.0' , 'result' : { 'active' : 124429280 , 'inactive' : 73287840 , 'state' : 'activating' }, 'id' : 1 }} Source code in solana/rpc/api.py def get_stake_activation ( self , pubkey : Union [ PublicKey , str ], epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns epoch activation information for a stake account. Args: pubkey: Pubkey of stake account to query, as base-58 encoded string or PublicKey object. epoch: (optional) Epoch for which to calculate activation details. If parameter not provided, defaults to current epoch. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". min_context_slot: set the minimum slot that the request can be evaluated at Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_stake_activation() # doctest: +SKIP {'jsonrpc': '2.0','result': {'active': 124429280, 'inactive': 73287840, 'state': 'activating'}, 'id': 1}} \"\"\" args = self . _get_stake_activation_args ( pubkey , epoch , commitment , min_context_slot , ) return self . _provider . make_request ( * args )","title":"get_stake_activation()"},{"location":"rpc/api/#solana.rpc.api.Client.get_supply","text":"Returns information about the current supply. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_supply () { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 3846 }, 'value' : { 'circulating' : 683635192454157660 , 'nonCirculating' : 316364808037127120 , 'nonCirculatingAccounts' : [ 'ETfDYz7Cg5p9SDFmdpRerjBN5puKK7xydEBZZGM2V4Ay' , '7cKxv6UznFoWRuJkgw5bWj5rp5PiKTcXZeEaLqyd3Bbm' , 'CV7qh8ZoqeUSTQagosGpkLptXoojf9yCszxkRx1jTD12' , 'FZ9S7X9jMbCaMyJjRfSoBhFyarUMVwvx7HWRe4LnZHsg' , ... ] 'total' : 1000000000491284780 }}, 'id' : 1 } Source code in solana/rpc/api.py def get_supply ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns information about the current supply. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_supply() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 3846}, 'value': {'circulating': 683635192454157660, 'nonCirculating': 316364808037127120, 'nonCirculatingAccounts': ['ETfDYz7Cg5p9SDFmdpRerjBN5puKK7xydEBZZGM2V4Ay', '7cKxv6UznFoWRuJkgw5bWj5rp5PiKTcXZeEaLqyd3Bbm', 'CV7qh8ZoqeUSTQagosGpkLptXoojf9yCszxkRx1jTD12', 'FZ9S7X9jMbCaMyJjRfSoBhFyarUMVwvx7HWRe4LnZHsg', ...] 'total': 1000000000491284780}}, 'id': 1} \"\"\" args = self . _get_supply_args ( commitment ) return self . _provider . make_request ( * args )","title":"get_supply()"},{"location":"rpc/api/#solana.rpc.api.Client.get_token_account_balance","text":"Returns the token balance of an SPL Token account (UNSTABLE). Parameters: Name Type Description Default pubkey Union[str, PublicKey] Pubkey of Token account to query, as base-58 encoded string or PublicKey object. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_token_account_balance ( \"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\" ) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 1114 }, 'value' : { 'uiAmount' : 98.64 , 'amount' : '9864' , 'decimals' : 2 }, 'id' : 1 } Source code in solana/rpc/api.py def get_token_account_balance ( self , pubkey : Union [ str , PublicKey ], commitment : Optional [ Commitment ] = None ): \"\"\"Returns the token balance of an SPL Token account (UNSTABLE). Args: pubkey: Pubkey of Token account to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_token_account_balance(\"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\") # doctest: +SKIP {'jsonrpc': '2.0','result': { 'context': {'slot':1114}, 'value': { 'uiAmount': 98.64, 'amount': '9864', 'decimals': 2}, 'id' :1} \"\"\" args = self . _get_token_account_balance_args ( pubkey , commitment ) return self . _provider . make_request ( * args )","title":"get_token_account_balance()"},{"location":"rpc/api/#solana.rpc.api.Client.get_token_accounts_by_delegate","text":"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Parameters: Name Type Description Default delegate PublicKey Public key of the delegate owner to query. required opts Optional[types.TokenAccountOpts] Token account option specifying at least one of mint or program_id . None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/api.py def get_token_accounts_by_delegate ( self , delegate : PublicKey , opts : Optional [ types . TokenAccountOpts ] = None , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" args = self . _get_token_accounts_by_delegate_args ( delegate , opts , commitment ) return self . __get_token_accounts ( * args )","title":"get_token_accounts_by_delegate()"},{"location":"rpc/api/#solana.rpc.api.Client.get_token_accounts_by_owner","text":"Returns all SPL Token accounts by token owner (UNSTABLE). Parameters: Name Type Description Default owner PublicKey Public key of the account owner to query. required opts types.TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/api.py def get_token_accounts_by_owner ( self , owner : PublicKey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Returns all SPL Token accounts by token owner (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" args = self . _get_token_accounts_by_owner_args ( owner , opts , commitment ) return self . __get_token_accounts ( * args )","title":"get_token_accounts_by_owner()"},{"location":"rpc/api/#solana.rpc.api.Client.get_token_largest_accounts","text":"Returns the 20 largest accounts of a particular SPL Token type. Source code in solana/rpc/api.py def get_token_largest_accounts ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the 20 largest accounts of a particular SPL Token type.\"\"\" args = self . _get_token_largest_account_args ( pubkey , commitment ) return self . _provider . make_request ( * args )","title":"get_token_largest_accounts()"},{"location":"rpc/api/#solana.rpc.api.Client.get_token_supply","text":"Returns the total supply of an SPL Token type. Source code in solana/rpc/api.py def get_token_supply ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the total supply of an SPL Token type.\"\"\" args = self . _get_token_supply_args ( pubkey , commitment ) return self . _provider . make_request ( * args )","title":"get_token_supply()"},{"location":"rpc/api/#solana.rpc.api.Client.get_transaction","text":"Returns transaction details for a confirmed transaction. Parameters: Name Type Description Default tx_sig str Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the transaction.message.instructions list. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None max_support_transaction_version Optional[int] (optional) set the max transaction version to return in responses. If the requested block contains a transaction with a higher version, an error will be returned. None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_transaction ( \"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\" ) { 'jsonrpc' : '2.0' , 'result' : { 'meta' : { 'err' : None , 'fee' : 5000 , 'rewards' : [], 'postBalances' : [ 498449233720610510 , 1000001001987940 , 1 ], 'preBalances' : [ 498449233721615510 , 1000001000987940 , 1 ], 'status' : { 'Ok' : None }}, 'slot' : 1659335 , 'transaction' : { 'message' : { 'accountKeys' : [ '9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g' , '2KW2XRd9kwqet15Aha2oK3tYvd3nWbTFH1MBiRAv1BE1' , '11111111111111111111111111111111' ], 'header' : { 'numReadonlySignedAccounts' : 0 , 'numReadonlyUnsignedAccounts' : 1 , 'numRequiredSignatures' : 1 }, 'instructions' : [{ 'accounts' : [ 0 , 1 ], 'data' : '3Bxs4Bc3VYuGVB19' , 'programIdIndex' : 2 }], 'recentBlockhash' : 'FwcsKNptGtMLccXAA9YgnivVFK95mKzECLT1DNPi3SDr' }, 'signatures' : [ '3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy' ]}}, 'id' : 4 } Source code in solana/rpc/api.py def get_transaction ( self , tx_sig : str , encoding : str = \"json\" , commitment : Optional [ Commitment ] = None , max_support_transaction_version : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". max_support_transaction_version: (optional) set the max transaction version to return in responses. If the requested block contains a transaction with a higher version, an error will be returned. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_transaction(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\") # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'meta': {'err': None, 'fee': 5000, 'rewards': [], 'postBalances': [498449233720610510, 1000001001987940, 1], 'preBalances': [498449233721615510, 1000001000987940, 1], 'status': {'Ok': None}}, 'slot': 1659335, 'transaction': {'message': {'accountKeys': ['9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g', '2KW2XRd9kwqet15Aha2oK3tYvd3nWbTFH1MBiRAv1BE1', '11111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 1, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [0, 1], 'data': '3Bxs4Bc3VYuGVB19', 'programIdIndex': 2}], 'recentBlockhash': 'FwcsKNptGtMLccXAA9YgnivVFK95mKzECLT1DNPi3SDr'}, 'signatures': ['3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy']}}, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_transaction_args ( tx_sig , encoding , commitment , max_support_transaction_version ) return self . _provider . make_request ( * args )","title":"get_transaction()"},{"location":"rpc/api/#solana.rpc.api.Client.get_transaction_count","text":"Returns the current Transaction count from the ledger. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_transaction_count () { 'jsonrpc' : '2.0' , 'result' : 4554 , 'id' : 1 } Source code in solana/rpc/api.py def get_transaction_count ( self , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns the current Transaction count from the ledger. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_transaction_count() # doctest: +SKIP {'jsonrpc': '2.0', 'result': 4554, 'id': 1} \"\"\" args = self . _get_transaction_count_args ( commitment , min_context_slot ) return self . _provider . make_request ( * args )","title":"get_transaction_count()"},{"location":"rpc/api/#solana.rpc.api.Client.get_version","text":"Returns the current solana versions running on the node. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_version () { 'jsonrpc' : '2.0' , 'result' : { 'solana-core' : '1.4.0 5332fcad' }, 'id' : 1 } Source code in solana/rpc/api.py def get_version ( self ) -> types . RPCResponse : \"\"\"Returns the current solana versions running on the node. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_version() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'solana-core': '1.4.0 5332fcad'}, 'id': 1} \"\"\" return self . _provider . make_request ( self . _get_version )","title":"get_version()"},{"location":"rpc/api/#solana.rpc.api.Client.get_vote_accounts","text":"Returns the account info and associated stake for all the voting accounts in the current bank. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_vote_accounts () { 'jsonrpc' : '2.0' , 'result' : { 'current' : [{ 'activatedStake' : 0 , 'commission' : 100 , 'epochCredits' : [[ 165 , 714644 , 707372 ], [ 166 , 722092 , 714644 ], [ 167 , 730285 , 722092 ], [ 168 , 738476 , 730285 ], ... ] 'epochVoteAccount' : True , 'lastVote' : 1872294 , 'nodePubkey' : 'J7v9ndmcoBuo9to2MnHegLnBkC9x3SAVbQBJo5MMJrN1' , 'rootSlot' : 1872263 , 'votePubkey' : 'HiFjzpR7e5Kv2tdU9jtE4FbH1X8Z9Syia3Uadadx18b5' }, { 'activatedStake' : 500029968930560 , 'commission' : 100 , 'epochCredits' : [[ 165 , 1359689 , 1351498 ], [ 166 , 1367881 , 1359689 ], [ 167 , 1376073 , 1367881 ], [ 168 , 1384265 , 1376073 ], ... ], 'epochVoteAccount' : True , 'lastVote' : 1872295 , 'nodePubkey' : 'dv1LfzJvDF7S1fBKpFgKoKXK5yoSosmkAdfbxBo1GqJ' , 'rootSlot' : 1872264 , 'votePubkey' : '5MMCR4NbTZqjthjLGywmeT66iwE9J9f7kjtxzJjwfUx2' }, { 'activatedStake' : 0 , 'commission' : 100 , 'epochCredits' : [[ 227 , 2751 , 0 ], [ 228 , 7188 , 2751 ]], 'epochVoteAccount' : True , 'lastVote' : 1872295 , 'nodePubkey' : 'H1wDvJ5HJc1SzhHoWtaycpzQpFbsL7g8peaRV3obKShs' , 'rootSlot' : 1872264 , 'votePubkey' : 'DPqpgoLQVU3aq72HEqSMsB9qh4KoXc9fGEpvgEuiwnp6' }], 'delinquent' : []}, 'id' : 1 } Source code in solana/rpc/api.py def get_vote_accounts ( self , commitment : Optional [ Commitment ] = None ): \"\"\"Returns the account info and associated stake for all the voting accounts in the current bank. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_vote_accounts() # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'current': [{'activatedStake': 0, 'commission': 100, 'epochCredits': [[165, 714644, 707372], [166, 722092, 714644], [167, 730285, 722092], [168, 738476, 730285], ...] 'epochVoteAccount': True, 'lastVote': 1872294, 'nodePubkey': 'J7v9ndmcoBuo9to2MnHegLnBkC9x3SAVbQBJo5MMJrN1', 'rootSlot': 1872263, 'votePubkey': 'HiFjzpR7e5Kv2tdU9jtE4FbH1X8Z9Syia3Uadadx18b5'}, {'activatedStake': 500029968930560, 'commission': 100, 'epochCredits': [[165, 1359689, 1351498], [166, 1367881, 1359689], [167, 1376073, 1367881], [168, 1384265, 1376073], ...], 'epochVoteAccount': True, 'lastVote': 1872295, 'nodePubkey': 'dv1LfzJvDF7S1fBKpFgKoKXK5yoSosmkAdfbxBo1GqJ', 'rootSlot': 1872264, 'votePubkey': '5MMCR4NbTZqjthjLGywmeT66iwE9J9f7kjtxzJjwfUx2'}, {'activatedStake': 0, 'commission': 100, 'epochCredits': [[227, 2751, 0], [228, 7188, 2751]], 'epochVoteAccount': True, 'lastVote': 1872295, 'nodePubkey': 'H1wDvJ5HJc1SzhHoWtaycpzQpFbsL7g8peaRV3obKShs', 'rootSlot': 1872264, 'votePubkey': 'DPqpgoLQVU3aq72HEqSMsB9qh4KoXc9fGEpvgEuiwnp6'}], 'delinquent': []}, 'id': 1} \"\"\" args = self . _get_vote_accounts_args ( commitment ) return self . _provider . make_request ( * args )","title":"get_vote_accounts()"},{"location":"rpc/api/#solana.rpc.api.Client.is_blockhash_valid","text":"Returns whether a blockhash is still valid or not NEW: This method is only available in solana-core v1.9 or newer. Please use getRecentBlockhash for solana-core v1.8 Parameters: Name Type Description Default blockhash str the blockhash of this block, as base-58 encoded string required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None min_context_slot Optional[int] set the minimum slot that the request can be evaluated at None Examples: solana_client = Client(\"http://localhost:8899\") solana_client.is_blockhash_valid( 'J7rBdM6AecPDEZp8aPq5iPSNKVkU5Q76F3oAV4eW5wsW' ) Source code in solana/rpc/api.py def is_blockhash_valid ( self , blockhash : str , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Returns whether a blockhash is still valid or not NEW: This method is only available in solana-core v1.9 or newer. Please use getRecentBlockhash for solana-core v1.8 Args: blockhash: the blockhash of this block, as base-58 encoded string commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". min_context_slot: set the minimum slot that the request can be evaluated at Example: solana_client = Client(\"http://localhost:8899\") solana_client.is_blockhash_valid( 'J7rBdM6AecPDEZp8aPq5iPSNKVkU5Q76F3oAV4eW5wsW' ) \"\"\" args = self . _get_is_blockhash_valid_args ( blockhash , commitment , min_context_slot , ) return self . _provider . make_request ( * args )","title":"is_blockhash_valid()"},{"location":"rpc/api/#solana.rpc.api.Client.is_connected","text":"Health check. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . is_connected () True Returns: Type Description bool True if the client is connected. Source code in solana/rpc/api.py def is_connected ( self ) -> bool : \"\"\"Health check. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.is_connected() # doctest: +SKIP True Returns: True if the client is connected. \"\"\" return self . _provider . is_connected ()","title":"is_connected()"},{"location":"rpc/api/#solana.rpc.api.Client.request_airdrop","text":"Requests an airdrop of lamports to a Pubkey. Parameters: Name Type Description Default pubkey Union[PublicKey, str] Pubkey of account to receive lamports, as base-58 encoded string or public key object. required lamports int Amout of lamports. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solana.publickey import PublicKey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . request_airdrop ( PublicKey ( 1 ), 10000 ) { 'jsonrpc' : '2.0' , 'result' : 'uK6gbLbhnTEgjgmwn36D5BRTRkG4AT8r7Q162TLnJzQnHUZVL9r6BYZVfRttrhmkmno6Fp4VQELzL4AiriCo61U' , 'id' : 1 } Source code in solana/rpc/api.py def request_airdrop ( self , pubkey : Union [ PublicKey , str ], lamports : int , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Requests an airdrop of lamports to a Pubkey. Args: pubkey: Pubkey of account to receive lamports, as base-58 encoded string or public key object. lamports: Amout of lamports. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solana.publickey import PublicKey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.request_airdrop(PublicKey(1), 10000) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'uK6gbLbhnTEgjgmwn36D5BRTRkG4AT8r7Q162TLnJzQnHUZVL9r6BYZVfRttrhmkmno6Fp4VQELzL4AiriCo61U', 'id': 1} \"\"\" args = self . _request_airdrop_args ( pubkey , lamports , commitment ) return self . _provider . make_request ( * args )","title":"request_airdrop()"},{"location":"rpc/api/#solana.rpc.api.Client.send_raw_transaction","text":"Send a transaction that has already been signed and serialized into the wire format. Parameters: Name Type Description Default txn Union[bytes, str] Fully-signed Transaction object, a fully sign transaction in wire format, or a fully transaction as base-64 encoded string. required opts Optional[types.TxOpts] (optional) Transaction options. None Before submitting, the following preflight checks are performed (unless disabled with the skip_preflight option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> full_signed_tx_str = ( ... \"AbN5XM+qw+7oOLsFw7goQSLBis7c1kXJFP6OF4w7YmQNhhbQYcyBiybKuOzzhV7McvoRP3Mey9AhXojtwDCdbwoBAAEDE5j2\" ... \"LG0aRXxRumpLXz29L2n8qTIWIY3ImX5Ba9F9k8poq0Z3/7HyiU3QphU8Ix1F7ENq5TrmAUnb4V8y5LhwPwAAAAAAAAAAAAAA\" ... \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAg5YY9wG6fpuieuWYJd1ta7ZtFPbV0OriFRYdcYUaEGkBAgIAAQwCAAAAQEIPAAAAAAA=\" ) >>> solana_client . send_raw_transaction ( full_signed_tx_str ) { 'jsonrpc' : '2.0' , 'result' : 'CMwyESM2NE74mghfbvsHJDERF7xMYKshwwm6VgH6GFqXzx8LfBFuP5ruccumfhTguha6seUHPpiHzzHUQXzq2kN' , 'id' : 1 } Source code in solana/rpc/api.py def send_raw_transaction ( self , txn : Union [ bytes , str ], opts : Optional [ types . TxOpts ] = None , ) -> types . RPCResponse : \"\"\"Send a transaction that has already been signed and serialized into the wire format. Args: txn: Fully-signed Transaction object, a fully sign transaction in wire format, or a fully transaction as base-64 encoded string. opts: (optional) Transaction options. Before submitting, the following preflight checks are performed (unless disabled with the `skip_preflight` option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> full_signed_tx_str = ( ... \"AbN5XM+qw+7oOLsFw7goQSLBis7c1kXJFP6OF4w7YmQNhhbQYcyBiybKuOzzhV7McvoRP3Mey9AhXojtwDCdbwoBAAEDE5j2\" ... \"LG0aRXxRumpLXz29L2n8qTIWIY3ImX5Ba9F9k8poq0Z3/7HyiU3QphU8Ix1F7ENq5TrmAUnb4V8y5LhwPwAAAAAAAAAAAAAA\" ... \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAg5YY9wG6fpuieuWYJd1ta7ZtFPbV0OriFRYdcYUaEGkBAgIAAQwCAAAAQEIPAAAAAAA=\") >>> solana_client.send_raw_transaction(full_signed_tx_str) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'CMwyESM2NE74mghfbvsHJDERF7xMYKshwwm6VgH6GFqXzx8LfBFuP5ruccumfhTguha6seUHPpiHzzHUQXzq2kN', 'id': 1} \"\"\" # noqa: E501 # pylint: disable=line-too-long opts_to_use = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts args = self . _send_raw_transaction_args ( txn , opts_to_use ) resp = self . _provider . make_request ( * args ) if opts_to_use . skip_confirmation : return self . _post_send ( resp ) post_send_args = self . _send_raw_transaction_post_send_args ( resp , opts_to_use ) return self . __post_send_with_confirm ( * post_send_args )","title":"send_raw_transaction()"},{"location":"rpc/api/#solana.rpc.api.Client.send_transaction","text":"Send a transaction. Parameters: Name Type Description Default txn Transaction Transaction object. required signers Keypair Signers to sign the transaction. () opts Optional[types.TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) Pass a valid recent blockhash here if you want to skip fetching the recent blockhash or relying on the cache. None Examples: >>> from solana.keypair import Keypair >>> from solana.publickey import PublicKey >>> from solana.rpc.api import Client >>> from solana.system_program import TransferParams , transfer >>> from solana.transaction import Transaction >>> sender , receiver = Keypair . from_seed ( bytes ( PublicKey ( 1 ))), Keypair . from_seed ( bytes ( PublicKey ( 2 ))) >>> txn = Transaction () . add ( transfer ( TransferParams ( ... from_pubkey = sender . public_key , to_pubkey = receiver . public_key , lamports = 1000 ))) >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . send_transaction ( txn , sender ) { 'jsonrpc' : '2.0' , 'result' : '236zSA5w4NaVuLXXHK1mqiBuBxkNBu84X6cfLBh1v6zjPrLfyECz4zdedofBaZFhs4gdwzSmij9VkaSo2tR5LTgG' , 'id' : 12 } Source code in solana/rpc/api.py def send_transaction ( self , txn : Transaction , * signers : Keypair , opts : Optional [ types . TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> types . RPCResponse : \"\"\"Send a transaction. Args: txn: Transaction object. signers: Signers to sign the transaction. opts: (optional) Transaction options. recent_blockhash: (optional) Pass a valid recent blockhash here if you want to skip fetching the recent blockhash or relying on the cache. Example: >>> from solana.keypair import Keypair >>> from solana.publickey import PublicKey >>> from solana.rpc.api import Client >>> from solana.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> sender, receiver = Keypair.from_seed(bytes(PublicKey(1))), Keypair.from_seed(bytes(PublicKey(2))) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.public_key, to_pubkey=receiver.public_key, lamports=1000))) >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.send_transaction(txn, sender) # doctest: +SKIP {'jsonrpc': '2.0', 'result': '236zSA5w4NaVuLXXHK1mqiBuBxkNBu84X6cfLBh1v6zjPrLfyECz4zdedofBaZFhs4gdwzSmij9VkaSo2tR5LTgG', 'id': 12} \"\"\" last_valid_block_height = None if recent_blockhash is None : if self . blockhash_cache : try : recent_blockhash = self . blockhash_cache . get () except ValueError : blockhash_resp = self . get_latest_blockhash ( Finalized ) recent_blockhash = self . _process_blockhash_resp ( blockhash_resp , used_immediately = True ) last_valid_block_height = blockhash_resp [ \"result\" ][ \"value\" ][ \"lastValidBlockHeight\" ] else : blockhash_resp = self . get_latest_blockhash ( Finalized ) recent_blockhash = self . parse_recent_blockhash ( blockhash_resp ) last_valid_block_height = blockhash_resp [ \"result\" ][ \"value\" ][ \"lastValidBlockHeight\" ] txn . recent_blockhash = recent_blockhash txn . sign ( * signers ) opts_to_use = ( types . TxOpts ( preflight_commitment = self . _commitment , last_valid_block_height = last_valid_block_height ) if opts is None else opts ) txn_resp = self . send_raw_transaction ( txn . serialize (), opts = opts_to_use ) if self . blockhash_cache : blockhash_resp = self . get_recent_blockhash ( Finalized ) self . _process_blockhash_resp ( blockhash_resp , used_immediately = False ) return txn_resp","title":"send_transaction()"},{"location":"rpc/api/#solana.rpc.api.Client.set_log_filter","text":"Sets the log filter on the validator. Parameters: Name Type Description Default log_filter str The new log filter to use. required Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . set_log_filter ( \"solana_core=debug\" ) { 'jsonrpc' : '2.0' , 'result' : None , 'id' : 1 } Source code in solana/rpc/api.py def set_log_filter ( self , log_filter : str ) -> types . RPCResponse : \"\"\"Sets the log filter on the validator. Args: log_filter: The new log filter to use. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.set_log_filter(\"solana_core=debug\") # doctest: +SKIP {'jsonrpc': '2.0', 'result': None, 'id': 1} \"\"\" args = self . _set_log_filter_args ( log_filter ) return self . _provider . make_request ( * args )","title":"set_log_filter()"},{"location":"rpc/api/#solana.rpc.api.Client.simulate_transaction","text":"Simulate sending a transaction. Parameters: Name Type Description Default txn Union[bytes, str, Transaction] A Transaction object, a transaction in wire format, or a transaction as base-64 encoded string The transaction must have a valid blockhash, but is not required to be signed. required sig_verify bool If true the transaction signatures will be verified (default: false). False commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> tx_str = ( ... \"4hXTCkRzt9WyecNzV1XPgCDfGAZzQKNxLXgynz5QDuWWPSAZBZSHptvWRL3BjCvzUXRdKvHL2b7yGrRQcWyaqsaBCncVG7BF\" ... \"ggS8w9snUts67BSh3EqKpXLUm5UMHfD7ZBe9GhARjbNQMLJ1QD3Spr6oMTBU6EhdB4RD8CP2xUxr2u3d6fos36PD98XS6oX8\" ... \"TQjLpsMwncs5DAMiD4nNnR8NBfyghGCWvCVifVwvA8B8TJxE1aiyiv2L429BCWfyzAme5sZW8rDb14NeCQHhZbtNqfXhcp2t\" ... ) >>> solana_client . simulate_transaction ( tx_str ) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 218 }, 'value' : { 'err' : null , 'logs' : [ 'BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success' ]}, 'id' : 1 } Source code in solana/rpc/api.py def simulate_transaction ( self , txn : Union [ bytes , str , Transaction ], sig_verify : bool = False , commitment : Optional [ Commitment ] = None , min_context_slot : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Simulate sending a transaction. Args: txn: A Transaction object, a transaction in wire format, or a transaction as base-64 encoded string The transaction must have a valid blockhash, but is not required to be signed. sig_verify: If true the transaction signatures will be verified (default: false). commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> tx_str = ( ... \"4hXTCkRzt9WyecNzV1XPgCDfGAZzQKNxLXgynz5QDuWWPSAZBZSHptvWRL3BjCvzUXRdKvHL2b7yGrRQcWyaqsaBCncVG7BF\" ... \"ggS8w9snUts67BSh3EqKpXLUm5UMHfD7ZBe9GhARjbNQMLJ1QD3Spr6oMTBU6EhdB4RD8CP2xUxr2u3d6fos36PD98XS6oX8\" ... \"TQjLpsMwncs5DAMiD4nNnR8NBfyghGCWvCVifVwvA8B8TJxE1aiyiv2L429BCWfyzAme5sZW8rDb14NeCQHhZbtNqfXhcp2t\" ... ) >>> solana_client.simulate_transaction(tx_str) # doctest: +SKIP {'jsonrpc' :'2.0', 'result': {'context': {'slot': 218}, 'value': { 'err': null, 'logs': ['BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success']}, 'id':1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _simulate_transaction_args ( txn , sig_verify , commitment , min_context_slot , ) return self . _provider . make_request ( * args )","title":"simulate_transaction()"},{"location":"rpc/api/#solana.rpc.api.Client.validator_exit","text":"Request to have the validator exit. Validator must have booted with RPC exit enabled ( --enable-rpc-exit parameter). Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . validator_exit () { 'jsonrpc' : '2.0' , 'result' : true , 'id' : 1 } Source code in solana/rpc/api.py def validator_exit ( self ) -> types . RPCResponse : \"\"\"Request to have the validator exit. Validator must have booted with RPC exit enabled (`--enable-rpc-exit` parameter). Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.validator_exit() # doctest: +SKIP {'jsonrpc': '2.0', 'result': true, 'id': 1} \"\"\" return self . _provider . make_request ( self . _validator_exit )","title":"validator_exit()"},{"location":"rpc/api/#solana.rpc.api.DataSliceOpt","text":"Option to limit the returned account data, only available for \"base58\" or \"base64\" encoding. Source code in solana/rpc/api.py def DataSliceOpt ( * args , ** kwargs ) -> types . DataSliceOpts : # pylint: disable=invalid-name \"\"\"Option to limit the returned account data, only available for \"base58\" or \"base64\" encoding.\"\"\" warn ( \"solana.rpc.api.DataSliceOpt is deprecated, please use solana.rpc.types.DataSliceOpts\" , category = DeprecationWarning , ) return types . DataSliceOpts ( * args , ** kwargs )","title":"DataSliceOpt()"},{"location":"rpc/api/#solana.rpc.api.MemcmpOpt","text":"Option to compare a provided series of bytes with program account data at a particular offset. Source code in solana/rpc/api.py def MemcmpOpt ( * args , ** kwargs ) -> types . MemcmpOpts : # pylint: disable=invalid-name \"\"\"Option to compare a provided series of bytes with program account data at a particular offset.\"\"\" warn ( \"solana.rpc.api.MemcmpOpt is deprecated, please use solana.rpc.types.MemcmpOpts\" , category = DeprecationWarning ) return types . MemcmpOpts ( * args , ** kwargs )","title":"MemcmpOpt()"},{"location":"rpc/async_api/","text":"Async API Client solana.rpc.async_api Async API client to interact with the Solana JSON RPC Endpoint. AsyncClient Async client class. Parameters: Name Type Description Default endpoint Optional[str] URL of the RPC endpoint. None commitment Optional[Commitment] Default bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None blockhash_cache Union[solana.blockhash.BlockhashCache, bool] (Experimental) If True, keep a cache of recent blockhashes to make send_transaction calls faster. You can also pass your own BlockhashCache object to customize its parameters. The cache works as follows: Retrieve the oldest unused cached blockhash that is younger than ttl seconds, where ttl is defined in the BlockhashCache (we prefer unused blockhashes because reusing blockhashes can cause errors in some edge cases, and we prefer slightly older blockhashes because they're more likely to be accepted by every validator). If there are no unused blockhashes in the cache, take the oldest used blockhash that is younger than ttl seconds. Fetch a new recent blockhash after sending the transaction. This is to keep the cache up-to-date. If you want something tailored to your use case, run your own loop that fetches the recent blockhash, and pass that value in your .send_transaction calls. False timeout float HTTP request timeout in seconds. 10 Source code in solana/rpc/async_api.py class AsyncClient ( _ClientCore ): # pylint: disable=too-many-public-methods \"\"\"Async client class. Args: endpoint: URL of the RPC endpoint. commitment: Default bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". blockhash_cache: (Experimental) If True, keep a cache of recent blockhashes to make `send_transaction` calls faster. You can also pass your own BlockhashCache object to customize its parameters. The cache works as follows: 1. Retrieve the oldest unused cached blockhash that is younger than `ttl` seconds, where `ttl` is defined in the BlockhashCache (we prefer unused blockhashes because reusing blockhashes can cause errors in some edge cases, and we prefer slightly older blockhashes because they're more likely to be accepted by every validator). 2. If there are no unused blockhashes in the cache, take the oldest used blockhash that is younger than `ttl` seconds. 3. Fetch a new recent blockhash *after* sending the transaction. This is to keep the cache up-to-date. If you want something tailored to your use case, run your own loop that fetches the recent blockhash, and pass that value in your `.send_transaction` calls. timeout: HTTP request timeout in seconds. \"\"\" def __init__ ( self , endpoint : Optional [ str ] = None , commitment : Optional [ Commitment ] = None , blockhash_cache : Union [ BlockhashCache , bool ] = False , timeout : float = 10 , ) -> None : \"\"\"Init API client.\"\"\" super () . __init__ ( commitment , blockhash_cache ) self . _provider = async_http . AsyncHTTPProvider ( endpoint , timeout = timeout ) async def __aenter__ ( self ) -> \"AsyncClient\" : \"\"\"Use as a context manager.\"\"\" await self . _provider . __aenter__ () return self async def __aexit__ ( self , _exc_type , _exc , _tb ): \"\"\"Exits the context manager.\"\"\" await self . close () @property def request ( self ): if getattr ( self , '_provider' ): request_raw = self . _provider . content return self . _provider . json_decode ( request_raw ) return None @property def response_headers ( self ): return self . _provider . response_headers if getattr ( self , '_provider' ) else None async def close ( self ) -> None : \"\"\"Use this when you are done with the client.\"\"\" await self . _provider . close () async def is_connected ( self ) -> bool : \"\"\"Health check. >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.is_connected()) # doctest: +SKIP True Returns: True if the client is connected. \"\"\" return await self . _provider . is_connected () async def get_balance ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the balance of the account of provided Pubkey. Args: pubkey: Pubkey of account to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solana.publickey import PublicKey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_balance(PublicKey(1))) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 228}, 'value': 0}, 'id': 1} \"\"\" args = self . _get_balance_args ( pubkey , commitment ) return await self . _provider . make_request ( * args ) async def get_account_info ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> types . RPCResponse : \"\"\"Returns all the account info for the specified public key. Args: pubkey: Pubkey of account to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. - \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solana.publickey import PublicKey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_account_info(PublicKey(1))) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 33265073}, 'value': {'data': '', 'executable': False, 'lamports': 4459816188034584, 'owner': '11111111111111111111111111111111', 'rentEpoch': 90}}, 'id': 1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_account_info_args ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , min_context_slot = None ) return await self . _provider . make_request ( * args ) async def get_block_commitment ( self , slot : int ) -> types . RPCResponse : \"\"\"Fetch the commitment for particular block. Args: slot: Block, identified by Slot. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_block_commitment(0)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'commitment': [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 497717120], 'totalStake': 497717120}, 'id': 1}} \"\"\" args = self . _get_block_commitment_args ( slot ) return await self . _provider . make_request ( * args ) async def get_block_time ( self , slot : int ) -> types . RPCResponse : \"\"\"Fetch the estimated production time of a block. Args: slot: Block, identified by Slot. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_block_time(5)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1598400007, 'id': 1} \"\"\" args = self . _get_block_time_args ( slot ) return await self . _provider . make_request ( * args ) async def get_cluster_nodes ( self ) -> types . RPCResponse : \"\"\"Returns information about all the nodes participating in the cluster. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_cluster_nodes()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [{'gossip': '127.0.0.1:8001', 'pubkey': 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk', 'rpc': '127.0.0.1:8899', 'tpu': '127.0.0.1:8003', 'version': '1.4.0 5332fcad'}], 'id': 1} \"\"\" return await self . _provider . make_request ( self . _get_cluster_nodes ) async def get_confirmed_block ( self , slot : int , encoding : str = \"json\" , ) -> types . RPCResponse : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_confirmed_block(1)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': {'message': {'accountKeys': ['LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk', 'EKAar3bMQUZvGSonq7vcPF2nPaCYowbnat44FPafW8Po', 'SysvarS1otHashes111111111111111111111111111', 'SysvarC1ock11111111111111111111111111111111', 'Vote111111111111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 3, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [1, 2, 3, 0], 'data': '37u9WtQpcm6ULa3VmTgTKEBCtYMxq84mk82tRvKdFEwj3rALiptAzuMJ1yoVSFAMARMZYp7q', 'programIdIndex': 4}], 'recentBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2'}, 'signatures': ['63jnpMCs7TNnCjnTqUrX7Mvqc5CbJMtVkLxBjPHUQkjXyZrQuZpfhjvzA7A29D9tMqVaiQC3UNP1NeaZKFFHJyQE']}}]}, 'id': 9} >>> asyncio.run(solana_client.get_confirmed_block(1, encoding=\"base64\")) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': ['AfxyKHmHIjXWjkyHODGeAbVxmfQWPj1ydS9nF+ynJHo8I1vCPDp2P9Cj5aA6W1CAHEHCqY0B1FDKomCzRo3qrAsBAAMFBQ6QBWfhQF7rG02xhuEsmmrUtz3AUjBtJKkqaHPJEmvFzziDX0C0robPrl9RbOyXHoc9/Dxa0zoGL6cEjvCjLgan1RcZLwqvxvJl4/t3zHragsUp0L47E24tAFUgAAAABqfVFxjHdMkoVmOYaR1etoteuKObS21cc1VbIQAAAAAHYUgdNXR0u3xNdiTr072z2DVec9EQQ/wNo1OAAAAAAM8NSv7ISDPN9E9XNL9vX7h8LuJHWlopUcX39DxsDx23AQQEAQIDADUCAAAAAQAAAAAAAAAAAAAAAAAAAIWWp5Il3Kg312pzVk6Jt61iyFhTbtmkh/ORbj3JUQRbAA==', 'base64']}]}, 'id': 10} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_confirmed_block_args ( slot , encoding ) return await self . _provider . make_request ( * args ) async def get_recent_performance_samples ( self , limit : Optional [ int ] = None ) -> types . RPCResponse : \"\"\"Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Args: limit: Limit (optional) number of samples to return (maximum 720) Examples: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_recent_performance_samples(4)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [ { 'numSlots': 126, 'numTransactions': 126, 'samplePeriodSecs': 60, 'slot': 348125 }, { 'numSlots': 126, 'numTransactions': 126, 'samplePeriodSecs': 60, 'slot': 347999 }, { 'numSlots': 125, 'numTransactions': 125, 'samplePeriodSecs': 60, 'slot': 347873 }, { 'numSlots': 125, 'numTransactions': 125, 'samplePeriodSecs': 60, 'slot': 347748 } ], 'id': 1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_recent_performance_samples_args ( limit ) return await self . _provider . make_request ( * args ) async def get_block ( self , slot : int , encoding : str = \"json\" , ) -> types . RPCResponse : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_block(1)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockHeight': 0, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': {'message': {'accountKeys': ['LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk', 'EKAar3bMQUZvGSonq7vcPF2nPaCYowbnat44FPafW8Po', 'SysvarS1otHashes111111111111111111111111111', 'SysvarC1ock11111111111111111111111111111111', 'Vote111111111111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 3, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [1, 2, 3, 0], 'data': '37u9WtQpcm6ULa3VmTgTKEBCtYMxq84mk82tRvKdFEwj3rALiptAzuMJ1yoVSFAMARMZYp7q', 'programIdIndex': 4}], 'recentBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2'}, 'signatures': ['63jnpMCs7TNnCjnTqUrX7Mvqc5CbJMtVkLxBjPHUQkjXyZrQuZpfhjvzA7A29D9tMqVaiQC3UNP1NeaZKFFHJyQE']}}]}, 'id': 9} >>> asyncio.run(solana_client.get_block(1, encoding=\"base64\")) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockHeight': 0, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': ['AfxyKHmHIjXWjkyHODGeAbVxmfQWPj1ydS9nF+ynJHo8I1vCPDp2P9Cj5aA6W1CAHEHCqY0B1FDKomCzRo3qrAsBAAMFBQ6QBWfhQF7rG02xhuEsmmrUtz3AUjBtJKkqaHPJEmvFzziDX0C0robPrl9RbOyXHoc9/Dxa0zoGL6cEjvCjLgan1RcZLwqvxvJl4/t3zHragsUp0L47E24tAFUgAAAABqfVFxjHdMkoVmOYaR1etoteuKObS21cc1VbIQAAAAAHYUgdNXR0u3xNdiTr072z2DVec9EQQ/wNo1OAAAAAAM8NSv7ISDPN9E9XNL9vX7h8LuJHWlopUcX39DxsDx23AQQEAQIDADUCAAAAAQAAAAAAAAAAAAAAAAAAAIWWp5Il3Kg312pzVk6Jt61iyFhTbtmkh/ORbj3JUQRbAA==', 'base64']}]}, 'id': 10} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_block_args ( slot , encoding ) return await self . _provider . make_request ( * args ) async def get_block_height ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the current block height of the node. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_block_height()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1233, 'id': 1} \"\"\" args = self . _get_block_height_args ( commitment ) return await self . _provider . make_request ( * args ) async def get_confirmed_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> types . RPCResponse : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_confirmed_blocks(5, 10)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [5, 6, 7, 8, 9, 10], 'id': 1} \"\"\" args = self . _get_confirmed_blocks_args ( start_slot , end_slot ) return await self . _provider . make_request ( * args ) async def get_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> types . RPCResponse : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_blocks(5, 10)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [5, 6, 7, 8, 9, 10], 'id': 1} \"\"\" args = self . _get_blocks_args ( start_slot , end_slot ) return await self . _provider . make_request ( * args ) async def get_confirmed_signature_for_address2 ( self , account : Union [ str , Keypair , PublicKey ], before : Optional [ str ] = None , until : Optional [ str ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optoinal) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_confirmed_signature_for_address2(\"Vote111111111111111111111111111111111111111\", limit=1)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [{'err': None, 'memo': None, 'signature': 'v1BK8XcaPBzAGd7TB1K53pMdi6TBGe5CLCgx8cmZ4Bj63ZNvA6ca2QaxFpBFdvmpoFQ51VorBjifkBGLTDhwpqN', 'slot': 4290}], 'id': 2} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_confirmed_signature_for_address2_args ( account , before , until , limit , commitment ) return await self . _provider . make_request ( * args ) async def get_signatures_for_address ( self , account : Union [ str , Keypair , PublicKey ], before : Optional [ str ] = None , until : Optional [ str ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_signatures_for_address(\"Vote111111111111111111111111111111111111111\", limit=1)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [{'err': None, 'memo': None, 'signature': 'v1BK8XcaPBzAGd7TB1K53pMdi6TBGe5CLCgx8cmZ4Bj63ZNvA6ca2QaxFpBFdvmpoFQ51VorBjifkBGLTDhwpqN', 'slot': 4290}], 'id': 2} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_signatures_for_address_args ( account , before , until , limit , commitment ) return await self . _provider . make_request ( * args ) async def get_confirmed_transaction ( self , tx_sig : str , encoding : str = \"json\" ) -> types . RPCResponse : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_confirmed_transaction(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\")) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'meta': {'err': None, 'fee': 5000, 'postBalances': [498449233720610510, 1000001001987940, 1], 'preBalances': [498449233721615510, 1000001000987940, 1], 'status': {'Ok': None}}, 'slot': 1659335, 'transaction': {'message': {'accountKeys': ['9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g', '2KW2XRd9kwqet15Aha2oK3tYvd3nWbTFH1MBiRAv1BE1', '11111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 1, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [0, 1], 'data': '3Bxs4Bc3VYuGVB19', 'programIdIndex': 2}], 'recentBlockhash': 'FwcsKNptGtMLccXAA9YgnivVFK95mKzECLT1DNPi3SDr'}, 'signatures': ['3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy']}}, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_confirmed_transaction_args ( tx_sig , encoding ) return await self . _provider . make_request ( * args ) async def get_transaction ( self , tx_sig : str , encoding : str = \"json\" , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_transaction(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\")) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'meta': {'err': None, 'fee': 5000, 'rewards': [], 'postBalances': [498449233720610510, 1000001001987940, 1], 'preBalances': [498449233721615510, 1000001000987940, 1], 'status': {'Ok': None}}, 'slot': 1659335, 'transaction': {'message': {'accountKeys': ['9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g', '2KW2XRd9kwqet15Aha2oK3tYvd3nWbTFH1MBiRAv1BE1', '11111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 1, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [0, 1], 'data': '3Bxs4Bc3VYuGVB19', 'programIdIndex': 2}], 'recentBlockhash': 'FwcsKNptGtMLccXAA9YgnivVFK95mKzECLT1DNPi3SDr'}, 'signatures': ['3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy']}}, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_transaction_args ( tx_sig , encoding , commitment ) return await self . _provider . make_request ( * args ) async def get_epoch_info ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns information about the current epoch. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_epoch_info()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'absoluteSlot': 5150, 'blockHeight': 5150, 'epoch': 0, 'slotIndex': 5150, 'slotsInEpoch': 8192}, 'id': 5} \"\"\" args = self . _get_epoch_info_args ( commitment ) return await self . _provider . make_request ( * args ) async def get_epoch_schedule ( self ) -> types . RPCResponse : \"\"\"Returns epoch schedule information from this cluster's genesis config. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_epoch_schedule()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'firstNormalEpoch': 0, 'firstNormalSlot': 0, 'leaderScheduleSlotOffset': 8192, 'slotsPerEpoch': 8192, 'warmup': False}, 'id': 6} \"\"\" return await self . _provider . make_request ( self . _get_epoch_schedule ) async def get_fee_calculator_for_blockhash ( self , blockhash : Union [ str , Blockhash ], commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the fee calculator associated with the query blockhash, or null if the blockhash has expired. Args: blockhash: Blockhash to query as a Base58 encoded string. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_fee_calculator_for_blockhash(\"BaQSR194dC4dZaRxATtxYyEwDkk7VgqUY8NVNkub8HFZ\")) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 7065}, 'value': {'feeCalculator': {'lamportsPerSignature': 5000}}}, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_fee_calculator_for_blockhash_args ( blockhash , commitment ) return await self . _provider . make_request ( * args ) async def get_fee_for_message ( self , message : Message , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the fee for a message. Args: message: Message that the fee is requested for. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solana.keypair import Keypair >>> from solana.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> sender, receiver = Keypair.from_seed(bytes(PublicKey(1))), Keypair.from_seed(bytes(PublicKey(2))) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.public_key, to_pubkey=receiver.public_key, lamports=1000))) >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_fee_for_message(txn.compile_message())) # doctest: +SKIP {'jsonrpc': '2.0', 'result': { 'context': { 'slot': 5068 }, 'value': 5000 }, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long if isinstance ( message , Transaction ): raise TransactionUncompiledError ( \"Transaction uncompiled, please compile to message first.\" ) args = self . _get_fee_for_message_args ( message , commitment ) return await self . _provider . make_request ( * args ) async def get_fee_rate_governor ( self ) -> types . RPCResponse : \"\"\"Return the fee rate governor information from the root bank. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_fee_rate_governor()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 7172}, 'value': {'feeRateGovernor': {'burnPercent': 50, 'maxLamportsPerSignature': 100000, 'minLamportsPerSignature': 5000, 'targetLamportsPerSignature': 10000, 'targetSignaturesPerSlot': 20000}}}, 'id': 5} \"\"\" return await self . _provider . make_request ( self . _get_fee_rate_governor ) async def get_fees ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns a recent block hash from the ledger, a fee schedule and the last slot the blockhash will be valid. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_fees()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 7727}, 'value': {'blockhash': 'GGS6AEDqjF5irU6D6VQNherEZ2hckGaeBiVdfSZKg4gd', 'feeCalculator': {'lamportsPerSignature': 5000}, 'lastValidSlot': 8027}}, 'id': 1} \"\"\" args = self . _get_fees_args ( commitment ) return await self . _provider . make_request ( * args ) async def get_first_available_block ( self ) -> types . RPCResponse : \"\"\"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_fees()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1, 'id': 2} \"\"\" return await self . _provider . make_request ( self . _get_first_available_block ) async def get_genesis_hash ( self ) -> types . RPCResponse : \"\"\"Returns the genesis hash. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_genesis_hash()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'id': 3} \"\"\" return await self . _provider . make_request ( self . _get_genesis_hash ) async def get_identity ( self ) -> types . RPCResponse : \"\"\"Returns the identity pubkey for the current node. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_identity()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'identity': 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk'}, 'id': 4} \"\"\" return await self . _provider . make_request ( self . _get_identity ) async def get_inflation_governor ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the current inflation governor. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_inflation_governor()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'foundation': 0.05, 'foundationTerm': 7.0, 'initial': 0.15, 'taper': 0.15, 'terminal': 0.015}, 'id': 5} \"\"\" args = self . _get_inflation_governor_args ( commitment ) return await self . _provider . make_request ( * args ) async def get_inflation_rate ( self ) -> types . RPCResponse : \"\"\"Returns the specific inflation values for the current epoch. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_inflation_rate()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'epoch': 1, 'foundation': 0.007499746885736559, 'total': 0.14999493771473116, 'validator': 0.1424951908289946}, 'id': 1} \"\"\" return await self . _provider . make_request ( self . _get_inflation_rate ) async def get_largest_accounts ( self , filter_opt : Optional [ str ] = None , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the 20 largest accounts, by lamport balance. Args: filter_opt: Filter results by account type; currently supported: circulating|nonCirculating. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_largest_accounts()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 8890}, 'value': [{'address': '95L7AsBCLRsqghsi6ksZkzjNbs6rqDgHCzKaGZ7bJi75', 'lamports': 500000000000000000}, {'address': 'APnSR52EC1eH676m7qTBHUJ1nrGpHYpV7XKPxgRDD8gX', 'lamports': 164511033098290000}, {'address': '13LeFbG6m2EP1fqCj9k66fcXsoTHMMtgr7c78AivUrYD', 'lamports': 153333632446109120}, {'address': 'GK2zqSsXLA2rwVZk347RYhh6jJpRsCA69FjLW93ZGi3B', 'lamports': 57499999036109120}, {'address': '8HVqyX9jebh31Q9Hp8t5sMVJs665979ZeEr3eCfzitUe', 'lamports': 30301031036109120}, {'address': 'HbZ5FfmKWNHC7uwk6TF1hVi6TCs7dtYfdjEcuPGgzFAg', 'lamports': 14999999036109120}, {'address': '14FUT96s9swbmH7ZjpDvfEDywnAYy9zaNhv4xvezySGu', 'lamports': 4999999036109120}, {'address': '9huDUZfxoJ7wGMTffUE7vh1xePqef7gyrLJu9NApncqA', 'lamports': 4999999036109120}, {'address': 'C7C8odR8oashR5Feyrq2tJKaXL18id1dSj2zbkDGL2C2', 'lamports': 4999999036109120}, {'address': 'AYgECURrvuX6GtFe4tX7aAj87Xc5r5Znx96ntNk1nCv', 'lamports': 2499999518054560}, {'address': 'AogcwQ1ubM76EPMhSD5cw1ES4W5econvQCFmBL6nTW1', 'lamports': 2499999518054560}, {'address': 'gWgqQ4udVxE3uNxRHEwvftTHwpEmPHAd8JR9UzaHbR2', 'lamports': 2499999518054560}, {'address': '3D91zLQPRLamwJfGR5ZYMKQb4C18gsJNaSdmB6b2wLhw', 'lamports': 2499999518054560}, {'address': '3bHbMa5VW3np5AJazuacidrN4xPZgwhcXigmjwHmBg5e', 'lamports': 2499999518054560}, {'address': '4U3RFq7X5kLG6tZ9kcksFL8oXeGNjtuUN1YfkVKXbs5x', 'lamports': 2499999518054560}, {'address': '5cBVGBKY6kBaiTVmsQpxThJ2oqitBYuCAX9Zm2zMuV4y', 'lamports': 2499999518054560}, {'address': '8PjJTv657aeN9p5R2WoM6pPSz385chvTTytUWaEjSjkq', 'lamports': 2499999518054560}, {'address': 'AHB94zKUASftTdqgdfiDSdnPJHkEFp7zX3yMrcSxABsv', 'lamports': 2499999518054560}, {'address': 'Hc36Wh1ZqYGzGAnsJWNT9r2gY3h9n89uDpxZPsmEsiE3', 'lamports': 2499999518054560}, {'address': 'GxyRKP2eVKACaSSnso4VLSAjZKmHsFXHWUfS3A5CtiMA', 'lamports': 1940147018054560}]}, 'id': 2} \"\"\" args = self . _get_largest_accounts_args ( filter_opt , commitment ) return await self . _provider . make_request ( * args ) async def get_leader_schedule ( self , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the leader schedule for an epoch. Args: epoch: Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_leader_schedule()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'EWj2cuEuVhi7RX81cnAY3TzpyFwnHzzVwvuTyfmxmhs3': [0, 1, 2, 3, 4, 5, ...]}, 'id': 6} \"\"\" args = self . _get_leader_schedule_args ( epoch , commitment ) return await self . _provider . make_request ( * args ) async def get_minimum_balance_for_rent_exemption ( self , usize : int , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns minimum balance required to make account rent exempt. Args: usize: Account data length. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_minimum_balance_for_rent_exemption(50)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1238880, 'id': 7} \"\"\" args = self . _get_minimum_balance_for_rent_exemption_args ( usize , commitment ) return await self . _provider . make_request ( * args ) async def get_multiple_accounts ( self , pubkeys : List [ Union [ PublicKey , str ]], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> types . RPCResponse : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. - \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solana.publickey import PublicKey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> pubkeys = [PublicKey(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), PublicKey(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> asyncio.run(solana_client.get_multiple_accounts(pubkeys)) # doctest: +SKIP { \"jsonrpc\": \"2.0\", \"result\": { \"context\": {\"slot\": 97531946}, \"value\": [ { \"data\": [\"\", \"base64\"], \"executable\": False, \"lamports\": 1, \"owner\": \"11111111111111111111111111111111\", \"rentEpoch\": 225, }, { \"data\": [\"\", \"base64\"], \"executable\": False, \"lamports\": 809441127, \"owner\": \"11111111111111111111111111111111\", \"rentEpoch\": 225, }, ], }, \"id\": 1, } \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_multiple_accounts_args ( pubkeys = pubkeys , commitment = commitment , encoding = encoding , data_slice = data_slice ) return await self . _provider . make_request ( * args ) async def get_program_accounts ( # pylint: disable=too-many-arguments self , pubkey : Union [ str , PublicKey ], commitment : Optional [ Commitment ] = Finalized , encoding : Optional [ str ] = None , data_slice : Optional [ types . DataSliceOpts ] = None , data_size : Optional [ int ] = None , memcmp_opts : Optional [ List [ types . MemcmpOpts ]] = None , ) -> types . RPCResponse : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for the returned Transaction, either jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. data_size: (optional) Option to compare the program account data length with the provided data size. memcmp_opts: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> memcmp_opts = [ ... types.MemcmpOpts(offset=4, bytes=\"3Mc6vR\"), ... ] >>> asyncio.run(solana_client.get_program_accounts(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\", data_size=17, memcmp_opts=memcmp_opts)) # doctest: +SKIP {'jsonrpc': \"2.0\", 'result' :[{ 'account' :{ 'data' :'2R9jLfiAQ9bgdcw6h8s44439', 'executable' :false, 'lamports' :15298080, 'owner' :'4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T', 'rentEpoch' :28}, 'pubkey' :'CxELquR1gPP8wHe33gZ4QxqGB3sZ9RSwsJ2KshVewkFY'}], 'id' :1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_program_accounts_args ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , data_size = data_size , memcmp_opts = memcmp_opts , ) return await self . _provider . make_request ( * args ) async def get_recent_blockhash ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns a recent block hash from the ledger. Response also includes a fee schedule that can be used to compute the cost of submitting a transaction using it. Deprecated, please use get_latest_blockhash() instead. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_recent_blockhash()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 1637}, 'value': {'blockhash': 'EALChog1mXQ9nEgEUQpWAtmA5UueUZvZiL16ZivmR7eb', 'feeCalculator': {'lamportsPerSignature': 5000}}}, 'id': 2} \"\"\" args = self . _get_recent_blockhash_args ( commitment ) return await self . _provider . make_request ( * args ) async def get_latest_blockhash ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the latest block hash from the ledger. Response also includes the last valid block height. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_latest_blockhash()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 1637}, 'value': {'blockhash': 'EALChog1mXQ9nEgEUQpWAtmA5UueUZvZiL16ZivmR7eb', 'lastValidBlockHeight': 3090}}, 'id': 2} \"\"\" args = self . _get_latest_blockhash_args ( commitment ) return await self . _provider . make_request ( * args ) async def get_signature_statuses ( self , signatures : List [ Union [ str , bytes ]], search_transaction_history : bool = False ) -> types . RPCResponse : \"\"\"Returns the statuses of a list of signatures. Unless the `search_transaction_history` configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus `MAX_RECENT_BLOCKHASHES` rooted slots. Args: signatures: An array of transaction signatures to confirm. search_transaction_history: If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> signatures = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\", ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\"] >>> asyncio.run(solana_client.get_signature_statuses(signatures)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': { 'context': {'slot':82}, 'value': [{ 'slot': 72, 'confirmations': 10, 'err': null, 'status': {'Ok': null}}, null]}, 'id': 1} \"\"\" args = self . _get_signature_statuses_args ( signatures , search_transaction_history ) return await self . _provider . make_request ( * args ) async def get_slot ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the current slot the node is processing. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_slot()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 7515, 'id': 1} \"\"\" args = self . _get_slot_args ( commitment ) return await self . _provider . make_request ( * args ) async def get_slot_leader ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the current slot leader. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_slot_leader()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'EWj2cuEuVhi7RX81cnAY3TzpyFwnHzzVwvuTyfmxmhs3', 'id': 1} \"\"\" args = self . _get_slot_leader_args ( commitment ) return await self . _provider . make_request ( * args ) async def get_stake_activation ( self , pubkey : Union [ PublicKey , str ], epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns epoch activation information for a stake account. Args: pubkey: Pubkey of stake account to query, as base-58 encoded string or PublicKey object. epoch: (optional) Epoch for which to calculate activation details. If parameter not provided, defaults to current epoch. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_stake_activation()) # doctest: +SKIP {'jsonrpc': '2.0','result': {'active': 124429280, 'inactive': 73287840, 'state': 'activating'}, 'id': 1}} \"\"\" args = self . _get_stake_activation_args ( pubkey , epoch , commitment ) return await self . _provider . make_request ( * args ) async def get_supply ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns information about the current supply. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_supply()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 3846}, 'value': {'circulating': 683635192454157660, 'nonCirculating': 316364808037127120, 'nonCirculatingAccounts': ['ETfDYz7Cg5p9SDFmdpRerjBN5puKK7xydEBZZGM2V4Ay', '7cKxv6UznFoWRuJkgw5bWj5rp5PiKTcXZeEaLqyd3Bbm', 'CV7qh8ZoqeUSTQagosGpkLptXoojf9yCszxkRx1jTD12', 'FZ9S7X9jMbCaMyJjRfSoBhFyarUMVwvx7HWRe4LnZHsg', ...] 'total': 1000000000491284780}}, 'id': 1} \"\"\" args = self . _get_supply_args ( commitment ) return await self . _provider . make_request ( * args ) async def get_token_account_balance ( self , pubkey : Union [ str , PublicKey ], commitment : Optional [ Commitment ] = None ): \"\"\"Returns the token balance of an SPL Token account (UNSTABLE). Args: pubkey: Pubkey of Token account to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_token_account_balance(\"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\")) # noqa: E501 # pylint: disable=line-too-long # doctest: +SKIP {'jsonrpc': '2.0','result': { 'context': {'slot':1114}, 'value': { 'uiAmount': 98.64, 'amount': '9864', 'decimals': 2}, 'id' :1} \"\"\" args = self . _get_token_account_balance_args ( pubkey , commitment ) return await self . _provider . make_request ( * args ) async def get_token_accounts_by_delegate ( self , delegate : PublicKey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" args = self . _get_token_accounts_by_delegate_args ( delegate , opts , commitment ) return await self . __get_token_accounts ( * args ) async def get_token_accounts_by_owner ( self , owner : PublicKey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Returns all SPL Token accounts by token owner (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" args = self . _get_token_accounts_by_owner_args ( owner , opts , commitment ) return await self . __get_token_accounts ( * args ) async def __get_token_accounts ( self , method : types . RPCMethod , pubkey : str , opts : types . TokenAccountOpts , commitment : Commitment , ) -> types . RPCResponse : args = self . _get_token_accounts_args ( method , pubkey , opts , commitment ) return await self . _provider . make_request ( * args ) async def get_token_largest_accounts ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the 20 largest accounts of a particular SPL Token type.\"\"\" args = self . _get_token_largest_account_args ( pubkey , commitment ) return await self . _provider . make_request ( * args ) async def get_token_supply ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the total supply of an SPL Token type.\"\"\" args = self . _get_token_supply_args ( pubkey , commitment ) return await self . _provider . make_request ( * args ) async def get_transaction_count ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the current Transaction count from the ledger. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_transaction_count()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 4554, 'id': 1} \"\"\" args = self . _get_transaction_count_args ( commitment ) return await self . _provider . make_request ( * args ) async def get_minimum_ledger_slot ( self ) -> types . RPCResponse : \"\"\"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_minimum_ledger_slot()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1234, 'id': 1} \"\"\" return await self . _provider . make_request ( self . _minimum_ledger_slot ) async def get_version ( self ) -> types . RPCResponse : \"\"\"Returns the current solana versions running on the node. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_version()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'solana-core': '1.4.0 5332fcad'}, 'id': 1} \"\"\" return await self . _provider . make_request ( self . _get_version ) async def get_vote_accounts ( self , commitment : Optional [ Commitment ] = None ): \"\"\"Returns the account info and associated stake for all the voting accounts in the current bank. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_vote_accounts()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'current': [{'activatedStake': 0, 'commission': 100, 'epochCredits': [[165, 714644, 707372], [166, 722092, 714644], [167, 730285, 722092], [168, 738476, 730285], ...] 'epochVoteAccount': True, 'lastVote': 1872294, 'nodePubkey': 'J7v9ndmcoBuo9to2MnHegLnBkC9x3SAVbQBJo5MMJrN1', 'rootSlot': 1872263, 'votePubkey': 'HiFjzpR7e5Kv2tdU9jtE4FbH1X8Z9Syia3Uadadx18b5'}, {'activatedStake': 500029968930560, 'commission': 100, 'epochCredits': [[165, 1359689, 1351498], [166, 1367881, 1359689], [167, 1376073, 1367881], [168, 1384265, 1376073], ...], 'epochVoteAccount': True, 'lastVote': 1872295, 'nodePubkey': 'dv1LfzJvDF7S1fBKpFgKoKXK5yoSosmkAdfbxBo1GqJ', 'rootSlot': 1872264, 'votePubkey': '5MMCR4NbTZqjthjLGywmeT66iwE9J9f7kjtxzJjwfUx2'}, {'activatedStake': 0, 'commission': 100, 'epochCredits': [[227, 2751, 0], [228, 7188, 2751]], 'epochVoteAccount': True, 'lastVote': 1872295, 'nodePubkey': 'H1wDvJ5HJc1SzhHoWtaycpzQpFbsL7g8peaRV3obKShs', 'rootSlot': 1872264, 'votePubkey': 'DPqpgoLQVU3aq72HEqSMsB9qh4KoXc9fGEpvgEuiwnp6'}], 'delinquent': []}, 'id': 1} \"\"\" args = self . _get_vote_accounts_args ( commitment ) return await self . _provider . make_request ( * args ) async def request_airdrop ( self , pubkey : Union [ PublicKey , str ], lamports : int , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Requests an airdrop of lamports to a Pubkey. Args: pubkey: Pubkey of account to receive lamports, as base-58 encoded string or public key object. lamports: Amount of lamports. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solana.publickey import PublicKey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.request_airdrop(PublicKey(1), 10000)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'uK6gbLbhnTEgjgmwn36D5BRTRkG4AT8r7Q162TLnJzQnHUZVL9r6BYZVfRttrhmkmno6Fp4VQELzL4AiriCo61U', 'id': 1} \"\"\" args = self . _request_airdrop_args ( pubkey , lamports , commitment ) return await self . _provider . make_request ( * args ) async def send_raw_transaction ( self , txn : Union [ bytes , str ], opts : Optional [ types . TxOpts ] = None ) -> types . RPCResponse : \"\"\"Send a transaction that has already been signed and serialized into the wire format. Args: txn: Fully-signed Transaction object, a fully sign transaction in wire format, or a fully transaction as base-64 encoded string. opts: (optional) Transaction options. Before submitting, the following preflight checks are performed (unless disabled with the `skip_preflight` option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> full_signed_tx_str = ( ... \"AbN5XM+qw+7oOLsFw7goQSLBis7c1kXJFP6OF4w7YmQNhhbQYcyBiybKuOzzhV7McvoRP3Mey9AhXojtwDCdbwoBAAEDE5j2\" ... \"LG0aRXxRumpLXz29L2n8qTIWIY3ImX5Ba9F9k8poq0Z3/7HyiU3QphU8Ix1F7ENq5TrmAUnb4V8y5LhwPwAAAAAAAAAAAAAA\" ... \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAg5YY9wG6fpuieuWYJd1ta7ZtFPbV0OriFRYdcYUaEGkBAgIAAQwCAAAAQEIPAAAAAAA=\") >>> asyncio.run(solana_client.send_raw_transaction(full_signed_tx_str)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'CMwyESM2NE74mghfbvsHJDERF7xMYKshwwm6VgH6GFqXzx8LfBFuP5ruccumfhTguha6seUHPpiHzzHUQXzq2kN', 'id': 1} \"\"\" # noqa: E501 # pylint: disable=line-too-long opts_to_use = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts args = self . _send_raw_transaction_args ( txn , opts_to_use ) resp = await self . _provider . make_request ( * args ) if opts_to_use . skip_confirmation : return self . _post_send ( resp ) post_send_args = self . _send_raw_transaction_post_send_args ( resp , opts_to_use ) return await self . __post_send_with_confirm ( * post_send_args ) async def send_transaction ( self , txn : Transaction , * signers : Keypair , opts : Optional [ types . TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> types . RPCResponse : \"\"\"Send a transaction. Args: txn: Transaction object. signers: Signers to sign the transaction. opts: (optional) Transaction options. recent_blockhash: (optional) Pass a valid recent blockhash here if you want to skip fetching the recent blockhash or relying on the cache. Example: >>> from solana.keypair import Keypair >>> from solana.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> sender, receiver = Keypair.from_seed(bytes(PublicKey(1))), Keypair.from_seed(bytes(PublicKey(2))) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.public_key, to_pubkey=receiver.public_key, lamports=1000))) >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.send_transaction(txn, sender)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': '236zSA5w4NaVuLXXHK1mqiBuBxkNBu84X6cfLBh1v6zjPrLfyECz4zdedofBaZFhs4gdwzSmij9VkaSo2tR5LTgG', 'id': 12} \"\"\" last_valid_block_height = None if recent_blockhash is None : if self . blockhash_cache : try : recent_blockhash = self . blockhash_cache . get () except ValueError : blockhash_resp = await self . get_latest_blockhash ( Finalized ) recent_blockhash = self . _process_blockhash_resp ( blockhash_resp , used_immediately = True ) last_valid_block_height = blockhash_resp [ \"result\" ][ \"value\" ][ \"lastValidBlockHeight\" ] else : blockhash_resp = await self . get_latest_blockhash ( Finalized ) recent_blockhash = self . parse_recent_blockhash ( blockhash_resp ) last_valid_block_height = blockhash_resp [ \"result\" ][ \"value\" ][ \"lastValidBlockHeight\" ] txn . recent_blockhash = recent_blockhash txn . sign ( * signers ) opts_to_use = ( types . TxOpts ( preflight_commitment = self . _commitment , last_valid_block_height = last_valid_block_height ) if opts is None else opts ) txn_resp = await self . send_raw_transaction ( txn . serialize (), opts = opts_to_use ) if self . blockhash_cache : blockhash_resp = await self . get_latest_blockhash ( Finalized ) self . _process_blockhash_resp ( blockhash_resp , used_immediately = False ) return txn_resp async def simulate_transaction ( self , txn : Union [ bytes , str , Transaction ], sig_verify : bool = False , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Simulate sending a transaction. Args: txn: A Transaction object, a transaction in wire format, or a transaction as base-64 encoded string The transaction must have a valid blockhash, but is not required to be signed. sig_verify: If true the transaction signatures will be verified (default: false). commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> tx_str = ( ... \"4hXTCkRzt9WyecNzV1XPgCDfGAZzQKNxLXgynz5QDuWWPSAZBZSHptvWRL3BjCvzUXRdKvHL2b7yGrRQcWyaqsaBCncVG7BF\" ... \"ggS8w9snUts67BSh3EqKpXLUm5UMHfD7ZBe9GhARjbNQMLJ1QD3Spr6oMTBU6EhdB4RD8CP2xUxr2u3d6fos36PD98XS6oX8\" ... \"TQjLpsMwncs5DAMiD4nNnR8NBfyghGCWvCVifVwvA8B8TJxE1aiyiv2L429BCWfyzAme5sZW8rDb14NeCQHhZbtNqfXhcp2t\" ... ) >>> asyncio.run(solana_client.simulate_transaction(tx_str)) # doctest: +SKIP {'jsonrpc' :'2.0', 'result': {'context': {'slot': 218}, 'value': { 'err': null, 'logs': ['BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success']}, 'id':1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _simulate_transaction_args ( txn , sig_verify , commitment ) return await self . _provider . make_request ( * args ) async def set_log_filter ( self , log_filter : str ) -> types . RPCResponse : \"\"\"Sets the log filter on the validator. Args: log_filter: The new log filter to use. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.set_log_filter(\"solana_core=debug\")) # doctest: +SKIP {'jsonrpc': '2.0', 'result': None, 'id': 1} \"\"\" args = self . _set_log_filter_args ( log_filter ) return await self . _provider . make_request ( * args ) async def validator_exit ( self ) -> types . RPCResponse : \"\"\"Request to have the validator exit. Validator must have booted with RPC exit enabled (`--enable-rpc-exit` parameter). Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> solana_client.validator_exit() # doctest: +SKIP {'jsonrpc': '2.0', 'result': true, 'id': 1} \"\"\" return await self . _provider . make_request ( self . _validator_exit ) async def __post_send_with_confirm ( self , resp : types . RPCResponse , conf_comm : Commitment , last_valid_block_height : Optional [ int ] ) -> types . RPCResponse : resp = self . _post_send ( resp ) self . _provider . logger . info ( \"Transaction sent to %s . Signature %s : \" , self . _provider . endpoint_uri , resp [ \"result\" ] ) await self . confirm_transaction ( resp [ \"result\" ], conf_comm , last_valid_block_height = last_valid_block_height ) return resp async def confirm_transaction ( self , tx_sig : str , commitment : Optional [ Commitment ] = None , sleep_seconds : float = 0.5 , last_valid_block_height : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Confirm the transaction identified by the specified signature. Args: tx_sig: the transaction signature to confirm. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". sleep_seconds: The number of seconds to sleep when polling the signature status. last_valid_block_height: The block height by which the transaction would become invalid. \"\"\" commitment_to_use = self . _commitment if commitment is None else commitment commitment_rank = COMMITMENT_RANKS [ commitment_to_use ] if last_valid_block_height : # pylint: disable=no-else-return current_blockheight = ( await self . get_block_height ( commitment ))[ \"result\" ] while current_blockheight <= last_valid_block_height : resp = await self . get_signature_statuses ([ tx_sig ]) maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) resp_value = resp [ \"result\" ][ \"value\" ][ 0 ] if resp_value is not None : confirmation_status = resp_value [ \"confirmationStatus\" ] confirmation_rank = COMMITMENT_RANKS [ confirmation_status ] if confirmation_rank >= commitment_rank : break current_blockheight = ( await self . get_block_height ( commitment ))[ \"result\" ] await asyncio . sleep ( sleep_seconds ) else : maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) raise TransactionExpiredBlockheightExceededError ( f \" { tx_sig } has expired: block height exceeded\" ) return resp else : timeout = time () + 30 while time () < timeout : resp = await self . get_signature_statuses ([ tx_sig ]) maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) resp_value = resp [ \"result\" ][ \"value\" ][ 0 ] if resp_value is not None : confirmation_status = resp_value [ \"confirmationStatus\" ] confirmation_rank = COMMITMENT_RANKS [ confirmation_status ] if confirmation_rank >= commitment_rank : break await asyncio . sleep ( sleep_seconds ) else : maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) raise UnconfirmedTxError ( f \"Unable to confirm transaction { tx_sig } \" ) return resp __init__ ( self , endpoint = None , commitment = None , blockhash_cache = False , timeout = 10 ) special Init API client. Source code in solana/rpc/async_api.py def __init__ ( self , endpoint : Optional [ str ] = None , commitment : Optional [ Commitment ] = None , blockhash_cache : Union [ BlockhashCache , bool ] = False , timeout : float = 10 , ) -> None : \"\"\"Init API client.\"\"\" super () . __init__ ( commitment , blockhash_cache ) self . _provider = async_http . AsyncHTTPProvider ( endpoint , timeout = timeout ) close ( self ) async Use this when you are done with the client. Source code in solana/rpc/async_api.py async def close ( self ) -> None : \"\"\"Use this when you are done with the client.\"\"\" await self . _provider . close () confirm_transaction ( self , tx_sig , commitment = None , sleep_seconds = 0.5 , last_valid_block_height = None ) async Confirm the transaction identified by the specified signature. Parameters: Name Type Description Default tx_sig str the transaction signature to confirm. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None sleep_seconds float The number of seconds to sleep when polling the signature status. 0.5 last_valid_block_height Optional[int] The block height by which the transaction would become invalid. None Source code in solana/rpc/async_api.py async def confirm_transaction ( self , tx_sig : str , commitment : Optional [ Commitment ] = None , sleep_seconds : float = 0.5 , last_valid_block_height : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Confirm the transaction identified by the specified signature. Args: tx_sig: the transaction signature to confirm. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". sleep_seconds: The number of seconds to sleep when polling the signature status. last_valid_block_height: The block height by which the transaction would become invalid. \"\"\" commitment_to_use = self . _commitment if commitment is None else commitment commitment_rank = COMMITMENT_RANKS [ commitment_to_use ] if last_valid_block_height : # pylint: disable=no-else-return current_blockheight = ( await self . get_block_height ( commitment ))[ \"result\" ] while current_blockheight <= last_valid_block_height : resp = await self . get_signature_statuses ([ tx_sig ]) maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) resp_value = resp [ \"result\" ][ \"value\" ][ 0 ] if resp_value is not None : confirmation_status = resp_value [ \"confirmationStatus\" ] confirmation_rank = COMMITMENT_RANKS [ confirmation_status ] if confirmation_rank >= commitment_rank : break current_blockheight = ( await self . get_block_height ( commitment ))[ \"result\" ] await asyncio . sleep ( sleep_seconds ) else : maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) raise TransactionExpiredBlockheightExceededError ( f \" { tx_sig } has expired: block height exceeded\" ) return resp else : timeout = time () + 30 while time () < timeout : resp = await self . get_signature_statuses ([ tx_sig ]) maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) resp_value = resp [ \"result\" ][ \"value\" ][ 0 ] if resp_value is not None : confirmation_status = resp_value [ \"confirmationStatus\" ] confirmation_rank = COMMITMENT_RANKS [ confirmation_status ] if confirmation_rank >= commitment_rank : break await asyncio . sleep ( sleep_seconds ) else : maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) raise UnconfirmedTxError ( f \"Unable to confirm transaction { tx_sig } \" ) return resp get_account_info ( self , pubkey , commitment = None , encoding = 'base64' , data_slice = None ) async Returns all the account info for the specified public key. Parameters: Name Type Description Default pubkey Union[solana.publickey.PublicKey, str] Pubkey of account to query, as base-58 encoded string or PublicKey object. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding str (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". \"base58\" is limited to Account data of less than 128 bytes. \"base64\" will return base64 encoded data for Account data of any size. \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). 'base64' data_slice Optional[solana.rpc.types.DataSliceOpts] (optional) Option to limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None Examples: >>> from solana.publickey import PublicKey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_account_info ( PublicKey ( 1 ))) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 33265073 }, 'value' : { 'data' : '' , 'executable' : False , 'lamports' : 4459816188034584 , 'owner' : '11111111111111111111111111111111' , 'rentEpoch' : 90 }}, 'id' : 1 } Source code in solana/rpc/async_api.py async def get_account_info ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> types . RPCResponse : \"\"\"Returns all the account info for the specified public key. Args: pubkey: Pubkey of account to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. - \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solana.publickey import PublicKey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_account_info(PublicKey(1))) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 33265073}, 'value': {'data': '', 'executable': False, 'lamports': 4459816188034584, 'owner': '11111111111111111111111111111111', 'rentEpoch': 90}}, 'id': 1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_account_info_args ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , min_context_slot = None ) return await self . _provider . make_request ( * args ) get_balance ( self , pubkey , commitment = None ) async Returns the balance of the account of provided Pubkey. Parameters: Name Type Description Default pubkey Union[solana.publickey.PublicKey, str] Pubkey of account to query, as base-58 encoded string or PublicKey object. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solana.publickey import PublicKey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_balance ( PublicKey ( 1 ))) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 228 }, 'value' : 0 }, 'id' : 1 } Source code in solana/rpc/async_api.py async def get_balance ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the balance of the account of provided Pubkey. Args: pubkey: Pubkey of account to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solana.publickey import PublicKey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_balance(PublicKey(1))) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 228}, 'value': 0}, 'id': 1} \"\"\" args = self . _get_balance_args ( pubkey , commitment ) return await self . _provider . make_request ( * args ) get_block ( self , slot , encoding = 'json' ) async Returns identity and transaction information about a confirmed block in the ledger. Parameters: Name Type Description Default slot int Slot, as u64 integer. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_block ( 1 )) { 'jsonrpc' : '2.0' , 'result' : { 'blockTime' : None , 'blockHeight' : 0 , 'blockhash' : '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj' , 'parentSlot' : 0 , 'previousBlockhash' : 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2' , 'rewards' : [], 'transactions' : [{ 'meta' : { 'err' : None , 'fee' : 0 , 'postBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'preBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'status' : { 'Ok' : None }}, 'transaction' : { 'message' : { 'accountKeys' : [ 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk' , 'EKAar3bMQUZvGSonq7vcPF2nPaCYowbnat44FPafW8Po' , 'SysvarS1otHashes111111111111111111111111111' , 'SysvarC1ock11111111111111111111111111111111' , 'Vote111111111111111111111111111111111111111' ], 'header' : { 'numReadonlySignedAccounts' : 0 , 'numReadonlyUnsignedAccounts' : 3 , 'numRequiredSignatures' : 1 }, 'instructions' : [{ 'accounts' : [ 1 , 2 , 3 , 0 ], 'data' : '37u9WtQpcm6ULa3VmTgTKEBCtYMxq84mk82tRvKdFEwj3rALiptAzuMJ1yoVSFAMARMZYp7q' , 'programIdIndex' : 4 }], 'recentBlockhash' : 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2' }, 'signatures' : [ '63jnpMCs7TNnCjnTqUrX7Mvqc5CbJMtVkLxBjPHUQkjXyZrQuZpfhjvzA7A29D9tMqVaiQC3UNP1NeaZKFFHJyQE' ]}}]}, 'id' : 9 } >>> asyncio . run ( solana_client . get_block ( 1 , encoding = \"base64\" )) { 'jsonrpc' : '2.0' , 'result' : { 'blockTime' : None , 'blockHeight' : 0 , 'blockhash' : '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj' , 'parentSlot' : 0 , 'previousBlockhash' : 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2' , 'rewards' : [], 'transactions' : [{ 'meta' : { 'err' : None , 'fee' : 0 , 'postBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'preBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'status' : { 'Ok' : None }}, 'transaction' : [ 'AfxyKHmHIjXWjkyHODGeAbVxmfQWPj1ydS9nF+ynJHo8I1vCPDp2P9Cj5aA6W1CAHEHCqY0B1FDKomCzRo3qrAsBAAMFBQ6QBWfhQF7rG02xhuEsmmrUtz3AUjBtJKkqaHPJEmvFzziDX0C0robPrl9RbOyXHoc9/Dxa0zoGL6cEjvCjLgan1RcZLwqvxvJl4/t3zHragsUp0L47E24tAFUgAAAABqfVFxjHdMkoVmOYaR1etoteuKObS21cc1VbIQAAAAAHYUgdNXR0u3xNdiTr072z2DVec9EQQ/wNo1OAAAAAAM8NSv7ISDPN9E9XNL9vX7h8LuJHWlopUcX39DxsDx23AQQEAQIDADUCAAAAAQAAAAAAAAAAAAAAAAAAAIWWp5Il3Kg312pzVk6Jt61iyFhTbtmkh/ORbj3JUQRbAA==' , 'base64' ]}]}, 'id' : 10 } Source code in solana/rpc/async_api.py async def get_block ( self , slot : int , encoding : str = \"json\" , ) -> types . RPCResponse : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_block(1)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockHeight': 0, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': {'message': {'accountKeys': ['LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk', 'EKAar3bMQUZvGSonq7vcPF2nPaCYowbnat44FPafW8Po', 'SysvarS1otHashes111111111111111111111111111', 'SysvarC1ock11111111111111111111111111111111', 'Vote111111111111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 3, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [1, 2, 3, 0], 'data': '37u9WtQpcm6ULa3VmTgTKEBCtYMxq84mk82tRvKdFEwj3rALiptAzuMJ1yoVSFAMARMZYp7q', 'programIdIndex': 4}], 'recentBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2'}, 'signatures': ['63jnpMCs7TNnCjnTqUrX7Mvqc5CbJMtVkLxBjPHUQkjXyZrQuZpfhjvzA7A29D9tMqVaiQC3UNP1NeaZKFFHJyQE']}}]}, 'id': 9} >>> asyncio.run(solana_client.get_block(1, encoding=\"base64\")) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockHeight': 0, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': ['AfxyKHmHIjXWjkyHODGeAbVxmfQWPj1ydS9nF+ynJHo8I1vCPDp2P9Cj5aA6W1CAHEHCqY0B1FDKomCzRo3qrAsBAAMFBQ6QBWfhQF7rG02xhuEsmmrUtz3AUjBtJKkqaHPJEmvFzziDX0C0robPrl9RbOyXHoc9/Dxa0zoGL6cEjvCjLgan1RcZLwqvxvJl4/t3zHragsUp0L47E24tAFUgAAAABqfVFxjHdMkoVmOYaR1etoteuKObS21cc1VbIQAAAAAHYUgdNXR0u3xNdiTr072z2DVec9EQQ/wNo1OAAAAAAM8NSv7ISDPN9E9XNL9vX7h8LuJHWlopUcX39DxsDx23AQQEAQIDADUCAAAAAQAAAAAAAAAAAAAAAAAAAIWWp5Il3Kg312pzVk6Jt61iyFhTbtmkh/ORbj3JUQRbAA==', 'base64']}]}, 'id': 10} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_block_args ( slot , encoding ) return await self . _provider . make_request ( * args ) get_block_commitment ( self , slot ) async Fetch the commitment for particular block. Parameters: Name Type Description Default slot int Block, identified by Slot. required Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_block_commitment ( 0 )) { 'jsonrpc' : '2.0' , 'result' : { 'commitment' : [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 497717120 ], 'totalStake' : 497717120 }, 'id' : 1 }} Source code in solana/rpc/async_api.py async def get_block_commitment ( self , slot : int ) -> types . RPCResponse : \"\"\"Fetch the commitment for particular block. Args: slot: Block, identified by Slot. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_block_commitment(0)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'commitment': [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 497717120], 'totalStake': 497717120}, 'id': 1}} \"\"\" args = self . _get_block_commitment_args ( slot ) return await self . _provider . make_request ( * args ) get_block_height ( self , commitment = None ) async Returns the current block height of the node. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_block_height ()) { 'jsonrpc' : '2.0' , 'result' : 1233 , 'id' : 1 } Source code in solana/rpc/async_api.py async def get_block_height ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the current block height of the node. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_block_height()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1233, 'id': 1} \"\"\" args = self . _get_block_height_args ( commitment ) return await self . _provider . make_request ( * args ) get_block_time ( self , slot ) async Fetch the estimated production time of a block. Parameters: Name Type Description Default slot int Block, identified by Slot. required Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_block_time ( 5 )) { 'jsonrpc' : '2.0' , 'result' : 1598400007 , 'id' : 1 } Source code in solana/rpc/async_api.py async def get_block_time ( self , slot : int ) -> types . RPCResponse : \"\"\"Fetch the estimated production time of a block. Args: slot: Block, identified by Slot. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_block_time(5)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1598400007, 'id': 1} \"\"\" args = self . _get_block_time_args ( slot ) return await self . _provider . make_request ( * args ) get_blocks ( self , start_slot , end_slot = None ) async Returns a list of confirmed blocks. Parameters: Name Type Description Default start_slot int Start slot, as u64 integer. required end_slot Optional[int] (optional) End slot, as u64 integer. None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_blocks ( 5 , 10 )) { 'jsonrpc' : '2.0' , 'result' : [ 5 , 6 , 7 , 8 , 9 , 10 ], 'id' : 1 } Source code in solana/rpc/async_api.py async def get_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> types . RPCResponse : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_blocks(5, 10)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [5, 6, 7, 8, 9, 10], 'id': 1} \"\"\" args = self . _get_blocks_args ( start_slot , end_slot ) return await self . _provider . make_request ( * args ) get_cluster_nodes ( self ) async Returns information about all the nodes participating in the cluster. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_cluster_nodes ()) { 'jsonrpc' : '2.0' , 'result' : [{ 'gossip' : '127.0.0.1:8001' , 'pubkey' : 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk' , 'rpc' : '127.0.0.1:8899' , 'tpu' : '127.0.0.1:8003' , 'version' : '1.4.0 5332fcad' }], 'id' : 1 } Source code in solana/rpc/async_api.py async def get_cluster_nodes ( self ) -> types . RPCResponse : \"\"\"Returns information about all the nodes participating in the cluster. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_cluster_nodes()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [{'gossip': '127.0.0.1:8001', 'pubkey': 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk', 'rpc': '127.0.0.1:8899', 'tpu': '127.0.0.1:8003', 'version': '1.4.0 5332fcad'}], 'id': 1} \"\"\" return await self . _provider . make_request ( self . _get_cluster_nodes ) get_confirmed_block ( self , slot , encoding = 'json' ) async Returns identity and transaction information about a confirmed block in the ledger. Parameters: Name Type Description Default slot int Slot, as u64 integer. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_confirmed_block ( 1 )) { 'jsonrpc' : '2.0' , 'result' : { 'blockTime' : None , 'blockhash' : '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj' , 'parentSlot' : 0 , 'previousBlockhash' : 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2' , 'rewards' : [], 'transactions' : [{ 'meta' : { 'err' : None , 'fee' : 0 , 'postBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'preBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'status' : { 'Ok' : None }}, 'transaction' : { 'message' : { 'accountKeys' : [ 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk' , 'EKAar3bMQUZvGSonq7vcPF2nPaCYowbnat44FPafW8Po' , 'SysvarS1otHashes111111111111111111111111111' , 'SysvarC1ock11111111111111111111111111111111' , 'Vote111111111111111111111111111111111111111' ], 'header' : { 'numReadonlySignedAccounts' : 0 , 'numReadonlyUnsignedAccounts' : 3 , 'numRequiredSignatures' : 1 }, 'instructions' : [{ 'accounts' : [ 1 , 2 , 3 , 0 ], 'data' : '37u9WtQpcm6ULa3VmTgTKEBCtYMxq84mk82tRvKdFEwj3rALiptAzuMJ1yoVSFAMARMZYp7q' , 'programIdIndex' : 4 }], 'recentBlockhash' : 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2' }, 'signatures' : [ '63jnpMCs7TNnCjnTqUrX7Mvqc5CbJMtVkLxBjPHUQkjXyZrQuZpfhjvzA7A29D9tMqVaiQC3UNP1NeaZKFFHJyQE' ]}}]}, 'id' : 9 } >>> asyncio . run ( solana_client . get_confirmed_block ( 1 , encoding = \"base64\" )) { 'jsonrpc' : '2.0' , 'result' : { 'blockTime' : None , 'blockhash' : '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj' , 'parentSlot' : 0 , 'previousBlockhash' : 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2' , 'rewards' : [], 'transactions' : [{ 'meta' : { 'err' : None , 'fee' : 0 , 'postBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'preBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'status' : { 'Ok' : None }}, 'transaction' : [ 'AfxyKHmHIjXWjkyHODGeAbVxmfQWPj1ydS9nF+ynJHo8I1vCPDp2P9Cj5aA6W1CAHEHCqY0B1FDKomCzRo3qrAsBAAMFBQ6QBWfhQF7rG02xhuEsmmrUtz3AUjBtJKkqaHPJEmvFzziDX0C0robPrl9RbOyXHoc9/Dxa0zoGL6cEjvCjLgan1RcZLwqvxvJl4/t3zHragsUp0L47E24tAFUgAAAABqfVFxjHdMkoVmOYaR1etoteuKObS21cc1VbIQAAAAAHYUgdNXR0u3xNdiTr072z2DVec9EQQ/wNo1OAAAAAAM8NSv7ISDPN9E9XNL9vX7h8LuJHWlopUcX39DxsDx23AQQEAQIDADUCAAAAAQAAAAAAAAAAAAAAAAAAAIWWp5Il3Kg312pzVk6Jt61iyFhTbtmkh/ORbj3JUQRbAA==' , 'base64' ]}]}, 'id' : 10 } Source code in solana/rpc/async_api.py async def get_confirmed_block ( self , slot : int , encoding : str = \"json\" , ) -> types . RPCResponse : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_confirmed_block(1)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': {'message': {'accountKeys': ['LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk', 'EKAar3bMQUZvGSonq7vcPF2nPaCYowbnat44FPafW8Po', 'SysvarS1otHashes111111111111111111111111111', 'SysvarC1ock11111111111111111111111111111111', 'Vote111111111111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 3, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [1, 2, 3, 0], 'data': '37u9WtQpcm6ULa3VmTgTKEBCtYMxq84mk82tRvKdFEwj3rALiptAzuMJ1yoVSFAMARMZYp7q', 'programIdIndex': 4}], 'recentBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2'}, 'signatures': ['63jnpMCs7TNnCjnTqUrX7Mvqc5CbJMtVkLxBjPHUQkjXyZrQuZpfhjvzA7A29D9tMqVaiQC3UNP1NeaZKFFHJyQE']}}]}, 'id': 9} >>> asyncio.run(solana_client.get_confirmed_block(1, encoding=\"base64\")) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': ['AfxyKHmHIjXWjkyHODGeAbVxmfQWPj1ydS9nF+ynJHo8I1vCPDp2P9Cj5aA6W1CAHEHCqY0B1FDKomCzRo3qrAsBAAMFBQ6QBWfhQF7rG02xhuEsmmrUtz3AUjBtJKkqaHPJEmvFzziDX0C0robPrl9RbOyXHoc9/Dxa0zoGL6cEjvCjLgan1RcZLwqvxvJl4/t3zHragsUp0L47E24tAFUgAAAABqfVFxjHdMkoVmOYaR1etoteuKObS21cc1VbIQAAAAAHYUgdNXR0u3xNdiTr072z2DVec9EQQ/wNo1OAAAAAAM8NSv7ISDPN9E9XNL9vX7h8LuJHWlopUcX39DxsDx23AQQEAQIDADUCAAAAAQAAAAAAAAAAAAAAAAAAAIWWp5Il3Kg312pzVk6Jt61iyFhTbtmkh/ORbj3JUQRbAA==', 'base64']}]}, 'id': 10} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_confirmed_block_args ( slot , encoding ) return await self . _provider . make_request ( * args ) get_confirmed_blocks ( self , start_slot , end_slot = None ) async Returns a list of confirmed blocks. Parameters: Name Type Description Default start_slot int Start slot, as u64 integer. required end_slot Optional[int] (optional) End slot, as u64 integer. None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_confirmed_blocks ( 5 , 10 )) { 'jsonrpc' : '2.0' , 'result' : [ 5 , 6 , 7 , 8 , 9 , 10 ], 'id' : 1 } Source code in solana/rpc/async_api.py async def get_confirmed_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> types . RPCResponse : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_confirmed_blocks(5, 10)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [5, 6, 7, 8, 9, 10], 'id': 1} \"\"\" args = self . _get_confirmed_blocks_args ( start_slot , end_slot ) return await self . _provider . make_request ( * args ) get_confirmed_signature_for_address2 ( self , account , before = None , until = None , limit = None , commitment = None ) async Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Parameters: Name Type Description Default account Union[str, solana.keypair.Keypair, solana.publickey.PublicKey] Account to be queried. required before Optional[str] (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. None until Optional[str] (optional) Search until this transaction signature, if found before limit reached. None limit Optional[int] (optoinal) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). None commitment Optional[Commitment] (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_confirmed_signature_for_address2 ( \"Vote111111111111111111111111111111111111111\" , limit = 1 )) { 'jsonrpc' : '2.0' , 'result' : [{ 'err' : None , 'memo' : None , 'signature' : 'v1BK8XcaPBzAGd7TB1K53pMdi6TBGe5CLCgx8cmZ4Bj63ZNvA6ca2QaxFpBFdvmpoFQ51VorBjifkBGLTDhwpqN' , 'slot' : 4290 }], 'id' : 2 } Source code in solana/rpc/async_api.py async def get_confirmed_signature_for_address2 ( self , account : Union [ str , Keypair , PublicKey ], before : Optional [ str ] = None , until : Optional [ str ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optoinal) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_confirmed_signature_for_address2(\"Vote111111111111111111111111111111111111111\", limit=1)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [{'err': None, 'memo': None, 'signature': 'v1BK8XcaPBzAGd7TB1K53pMdi6TBGe5CLCgx8cmZ4Bj63ZNvA6ca2QaxFpBFdvmpoFQ51VorBjifkBGLTDhwpqN', 'slot': 4290}], 'id': 2} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_confirmed_signature_for_address2_args ( account , before , until , limit , commitment ) return await self . _provider . make_request ( * args ) get_confirmed_transaction ( self , tx_sig , encoding = 'json' ) async Returns transaction details for a confirmed transaction. Parameters: Name Type Description Default tx_sig str Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the transaction.message.instructions list. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_confirmed_transaction ( \"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\" )) { 'jsonrpc' : '2.0' , 'result' : { 'meta' : { 'err' : None , 'fee' : 5000 , 'postBalances' : [ 498449233720610510 , 1000001001987940 , 1 ], 'preBalances' : [ 498449233721615510 , 1000001000987940 , 1 ], 'status' : { 'Ok' : None }}, 'slot' : 1659335 , 'transaction' : { 'message' : { 'accountKeys' : [ '9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g' , '2KW2XRd9kwqet15Aha2oK3tYvd3nWbTFH1MBiRAv1BE1' , '11111111111111111111111111111111' ], 'header' : { 'numReadonlySignedAccounts' : 0 , 'numReadonlyUnsignedAccounts' : 1 , 'numRequiredSignatures' : 1 }, 'instructions' : [{ 'accounts' : [ 0 , 1 ], 'data' : '3Bxs4Bc3VYuGVB19' , 'programIdIndex' : 2 }], 'recentBlockhash' : 'FwcsKNptGtMLccXAA9YgnivVFK95mKzECLT1DNPi3SDr' }, 'signatures' : [ '3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy' ]}}, 'id' : 4 } Source code in solana/rpc/async_api.py async def get_confirmed_transaction ( self , tx_sig : str , encoding : str = \"json\" ) -> types . RPCResponse : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_confirmed_transaction(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\")) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'meta': {'err': None, 'fee': 5000, 'postBalances': [498449233720610510, 1000001001987940, 1], 'preBalances': [498449233721615510, 1000001000987940, 1], 'status': {'Ok': None}}, 'slot': 1659335, 'transaction': {'message': {'accountKeys': ['9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g', '2KW2XRd9kwqet15Aha2oK3tYvd3nWbTFH1MBiRAv1BE1', '11111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 1, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [0, 1], 'data': '3Bxs4Bc3VYuGVB19', 'programIdIndex': 2}], 'recentBlockhash': 'FwcsKNptGtMLccXAA9YgnivVFK95mKzECLT1DNPi3SDr'}, 'signatures': ['3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy']}}, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_confirmed_transaction_args ( tx_sig , encoding ) return await self . _provider . make_request ( * args ) get_epoch_info ( self , commitment = None ) async Returns information about the current epoch. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_epoch_info ()) { 'jsonrpc' : '2.0' , 'result' : { 'absoluteSlot' : 5150 , 'blockHeight' : 5150 , 'epoch' : 0 , 'slotIndex' : 5150 , 'slotsInEpoch' : 8192 }, 'id' : 5 } Source code in solana/rpc/async_api.py async def get_epoch_info ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns information about the current epoch. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_epoch_info()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'absoluteSlot': 5150, 'blockHeight': 5150, 'epoch': 0, 'slotIndex': 5150, 'slotsInEpoch': 8192}, 'id': 5} \"\"\" args = self . _get_epoch_info_args ( commitment ) return await self . _provider . make_request ( * args ) get_epoch_schedule ( self ) async Returns epoch schedule information from this cluster's genesis config. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_epoch_schedule ()) { 'jsonrpc' : '2.0' , 'result' : { 'firstNormalEpoch' : 0 , 'firstNormalSlot' : 0 , 'leaderScheduleSlotOffset' : 8192 , 'slotsPerEpoch' : 8192 , 'warmup' : False }, 'id' : 6 } Source code in solana/rpc/async_api.py async def get_epoch_schedule ( self ) -> types . RPCResponse : \"\"\"Returns epoch schedule information from this cluster's genesis config. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_epoch_schedule()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'firstNormalEpoch': 0, 'firstNormalSlot': 0, 'leaderScheduleSlotOffset': 8192, 'slotsPerEpoch': 8192, 'warmup': False}, 'id': 6} \"\"\" return await self . _provider . make_request ( self . _get_epoch_schedule ) get_fee_calculator_for_blockhash ( self , blockhash , commitment = None ) async Returns the fee calculator associated with the query blockhash, or null if the blockhash has expired. Parameters: Name Type Description Default blockhash Union[str, Blockhash] Blockhash to query as a Base58 encoded string. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_fee_calculator_for_blockhash ( \"BaQSR194dC4dZaRxATtxYyEwDkk7VgqUY8NVNkub8HFZ\" )) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 7065 }, 'value' : { 'feeCalculator' : { 'lamportsPerSignature' : 5000 }}}, 'id' : 4 } Source code in solana/rpc/async_api.py async def get_fee_calculator_for_blockhash ( self , blockhash : Union [ str , Blockhash ], commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the fee calculator associated with the query blockhash, or null if the blockhash has expired. Args: blockhash: Blockhash to query as a Base58 encoded string. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_fee_calculator_for_blockhash(\"BaQSR194dC4dZaRxATtxYyEwDkk7VgqUY8NVNkub8HFZ\")) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 7065}, 'value': {'feeCalculator': {'lamportsPerSignature': 5000}}}, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_fee_calculator_for_blockhash_args ( blockhash , commitment ) return await self . _provider . make_request ( * args ) get_fee_for_message ( self , message , commitment = None ) async Returns the fee for a message. Parameters: Name Type Description Default message Message Message that the fee is requested for. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solana.keypair import Keypair >>> from solana.system_program import TransferParams , transfer >>> from solana.transaction import Transaction >>> sender , receiver = Keypair . from_seed ( bytes ( PublicKey ( 1 ))), Keypair . from_seed ( bytes ( PublicKey ( 2 ))) >>> txn = Transaction () . add ( transfer ( TransferParams ( ... from_pubkey = sender . public_key , to_pubkey = receiver . public_key , lamports = 1000 ))) >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_fee_for_message ( txn . compile_message ())) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 5068 }, 'value' : 5000 }, 'id' : 4 } Source code in solana/rpc/async_api.py async def get_fee_for_message ( self , message : Message , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the fee for a message. Args: message: Message that the fee is requested for. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solana.keypair import Keypair >>> from solana.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> sender, receiver = Keypair.from_seed(bytes(PublicKey(1))), Keypair.from_seed(bytes(PublicKey(2))) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.public_key, to_pubkey=receiver.public_key, lamports=1000))) >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_fee_for_message(txn.compile_message())) # doctest: +SKIP {'jsonrpc': '2.0', 'result': { 'context': { 'slot': 5068 }, 'value': 5000 }, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long if isinstance ( message , Transaction ): raise TransactionUncompiledError ( \"Transaction uncompiled, please compile to message first.\" ) args = self . _get_fee_for_message_args ( message , commitment ) return await self . _provider . make_request ( * args ) get_fee_rate_governor ( self ) async Return the fee rate governor information from the root bank. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_fee_rate_governor ()) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 7172 }, 'value' : { 'feeRateGovernor' : { 'burnPercent' : 50 , 'maxLamportsPerSignature' : 100000 , 'minLamportsPerSignature' : 5000 , 'targetLamportsPerSignature' : 10000 , 'targetSignaturesPerSlot' : 20000 }}}, 'id' : 5 } Source code in solana/rpc/async_api.py async def get_fee_rate_governor ( self ) -> types . RPCResponse : \"\"\"Return the fee rate governor information from the root bank. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_fee_rate_governor()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 7172}, 'value': {'feeRateGovernor': {'burnPercent': 50, 'maxLamportsPerSignature': 100000, 'minLamportsPerSignature': 5000, 'targetLamportsPerSignature': 10000, 'targetSignaturesPerSlot': 20000}}}, 'id': 5} \"\"\" return await self . _provider . make_request ( self . _get_fee_rate_governor ) get_fees ( self , commitment = None ) async Returns a recent block hash from the ledger, a fee schedule and the last slot the blockhash will be valid. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_fees ()) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 7727 }, 'value' : { 'blockhash' : 'GGS6AEDqjF5irU6D6VQNherEZ2hckGaeBiVdfSZKg4gd' , 'feeCalculator' : { 'lamportsPerSignature' : 5000 }, 'lastValidSlot' : 8027 }}, 'id' : 1 } Source code in solana/rpc/async_api.py async def get_fees ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns a recent block hash from the ledger, a fee schedule and the last slot the blockhash will be valid. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_fees()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 7727}, 'value': {'blockhash': 'GGS6AEDqjF5irU6D6VQNherEZ2hckGaeBiVdfSZKg4gd', 'feeCalculator': {'lamportsPerSignature': 5000}, 'lastValidSlot': 8027}}, 'id': 1} \"\"\" args = self . _get_fees_args ( commitment ) return await self . _provider . make_request ( * args ) get_first_available_block ( self ) async Returns the slot of the lowest confirmed block that has not been purged from the ledger. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_fees ()) { 'jsonrpc' : '2.0' , 'result' : 1 , 'id' : 2 } Source code in solana/rpc/async_api.py async def get_first_available_block ( self ) -> types . RPCResponse : \"\"\"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_fees()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1, 'id': 2} \"\"\" return await self . _provider . make_request ( self . _get_first_available_block ) get_genesis_hash ( self ) async Returns the genesis hash. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_genesis_hash ()) { 'jsonrpc' : '2.0' , 'result' : 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2' , 'id' : 3 } Source code in solana/rpc/async_api.py async def get_genesis_hash ( self ) -> types . RPCResponse : \"\"\"Returns the genesis hash. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_genesis_hash()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'id': 3} \"\"\" return await self . _provider . make_request ( self . _get_genesis_hash ) get_identity ( self ) async Returns the identity pubkey for the current node. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_identity ()) { 'jsonrpc' : '2.0' , 'result' : { 'identity' : 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk' }, 'id' : 4 } Source code in solana/rpc/async_api.py async def get_identity ( self ) -> types . RPCResponse : \"\"\"Returns the identity pubkey for the current node. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_identity()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'identity': 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk'}, 'id': 4} \"\"\" return await self . _provider . make_request ( self . _get_identity ) get_inflation_governor ( self , commitment = None ) async Returns the current inflation governor. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_inflation_governor ()) { 'jsonrpc' : '2.0' , 'result' : { 'foundation' : 0.05 , 'foundationTerm' : 7.0 , 'initial' : 0.15 , 'taper' : 0.15 , 'terminal' : 0.015 }, 'id' : 5 } Source code in solana/rpc/async_api.py async def get_inflation_governor ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the current inflation governor. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_inflation_governor()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'foundation': 0.05, 'foundationTerm': 7.0, 'initial': 0.15, 'taper': 0.15, 'terminal': 0.015}, 'id': 5} \"\"\" args = self . _get_inflation_governor_args ( commitment ) return await self . _provider . make_request ( * args ) get_inflation_rate ( self ) async Returns the specific inflation values for the current epoch. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_inflation_rate ()) { 'jsonrpc' : '2.0' , 'result' : { 'epoch' : 1 , 'foundation' : 0.007499746885736559 , 'total' : 0.14999493771473116 , 'validator' : 0.1424951908289946 }, 'id' : 1 } Source code in solana/rpc/async_api.py async def get_inflation_rate ( self ) -> types . RPCResponse : \"\"\"Returns the specific inflation values for the current epoch. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_inflation_rate()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'epoch': 1, 'foundation': 0.007499746885736559, 'total': 0.14999493771473116, 'validator': 0.1424951908289946}, 'id': 1} \"\"\" return await self . _provider . make_request ( self . _get_inflation_rate ) get_largest_accounts ( self , filter_opt = None , commitment = None ) async Returns the 20 largest accounts, by lamport balance. Parameters: Name Type Description Default filter_opt Optional[str] Filter results by account type; currently supported: circulating|nonCirculating. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_largest_accounts ()) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 8890 }, 'value' : [{ 'address' : '95L7AsBCLRsqghsi6ksZkzjNbs6rqDgHCzKaGZ7bJi75' , 'lamports' : 500000000000000000 }, { 'address' : 'APnSR52EC1eH676m7qTBHUJ1nrGpHYpV7XKPxgRDD8gX' , 'lamports' : 164511033098290000 }, { 'address' : '13LeFbG6m2EP1fqCj9k66fcXsoTHMMtgr7c78AivUrYD' , 'lamports' : 153333632446109120 }, { 'address' : 'GK2zqSsXLA2rwVZk347RYhh6jJpRsCA69FjLW93ZGi3B' , 'lamports' : 57499999036109120 }, { 'address' : '8HVqyX9jebh31Q9Hp8t5sMVJs665979ZeEr3eCfzitUe' , 'lamports' : 30301031036109120 }, { 'address' : 'HbZ5FfmKWNHC7uwk6TF1hVi6TCs7dtYfdjEcuPGgzFAg' , 'lamports' : 14999999036109120 }, { 'address' : '14FUT96s9swbmH7ZjpDvfEDywnAYy9zaNhv4xvezySGu' , 'lamports' : 4999999036109120 }, { 'address' : '9huDUZfxoJ7wGMTffUE7vh1xePqef7gyrLJu9NApncqA' , 'lamports' : 4999999036109120 }, { 'address' : 'C7C8odR8oashR5Feyrq2tJKaXL18id1dSj2zbkDGL2C2' , 'lamports' : 4999999036109120 }, { 'address' : 'AYgECURrvuX6GtFe4tX7aAj87Xc5r5Znx96ntNk1nCv' , 'lamports' : 2499999518054560 }, { 'address' : 'AogcwQ1ubM76EPMhSD5cw1ES4W5econvQCFmBL6nTW1' , 'lamports' : 2499999518054560 }, { 'address' : 'gWgqQ4udVxE3uNxRHEwvftTHwpEmPHAd8JR9UzaHbR2' , 'lamports' : 2499999518054560 }, { 'address' : '3D91zLQPRLamwJfGR5ZYMKQb4C18gsJNaSdmB6b2wLhw' , 'lamports' : 2499999518054560 }, { 'address' : '3bHbMa5VW3np5AJazuacidrN4xPZgwhcXigmjwHmBg5e' , 'lamports' : 2499999518054560 }, { 'address' : '4U3RFq7X5kLG6tZ9kcksFL8oXeGNjtuUN1YfkVKXbs5x' , 'lamports' : 2499999518054560 }, { 'address' : '5cBVGBKY6kBaiTVmsQpxThJ2oqitBYuCAX9Zm2zMuV4y' , 'lamports' : 2499999518054560 }, { 'address' : '8PjJTv657aeN9p5R2WoM6pPSz385chvTTytUWaEjSjkq' , 'lamports' : 2499999518054560 }, { 'address' : 'AHB94zKUASftTdqgdfiDSdnPJHkEFp7zX3yMrcSxABsv' , 'lamports' : 2499999518054560 }, { 'address' : 'Hc36Wh1ZqYGzGAnsJWNT9r2gY3h9n89uDpxZPsmEsiE3' , 'lamports' : 2499999518054560 }, { 'address' : 'GxyRKP2eVKACaSSnso4VLSAjZKmHsFXHWUfS3A5CtiMA' , 'lamports' : 1940147018054560 }]}, 'id' : 2 } Source code in solana/rpc/async_api.py async def get_largest_accounts ( self , filter_opt : Optional [ str ] = None , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the 20 largest accounts, by lamport balance. Args: filter_opt: Filter results by account type; currently supported: circulating|nonCirculating. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_largest_accounts()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 8890}, 'value': [{'address': '95L7AsBCLRsqghsi6ksZkzjNbs6rqDgHCzKaGZ7bJi75', 'lamports': 500000000000000000}, {'address': 'APnSR52EC1eH676m7qTBHUJ1nrGpHYpV7XKPxgRDD8gX', 'lamports': 164511033098290000}, {'address': '13LeFbG6m2EP1fqCj9k66fcXsoTHMMtgr7c78AivUrYD', 'lamports': 153333632446109120}, {'address': 'GK2zqSsXLA2rwVZk347RYhh6jJpRsCA69FjLW93ZGi3B', 'lamports': 57499999036109120}, {'address': '8HVqyX9jebh31Q9Hp8t5sMVJs665979ZeEr3eCfzitUe', 'lamports': 30301031036109120}, {'address': 'HbZ5FfmKWNHC7uwk6TF1hVi6TCs7dtYfdjEcuPGgzFAg', 'lamports': 14999999036109120}, {'address': '14FUT96s9swbmH7ZjpDvfEDywnAYy9zaNhv4xvezySGu', 'lamports': 4999999036109120}, {'address': '9huDUZfxoJ7wGMTffUE7vh1xePqef7gyrLJu9NApncqA', 'lamports': 4999999036109120}, {'address': 'C7C8odR8oashR5Feyrq2tJKaXL18id1dSj2zbkDGL2C2', 'lamports': 4999999036109120}, {'address': 'AYgECURrvuX6GtFe4tX7aAj87Xc5r5Znx96ntNk1nCv', 'lamports': 2499999518054560}, {'address': 'AogcwQ1ubM76EPMhSD5cw1ES4W5econvQCFmBL6nTW1', 'lamports': 2499999518054560}, {'address': 'gWgqQ4udVxE3uNxRHEwvftTHwpEmPHAd8JR9UzaHbR2', 'lamports': 2499999518054560}, {'address': '3D91zLQPRLamwJfGR5ZYMKQb4C18gsJNaSdmB6b2wLhw', 'lamports': 2499999518054560}, {'address': '3bHbMa5VW3np5AJazuacidrN4xPZgwhcXigmjwHmBg5e', 'lamports': 2499999518054560}, {'address': '4U3RFq7X5kLG6tZ9kcksFL8oXeGNjtuUN1YfkVKXbs5x', 'lamports': 2499999518054560}, {'address': '5cBVGBKY6kBaiTVmsQpxThJ2oqitBYuCAX9Zm2zMuV4y', 'lamports': 2499999518054560}, {'address': '8PjJTv657aeN9p5R2WoM6pPSz385chvTTytUWaEjSjkq', 'lamports': 2499999518054560}, {'address': 'AHB94zKUASftTdqgdfiDSdnPJHkEFp7zX3yMrcSxABsv', 'lamports': 2499999518054560}, {'address': 'Hc36Wh1ZqYGzGAnsJWNT9r2gY3h9n89uDpxZPsmEsiE3', 'lamports': 2499999518054560}, {'address': 'GxyRKP2eVKACaSSnso4VLSAjZKmHsFXHWUfS3A5CtiMA', 'lamports': 1940147018054560}]}, 'id': 2} \"\"\" args = self . _get_largest_accounts_args ( filter_opt , commitment ) return await self . _provider . make_request ( * args ) get_latest_blockhash ( self , commitment = None ) async Returns the latest block hash from the ledger. Response also includes the last valid block height. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_latest_blockhash ()) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 1637 }, 'value' : { 'blockhash' : 'EALChog1mXQ9nEgEUQpWAtmA5UueUZvZiL16ZivmR7eb' , 'lastValidBlockHeight' : 3090 }}, 'id' : 2 } Source code in solana/rpc/async_api.py async def get_latest_blockhash ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the latest block hash from the ledger. Response also includes the last valid block height. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_latest_blockhash()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 1637}, 'value': {'blockhash': 'EALChog1mXQ9nEgEUQpWAtmA5UueUZvZiL16ZivmR7eb', 'lastValidBlockHeight': 3090}}, 'id': 2} \"\"\" args = self . _get_latest_blockhash_args ( commitment ) return await self . _provider . make_request ( * args ) get_leader_schedule ( self , epoch = None , commitment = None ) async Returns the leader schedule for an epoch. Parameters: Name Type Description Default epoch Optional[int] Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_leader_schedule ()) { 'jsonrpc' : '2.0' , 'result' : { 'EWj2cuEuVhi7RX81cnAY3TzpyFwnHzzVwvuTyfmxmhs3' : [ 0 , 1 , 2 , 3 , 4 , 5 , ... ]}, 'id' : 6 } Source code in solana/rpc/async_api.py async def get_leader_schedule ( self , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the leader schedule for an epoch. Args: epoch: Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_leader_schedule()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'EWj2cuEuVhi7RX81cnAY3TzpyFwnHzzVwvuTyfmxmhs3': [0, 1, 2, 3, 4, 5, ...]}, 'id': 6} \"\"\" args = self . _get_leader_schedule_args ( epoch , commitment ) return await self . _provider . make_request ( * args ) get_minimum_balance_for_rent_exemption ( self , usize , commitment = None ) async Returns minimum balance required to make account rent exempt. Parameters: Name Type Description Default usize int Account data length. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_minimum_balance_for_rent_exemption ( 50 )) { 'jsonrpc' : '2.0' , 'result' : 1238880 , 'id' : 7 } Source code in solana/rpc/async_api.py async def get_minimum_balance_for_rent_exemption ( self , usize : int , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns minimum balance required to make account rent exempt. Args: usize: Account data length. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_minimum_balance_for_rent_exemption(50)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1238880, 'id': 7} \"\"\" args = self . _get_minimum_balance_for_rent_exemption_args ( usize , commitment ) return await self . _provider . make_request ( * args ) get_minimum_ledger_slot ( self ) async Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_minimum_ledger_slot ()) { 'jsonrpc' : '2.0' , 'result' : 1234 , 'id' : 1 } Source code in solana/rpc/async_api.py async def get_minimum_ledger_slot ( self ) -> types . RPCResponse : \"\"\"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_minimum_ledger_slot()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1234, 'id': 1} \"\"\" return await self . _provider . make_request ( self . _minimum_ledger_slot ) get_multiple_accounts ( self , pubkeys , commitment = None , encoding = 'base64' , data_slice = None ) async Returns all the account info for a list of public keys. Parameters: Name Type Description Default pubkeys List[Union[solana.publickey.PublicKey, str]] list of Pubkeys to query, as base-58 encoded string or PublicKey object. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding str (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". \"base58\" is limited to Account data of less than 128 bytes. \"base64\" will return base64 encoded data for Account data of any size. \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). 'base64' data_slice Optional[solana.rpc.types.DataSliceOpts] (optional) Option to limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None Examples: >>> from solana.publickey import PublicKey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> pubkeys = [ PublicKey ( \"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\" ), PublicKey ( \"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\" )] >>> asyncio . run ( solana_client . get_multiple_accounts ( pubkeys )) { \"jsonrpc\" : \"2.0\" , \"result\" : { \"context\" : { \"slot\" : 97531946 }, \"value\" : [ { \"data\" : [ \"\" , \"base64\" ], \"executable\" : False , \"lamports\" : 1 , \"owner\" : \"11111111111111111111111111111111\" , \"rentEpoch\" : 225 , }, { \"data\" : [ \"\" , \"base64\" ], \"executable\" : False , \"lamports\" : 809441127 , \"owner\" : \"11111111111111111111111111111111\" , \"rentEpoch\" : 225 , }, ], }, \"id\" : 1 , } Source code in solana/rpc/async_api.py async def get_multiple_accounts ( self , pubkeys : List [ Union [ PublicKey , str ]], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> types . RPCResponse : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. - \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solana.publickey import PublicKey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> pubkeys = [PublicKey(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), PublicKey(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> asyncio.run(solana_client.get_multiple_accounts(pubkeys)) # doctest: +SKIP { \"jsonrpc\": \"2.0\", \"result\": { \"context\": {\"slot\": 97531946}, \"value\": [ { \"data\": [\"\", \"base64\"], \"executable\": False, \"lamports\": 1, \"owner\": \"11111111111111111111111111111111\", \"rentEpoch\": 225, }, { \"data\": [\"\", \"base64\"], \"executable\": False, \"lamports\": 809441127, \"owner\": \"11111111111111111111111111111111\", \"rentEpoch\": 225, }, ], }, \"id\": 1, } \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_multiple_accounts_args ( pubkeys = pubkeys , commitment = commitment , encoding = encoding , data_slice = data_slice ) return await self . _provider . make_request ( * args ) get_program_accounts ( self , pubkey , commitment = 'finalized' , encoding = None , data_slice = None , data_size = None , memcmp_opts = None ) async Returns all accounts owned by the provided program Pubkey. Parameters: Name Type Description Default pubkey Union[str, solana.publickey.PublicKey] Pubkey of program, as base-58 encoded string or PublicKey object. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". 'finalized' encoding Optional[str] (optional) Encoding for the returned Transaction, either jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. None data_slice Optional[solana.rpc.types.DataSliceOpts] (optional) Limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None data_size Optional[int] (optional) Option to compare the program account data length with the provided data size. None memcmp_opts Optional[List[solana.rpc.types.MemcmpOpts]] (optional) Options to compare a provided series of bytes with program account data at a particular offset. None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> memcmp_opts = [ ... types . MemcmpOpts ( offset = 4 , bytes = \"3Mc6vR\" ), ... ] >>> asyncio . run ( solana_client . get_program_accounts ( \"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\" , data_size = 17 , memcmp_opts = memcmp_opts )) { 'jsonrpc' : \"2.0\" , 'result' :[{ 'account' :{ 'data' : '2R9jLfiAQ9bgdcw6h8s44439' , 'executable' : false , 'lamports' : 15298080 , 'owner' : '4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T' , 'rentEpoch' : 28 }, 'pubkey' : 'CxELquR1gPP8wHe33gZ4QxqGB3sZ9RSwsJ2KshVewkFY' }], 'id' : 1 } Source code in solana/rpc/async_api.py async def get_program_accounts ( # pylint: disable=too-many-arguments self , pubkey : Union [ str , PublicKey ], commitment : Optional [ Commitment ] = Finalized , encoding : Optional [ str ] = None , data_slice : Optional [ types . DataSliceOpts ] = None , data_size : Optional [ int ] = None , memcmp_opts : Optional [ List [ types . MemcmpOpts ]] = None , ) -> types . RPCResponse : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for the returned Transaction, either jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. data_size: (optional) Option to compare the program account data length with the provided data size. memcmp_opts: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> memcmp_opts = [ ... types.MemcmpOpts(offset=4, bytes=\"3Mc6vR\"), ... ] >>> asyncio.run(solana_client.get_program_accounts(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\", data_size=17, memcmp_opts=memcmp_opts)) # doctest: +SKIP {'jsonrpc': \"2.0\", 'result' :[{ 'account' :{ 'data' :'2R9jLfiAQ9bgdcw6h8s44439', 'executable' :false, 'lamports' :15298080, 'owner' :'4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T', 'rentEpoch' :28}, 'pubkey' :'CxELquR1gPP8wHe33gZ4QxqGB3sZ9RSwsJ2KshVewkFY'}], 'id' :1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_program_accounts_args ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , data_size = data_size , memcmp_opts = memcmp_opts , ) return await self . _provider . make_request ( * args ) get_recent_blockhash ( self , commitment = None ) async Returns a recent block hash from the ledger. Response also includes a fee schedule that can be used to compute the cost of submitting a transaction using it. Deprecated, please use get_latest_blockhash() instead. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_recent_blockhash ()) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 1637 }, 'value' : { 'blockhash' : 'EALChog1mXQ9nEgEUQpWAtmA5UueUZvZiL16ZivmR7eb' , 'feeCalculator' : { 'lamportsPerSignature' : 5000 }}}, 'id' : 2 } Source code in solana/rpc/async_api.py async def get_recent_blockhash ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns a recent block hash from the ledger. Response also includes a fee schedule that can be used to compute the cost of submitting a transaction using it. Deprecated, please use get_latest_blockhash() instead. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_recent_blockhash()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 1637}, 'value': {'blockhash': 'EALChog1mXQ9nEgEUQpWAtmA5UueUZvZiL16ZivmR7eb', 'feeCalculator': {'lamportsPerSignature': 5000}}}, 'id': 2} \"\"\" args = self . _get_recent_blockhash_args ( commitment ) return await self . _provider . make_request ( * args ) get_recent_performance_samples ( self , limit = None ) async Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Parameters: Name Type Description Default limit Optional[int] Limit (optional) number of samples to return (maximum 720) None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_recent_performance_samples ( 4 )) { 'jsonrpc' : '2.0' , 'result' : [ { 'numSlots' : 126 , 'numTransactions' : 126 , 'samplePeriodSecs' : 60 , 'slot' : 348125 }, { 'numSlots' : 126 , 'numTransactions' : 126 , 'samplePeriodSecs' : 60 , 'slot' : 347999 }, { 'numSlots' : 125 , 'numTransactions' : 125 , 'samplePeriodSecs' : 60 , 'slot' : 347873 }, { 'numSlots' : 125 , 'numTransactions' : 125 , 'samplePeriodSecs' : 60 , 'slot' : 347748 } ], 'id' : 1 } Source code in solana/rpc/async_api.py async def get_recent_performance_samples ( self , limit : Optional [ int ] = None ) -> types . RPCResponse : \"\"\"Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Args: limit: Limit (optional) number of samples to return (maximum 720) Examples: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_recent_performance_samples(4)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [ { 'numSlots': 126, 'numTransactions': 126, 'samplePeriodSecs': 60, 'slot': 348125 }, { 'numSlots': 126, 'numTransactions': 126, 'samplePeriodSecs': 60, 'slot': 347999 }, { 'numSlots': 125, 'numTransactions': 125, 'samplePeriodSecs': 60, 'slot': 347873 }, { 'numSlots': 125, 'numTransactions': 125, 'samplePeriodSecs': 60, 'slot': 347748 } ], 'id': 1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_recent_performance_samples_args ( limit ) return await self . _provider . make_request ( * args ) get_signature_statuses ( self , signatures , search_transaction_history = False ) async Returns the statuses of a list of signatures. Unless the search_transaction_history configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus MAX_RECENT_BLOCKHASHES rooted slots. Parameters: Name Type Description Default signatures List[Union[str, bytes]] An array of transaction signatures to confirm. required search_transaction_history bool If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. False Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> signatures = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\" , ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\" ] >>> asyncio . run ( solana_client . get_signature_statuses ( signatures )) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 82 }, 'value' : [{ 'slot' : 72 , 'confirmations' : 10 , 'err' : null , 'status' : { 'Ok' : null }}, null ]}, 'id' : 1 } Source code in solana/rpc/async_api.py async def get_signature_statuses ( self , signatures : List [ Union [ str , bytes ]], search_transaction_history : bool = False ) -> types . RPCResponse : \"\"\"Returns the statuses of a list of signatures. Unless the `search_transaction_history` configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus `MAX_RECENT_BLOCKHASHES` rooted slots. Args: signatures: An array of transaction signatures to confirm. search_transaction_history: If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> signatures = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\", ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\"] >>> asyncio.run(solana_client.get_signature_statuses(signatures)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': { 'context': {'slot':82}, 'value': [{ 'slot': 72, 'confirmations': 10, 'err': null, 'status': {'Ok': null}}, null]}, 'id': 1} \"\"\" args = self . _get_signature_statuses_args ( signatures , search_transaction_history ) return await self . _provider . make_request ( * args ) get_signatures_for_address ( self , account , before = None , until = None , limit = None , commitment = None ) async Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Parameters: Name Type Description Default account Union[str, solana.keypair.Keypair, solana.publickey.PublicKey] Account to be queried. required before Optional[str] (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. None until Optional[str] (optional) Search until this transaction signature, if found before limit reached. None limit Optional[int] (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). None commitment Optional[Commitment] (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_signatures_for_address ( \"Vote111111111111111111111111111111111111111\" , limit = 1 )) { 'jsonrpc' : '2.0' , 'result' : [{ 'err' : None , 'memo' : None , 'signature' : 'v1BK8XcaPBzAGd7TB1K53pMdi6TBGe5CLCgx8cmZ4Bj63ZNvA6ca2QaxFpBFdvmpoFQ51VorBjifkBGLTDhwpqN' , 'slot' : 4290 }], 'id' : 2 } Source code in solana/rpc/async_api.py async def get_signatures_for_address ( self , account : Union [ str , Keypair , PublicKey ], before : Optional [ str ] = None , until : Optional [ str ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_signatures_for_address(\"Vote111111111111111111111111111111111111111\", limit=1)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [{'err': None, 'memo': None, 'signature': 'v1BK8XcaPBzAGd7TB1K53pMdi6TBGe5CLCgx8cmZ4Bj63ZNvA6ca2QaxFpBFdvmpoFQ51VorBjifkBGLTDhwpqN', 'slot': 4290}], 'id': 2} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_signatures_for_address_args ( account , before , until , limit , commitment ) return await self . _provider . make_request ( * args ) get_slot ( self , commitment = None ) async Returns the current slot the node is processing. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_slot ()) { 'jsonrpc' : '2.0' , 'result' : 7515 , 'id' : 1 } Source code in solana/rpc/async_api.py async def get_slot ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the current slot the node is processing. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_slot()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 7515, 'id': 1} \"\"\" args = self . _get_slot_args ( commitment ) return await self . _provider . make_request ( * args ) get_slot_leader ( self , commitment = None ) async Returns the current slot leader. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_slot_leader ()) { 'jsonrpc' : '2.0' , 'result' : 'EWj2cuEuVhi7RX81cnAY3TzpyFwnHzzVwvuTyfmxmhs3' , 'id' : 1 } Source code in solana/rpc/async_api.py async def get_slot_leader ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the current slot leader. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_slot_leader()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'EWj2cuEuVhi7RX81cnAY3TzpyFwnHzzVwvuTyfmxmhs3', 'id': 1} \"\"\" args = self . _get_slot_leader_args ( commitment ) return await self . _provider . make_request ( * args ) get_stake_activation ( self , pubkey , epoch = None , commitment = None ) async Returns epoch activation information for a stake account. Parameters: Name Type Description Default pubkey Union[solana.publickey.PublicKey, str] Pubkey of stake account to query, as base-58 encoded string or PublicKey object. required epoch Optional[int] (optional) Epoch for which to calculate activation details. If parameter not provided, defaults to current epoch. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_stake_activation ()) { 'jsonrpc' : '2.0' , 'result' : { 'active' : 124429280 , 'inactive' : 73287840 , 'state' : 'activating' }, 'id' : 1 }} Source code in solana/rpc/async_api.py async def get_stake_activation ( self , pubkey : Union [ PublicKey , str ], epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns epoch activation information for a stake account. Args: pubkey: Pubkey of stake account to query, as base-58 encoded string or PublicKey object. epoch: (optional) Epoch for which to calculate activation details. If parameter not provided, defaults to current epoch. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_stake_activation()) # doctest: +SKIP {'jsonrpc': '2.0','result': {'active': 124429280, 'inactive': 73287840, 'state': 'activating'}, 'id': 1}} \"\"\" args = self . _get_stake_activation_args ( pubkey , epoch , commitment ) return await self . _provider . make_request ( * args ) get_supply ( self , commitment = None ) async Returns information about the current supply. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_supply ()) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 3846 }, 'value' : { 'circulating' : 683635192454157660 , 'nonCirculating' : 316364808037127120 , 'nonCirculatingAccounts' : [ 'ETfDYz7Cg5p9SDFmdpRerjBN5puKK7xydEBZZGM2V4Ay' , '7cKxv6UznFoWRuJkgw5bWj5rp5PiKTcXZeEaLqyd3Bbm' , 'CV7qh8ZoqeUSTQagosGpkLptXoojf9yCszxkRx1jTD12' , 'FZ9S7X9jMbCaMyJjRfSoBhFyarUMVwvx7HWRe4LnZHsg' , ... ] 'total' : 1000000000491284780 }}, 'id' : 1 } Source code in solana/rpc/async_api.py async def get_supply ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns information about the current supply. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_supply()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 3846}, 'value': {'circulating': 683635192454157660, 'nonCirculating': 316364808037127120, 'nonCirculatingAccounts': ['ETfDYz7Cg5p9SDFmdpRerjBN5puKK7xydEBZZGM2V4Ay', '7cKxv6UznFoWRuJkgw5bWj5rp5PiKTcXZeEaLqyd3Bbm', 'CV7qh8ZoqeUSTQagosGpkLptXoojf9yCszxkRx1jTD12', 'FZ9S7X9jMbCaMyJjRfSoBhFyarUMVwvx7HWRe4LnZHsg', ...] 'total': 1000000000491284780}}, 'id': 1} \"\"\" args = self . _get_supply_args ( commitment ) return await self . _provider . make_request ( * args ) get_token_account_balance ( self , pubkey , commitment = None ) async Returns the token balance of an SPL Token account (UNSTABLE). Parameters: Name Type Description Default pubkey Union[str, solana.publickey.PublicKey] Pubkey of Token account to query, as base-58 encoded string or PublicKey object. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_token_account_balance ( \"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\" )) # noqa: E501 # pylint: disable=line-too-long { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 1114 }, 'value' : { 'uiAmount' : 98.64 , 'amount' : '9864' , 'decimals' : 2 }, 'id' : 1 } Source code in solana/rpc/async_api.py async def get_token_account_balance ( self , pubkey : Union [ str , PublicKey ], commitment : Optional [ Commitment ] = None ): \"\"\"Returns the token balance of an SPL Token account (UNSTABLE). Args: pubkey: Pubkey of Token account to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_token_account_balance(\"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\")) # noqa: E501 # pylint: disable=line-too-long # doctest: +SKIP {'jsonrpc': '2.0','result': { 'context': {'slot':1114}, 'value': { 'uiAmount': 98.64, 'amount': '9864', 'decimals': 2}, 'id' :1} \"\"\" args = self . _get_token_account_balance_args ( pubkey , commitment ) return await self . _provider . make_request ( * args ) get_token_accounts_by_delegate ( self , delegate , opts , commitment = None ) async Returns all SPL Token accounts by approved Delegate (UNSTABLE). Parameters: Name Type Description Default delegate PublicKey Public key of the delegate owner to query. required opts TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/async_api.py async def get_token_accounts_by_delegate ( self , delegate : PublicKey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" args = self . _get_token_accounts_by_delegate_args ( delegate , opts , commitment ) return await self . __get_token_accounts ( * args ) get_token_accounts_by_owner ( self , owner , opts , commitment = None ) async Returns all SPL Token accounts by token owner (UNSTABLE). Parameters: Name Type Description Default owner PublicKey Public key of the account owner to query. required opts TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/async_api.py async def get_token_accounts_by_owner ( self , owner : PublicKey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Returns all SPL Token accounts by token owner (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" args = self . _get_token_accounts_by_owner_args ( owner , opts , commitment ) return await self . __get_token_accounts ( * args ) get_token_largest_accounts ( self , pubkey , commitment = None ) async Returns the 20 largest accounts of a particular SPL Token type. Source code in solana/rpc/async_api.py async def get_token_largest_accounts ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the 20 largest accounts of a particular SPL Token type.\"\"\" args = self . _get_token_largest_account_args ( pubkey , commitment ) return await self . _provider . make_request ( * args ) get_token_supply ( self , pubkey , commitment = None ) async Returns the total supply of an SPL Token type. Source code in solana/rpc/async_api.py async def get_token_supply ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the total supply of an SPL Token type.\"\"\" args = self . _get_token_supply_args ( pubkey , commitment ) return await self . _provider . make_request ( * args ) get_transaction ( self , tx_sig , encoding = 'json' , commitment = None ) async Returns transaction details for a confirmed transaction. Parameters: Name Type Description Default tx_sig str Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the transaction.message.instructions list. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_transaction ( \"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\" )) { 'jsonrpc' : '2.0' , 'result' : { 'meta' : { 'err' : None , 'fee' : 5000 , 'rewards' : [], 'postBalances' : [ 498449233720610510 , 1000001001987940 , 1 ], 'preBalances' : [ 498449233721615510 , 1000001000987940 , 1 ], 'status' : { 'Ok' : None }}, 'slot' : 1659335 , 'transaction' : { 'message' : { 'accountKeys' : [ '9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g' , '2KW2XRd9kwqet15Aha2oK3tYvd3nWbTFH1MBiRAv1BE1' , '11111111111111111111111111111111' ], 'header' : { 'numReadonlySignedAccounts' : 0 , 'numReadonlyUnsignedAccounts' : 1 , 'numRequiredSignatures' : 1 }, 'instructions' : [{ 'accounts' : [ 0 , 1 ], 'data' : '3Bxs4Bc3VYuGVB19' , 'programIdIndex' : 2 }], 'recentBlockhash' : 'FwcsKNptGtMLccXAA9YgnivVFK95mKzECLT1DNPi3SDr' }, 'signatures' : [ '3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy' ]}}, 'id' : 4 } Source code in solana/rpc/async_api.py async def get_transaction ( self , tx_sig : str , encoding : str = \"json\" , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_transaction(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\")) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'meta': {'err': None, 'fee': 5000, 'rewards': [], 'postBalances': [498449233720610510, 1000001001987940, 1], 'preBalances': [498449233721615510, 1000001000987940, 1], 'status': {'Ok': None}}, 'slot': 1659335, 'transaction': {'message': {'accountKeys': ['9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g', '2KW2XRd9kwqet15Aha2oK3tYvd3nWbTFH1MBiRAv1BE1', '11111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 1, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [0, 1], 'data': '3Bxs4Bc3VYuGVB19', 'programIdIndex': 2}], 'recentBlockhash': 'FwcsKNptGtMLccXAA9YgnivVFK95mKzECLT1DNPi3SDr'}, 'signatures': ['3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy']}}, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_transaction_args ( tx_sig , encoding , commitment ) return await self . _provider . make_request ( * args ) get_transaction_count ( self , commitment = None ) async Returns the current Transaction count from the ledger. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_transaction_count ()) { 'jsonrpc' : '2.0' , 'result' : 4554 , 'id' : 1 } Source code in solana/rpc/async_api.py async def get_transaction_count ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the current Transaction count from the ledger. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_transaction_count()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 4554, 'id': 1} \"\"\" args = self . _get_transaction_count_args ( commitment ) return await self . _provider . make_request ( * args ) get_version ( self ) async Returns the current solana versions running on the node. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_version ()) { 'jsonrpc' : '2.0' , 'result' : { 'solana-core' : '1.4.0 5332fcad' }, 'id' : 1 } Source code in solana/rpc/async_api.py async def get_version ( self ) -> types . RPCResponse : \"\"\"Returns the current solana versions running on the node. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_version()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'solana-core': '1.4.0 5332fcad'}, 'id': 1} \"\"\" return await self . _provider . make_request ( self . _get_version ) get_vote_accounts ( self , commitment = None ) async Returns the account info and associated stake for all the voting accounts in the current bank. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_vote_accounts ()) { 'jsonrpc' : '2.0' , 'result' : { 'current' : [{ 'activatedStake' : 0 , 'commission' : 100 , 'epochCredits' : [[ 165 , 714644 , 707372 ], [ 166 , 722092 , 714644 ], [ 167 , 730285 , 722092 ], [ 168 , 738476 , 730285 ], ... ] 'epochVoteAccount' : True , 'lastVote' : 1872294 , 'nodePubkey' : 'J7v9ndmcoBuo9to2MnHegLnBkC9x3SAVbQBJo5MMJrN1' , 'rootSlot' : 1872263 , 'votePubkey' : 'HiFjzpR7e5Kv2tdU9jtE4FbH1X8Z9Syia3Uadadx18b5' }, { 'activatedStake' : 500029968930560 , 'commission' : 100 , 'epochCredits' : [[ 165 , 1359689 , 1351498 ], [ 166 , 1367881 , 1359689 ], [ 167 , 1376073 , 1367881 ], [ 168 , 1384265 , 1376073 ], ... ], 'epochVoteAccount' : True , 'lastVote' : 1872295 , 'nodePubkey' : 'dv1LfzJvDF7S1fBKpFgKoKXK5yoSosmkAdfbxBo1GqJ' , 'rootSlot' : 1872264 , 'votePubkey' : '5MMCR4NbTZqjthjLGywmeT66iwE9J9f7kjtxzJjwfUx2' }, { 'activatedStake' : 0 , 'commission' : 100 , 'epochCredits' : [[ 227 , 2751 , 0 ], [ 228 , 7188 , 2751 ]], 'epochVoteAccount' : True , 'lastVote' : 1872295 , 'nodePubkey' : 'H1wDvJ5HJc1SzhHoWtaycpzQpFbsL7g8peaRV3obKShs' , 'rootSlot' : 1872264 , 'votePubkey' : 'DPqpgoLQVU3aq72HEqSMsB9qh4KoXc9fGEpvgEuiwnp6' }], 'delinquent' : []}, 'id' : 1 } Source code in solana/rpc/async_api.py async def get_vote_accounts ( self , commitment : Optional [ Commitment ] = None ): \"\"\"Returns the account info and associated stake for all the voting accounts in the current bank. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_vote_accounts()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'current': [{'activatedStake': 0, 'commission': 100, 'epochCredits': [[165, 714644, 707372], [166, 722092, 714644], [167, 730285, 722092], [168, 738476, 730285], ...] 'epochVoteAccount': True, 'lastVote': 1872294, 'nodePubkey': 'J7v9ndmcoBuo9to2MnHegLnBkC9x3SAVbQBJo5MMJrN1', 'rootSlot': 1872263, 'votePubkey': 'HiFjzpR7e5Kv2tdU9jtE4FbH1X8Z9Syia3Uadadx18b5'}, {'activatedStake': 500029968930560, 'commission': 100, 'epochCredits': [[165, 1359689, 1351498], [166, 1367881, 1359689], [167, 1376073, 1367881], [168, 1384265, 1376073], ...], 'epochVoteAccount': True, 'lastVote': 1872295, 'nodePubkey': 'dv1LfzJvDF7S1fBKpFgKoKXK5yoSosmkAdfbxBo1GqJ', 'rootSlot': 1872264, 'votePubkey': '5MMCR4NbTZqjthjLGywmeT66iwE9J9f7kjtxzJjwfUx2'}, {'activatedStake': 0, 'commission': 100, 'epochCredits': [[227, 2751, 0], [228, 7188, 2751]], 'epochVoteAccount': True, 'lastVote': 1872295, 'nodePubkey': 'H1wDvJ5HJc1SzhHoWtaycpzQpFbsL7g8peaRV3obKShs', 'rootSlot': 1872264, 'votePubkey': 'DPqpgoLQVU3aq72HEqSMsB9qh4KoXc9fGEpvgEuiwnp6'}], 'delinquent': []}, 'id': 1} \"\"\" args = self . _get_vote_accounts_args ( commitment ) return await self . _provider . make_request ( * args ) is_connected ( self ) async Health check. solana_client = AsyncClient(\"http://localhost:8899\") asyncio.run(solana_client.is_connected()) # doctest: +SKIP True Returns: Type Description bool True if the client is connected. Source code in solana/rpc/async_api.py async def is_connected ( self ) -> bool : \"\"\"Health check. >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.is_connected()) # doctest: +SKIP True Returns: True if the client is connected. \"\"\" return await self . _provider . is_connected () request_airdrop ( self , pubkey , lamports , commitment = None ) async Requests an airdrop of lamports to a Pubkey. Parameters: Name Type Description Default pubkey Union[solana.publickey.PublicKey, str] Pubkey of account to receive lamports, as base-58 encoded string or public key object. required lamports int Amount of lamports. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solana.publickey import PublicKey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . request_airdrop ( PublicKey ( 1 ), 10000 )) { 'jsonrpc' : '2.0' , 'result' : 'uK6gbLbhnTEgjgmwn36D5BRTRkG4AT8r7Q162TLnJzQnHUZVL9r6BYZVfRttrhmkmno6Fp4VQELzL4AiriCo61U' , 'id' : 1 } Source code in solana/rpc/async_api.py async def request_airdrop ( self , pubkey : Union [ PublicKey , str ], lamports : int , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Requests an airdrop of lamports to a Pubkey. Args: pubkey: Pubkey of account to receive lamports, as base-58 encoded string or public key object. lamports: Amount of lamports. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solana.publickey import PublicKey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.request_airdrop(PublicKey(1), 10000)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'uK6gbLbhnTEgjgmwn36D5BRTRkG4AT8r7Q162TLnJzQnHUZVL9r6BYZVfRttrhmkmno6Fp4VQELzL4AiriCo61U', 'id': 1} \"\"\" args = self . _request_airdrop_args ( pubkey , lamports , commitment ) return await self . _provider . make_request ( * args ) send_raw_transaction ( self , txn , opts = None ) async Send a transaction that has already been signed and serialized into the wire format. Parameters: Name Type Description Default txn Union[bytes, str] Fully-signed Transaction object, a fully sign transaction in wire format, or a fully transaction as base-64 encoded string. required opts Optional[solana.rpc.types.TxOpts] (optional) Transaction options. None Before submitting, the following preflight checks are performed (unless disabled with the skip_preflight option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> full_signed_tx_str = ( ... \"AbN5XM+qw+7oOLsFw7goQSLBis7c1kXJFP6OF4w7YmQNhhbQYcyBiybKuOzzhV7McvoRP3Mey9AhXojtwDCdbwoBAAEDE5j2\" ... \"LG0aRXxRumpLXz29L2n8qTIWIY3ImX5Ba9F9k8poq0Z3/7HyiU3QphU8Ix1F7ENq5TrmAUnb4V8y5LhwPwAAAAAAAAAAAAAA\" ... \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAg5YY9wG6fpuieuWYJd1ta7ZtFPbV0OriFRYdcYUaEGkBAgIAAQwCAAAAQEIPAAAAAAA=\" ) >>> asyncio . run ( solana_client . send_raw_transaction ( full_signed_tx_str )) { 'jsonrpc' : '2.0' , 'result' : 'CMwyESM2NE74mghfbvsHJDERF7xMYKshwwm6VgH6GFqXzx8LfBFuP5ruccumfhTguha6seUHPpiHzzHUQXzq2kN' , 'id' : 1 } Source code in solana/rpc/async_api.py async def send_raw_transaction ( self , txn : Union [ bytes , str ], opts : Optional [ types . TxOpts ] = None ) -> types . RPCResponse : \"\"\"Send a transaction that has already been signed and serialized into the wire format. Args: txn: Fully-signed Transaction object, a fully sign transaction in wire format, or a fully transaction as base-64 encoded string. opts: (optional) Transaction options. Before submitting, the following preflight checks are performed (unless disabled with the `skip_preflight` option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> full_signed_tx_str = ( ... \"AbN5XM+qw+7oOLsFw7goQSLBis7c1kXJFP6OF4w7YmQNhhbQYcyBiybKuOzzhV7McvoRP3Mey9AhXojtwDCdbwoBAAEDE5j2\" ... \"LG0aRXxRumpLXz29L2n8qTIWIY3ImX5Ba9F9k8poq0Z3/7HyiU3QphU8Ix1F7ENq5TrmAUnb4V8y5LhwPwAAAAAAAAAAAAAA\" ... \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAg5YY9wG6fpuieuWYJd1ta7ZtFPbV0OriFRYdcYUaEGkBAgIAAQwCAAAAQEIPAAAAAAA=\") >>> asyncio.run(solana_client.send_raw_transaction(full_signed_tx_str)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'CMwyESM2NE74mghfbvsHJDERF7xMYKshwwm6VgH6GFqXzx8LfBFuP5ruccumfhTguha6seUHPpiHzzHUQXzq2kN', 'id': 1} \"\"\" # noqa: E501 # pylint: disable=line-too-long opts_to_use = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts args = self . _send_raw_transaction_args ( txn , opts_to_use ) resp = await self . _provider . make_request ( * args ) if opts_to_use . skip_confirmation : return self . _post_send ( resp ) post_send_args = self . _send_raw_transaction_post_send_args ( resp , opts_to_use ) return await self . __post_send_with_confirm ( * post_send_args ) send_transaction ( self , txn , * signers , * , opts = None , recent_blockhash = None ) async Send a transaction. Parameters: Name Type Description Default txn Transaction Transaction object. required signers Keypair Signers to sign the transaction. () opts Optional[solana.rpc.types.TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) Pass a valid recent blockhash here if you want to skip fetching the recent blockhash or relying on the cache. None Examples: >>> from solana.keypair import Keypair >>> from solana.system_program import TransferParams , transfer >>> from solana.transaction import Transaction >>> sender , receiver = Keypair . from_seed ( bytes ( PublicKey ( 1 ))), Keypair . from_seed ( bytes ( PublicKey ( 2 ))) >>> txn = Transaction () . add ( transfer ( TransferParams ( ... from_pubkey = sender . public_key , to_pubkey = receiver . public_key , lamports = 1000 ))) >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . send_transaction ( txn , sender )) { 'jsonrpc' : '2.0' , 'result' : '236zSA5w4NaVuLXXHK1mqiBuBxkNBu84X6cfLBh1v6zjPrLfyECz4zdedofBaZFhs4gdwzSmij9VkaSo2tR5LTgG' , 'id' : 12 } Source code in solana/rpc/async_api.py async def send_transaction ( self , txn : Transaction , * signers : Keypair , opts : Optional [ types . TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> types . RPCResponse : \"\"\"Send a transaction. Args: txn: Transaction object. signers: Signers to sign the transaction. opts: (optional) Transaction options. recent_blockhash: (optional) Pass a valid recent blockhash here if you want to skip fetching the recent blockhash or relying on the cache. Example: >>> from solana.keypair import Keypair >>> from solana.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> sender, receiver = Keypair.from_seed(bytes(PublicKey(1))), Keypair.from_seed(bytes(PublicKey(2))) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.public_key, to_pubkey=receiver.public_key, lamports=1000))) >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.send_transaction(txn, sender)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': '236zSA5w4NaVuLXXHK1mqiBuBxkNBu84X6cfLBh1v6zjPrLfyECz4zdedofBaZFhs4gdwzSmij9VkaSo2tR5LTgG', 'id': 12} \"\"\" last_valid_block_height = None if recent_blockhash is None : if self . blockhash_cache : try : recent_blockhash = self . blockhash_cache . get () except ValueError : blockhash_resp = await self . get_latest_blockhash ( Finalized ) recent_blockhash = self . _process_blockhash_resp ( blockhash_resp , used_immediately = True ) last_valid_block_height = blockhash_resp [ \"result\" ][ \"value\" ][ \"lastValidBlockHeight\" ] else : blockhash_resp = await self . get_latest_blockhash ( Finalized ) recent_blockhash = self . parse_recent_blockhash ( blockhash_resp ) last_valid_block_height = blockhash_resp [ \"result\" ][ \"value\" ][ \"lastValidBlockHeight\" ] txn . recent_blockhash = recent_blockhash txn . sign ( * signers ) opts_to_use = ( types . TxOpts ( preflight_commitment = self . _commitment , last_valid_block_height = last_valid_block_height ) if opts is None else opts ) txn_resp = await self . send_raw_transaction ( txn . serialize (), opts = opts_to_use ) if self . blockhash_cache : blockhash_resp = await self . get_latest_blockhash ( Finalized ) self . _process_blockhash_resp ( blockhash_resp , used_immediately = False ) return txn_resp set_log_filter ( self , log_filter ) async Sets the log filter on the validator. Parameters: Name Type Description Default log_filter str The new log filter to use. required Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . set_log_filter ( \"solana_core=debug\" )) { 'jsonrpc' : '2.0' , 'result' : None , 'id' : 1 } Source code in solana/rpc/async_api.py async def set_log_filter ( self , log_filter : str ) -> types . RPCResponse : \"\"\"Sets the log filter on the validator. Args: log_filter: The new log filter to use. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.set_log_filter(\"solana_core=debug\")) # doctest: +SKIP {'jsonrpc': '2.0', 'result': None, 'id': 1} \"\"\" args = self . _set_log_filter_args ( log_filter ) return await self . _provider . make_request ( * args ) simulate_transaction ( self , txn , sig_verify = False , commitment = None ) async Simulate sending a transaction. Parameters: Name Type Description Default txn Union[bytes, str, solana.transaction.Transaction] A Transaction object, a transaction in wire format, or a transaction as base-64 encoded string The transaction must have a valid blockhash, but is not required to be signed. required sig_verify bool If true the transaction signatures will be verified (default: false). False commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> tx_str = ( ... \"4hXTCkRzt9WyecNzV1XPgCDfGAZzQKNxLXgynz5QDuWWPSAZBZSHptvWRL3BjCvzUXRdKvHL2b7yGrRQcWyaqsaBCncVG7BF\" ... \"ggS8w9snUts67BSh3EqKpXLUm5UMHfD7ZBe9GhARjbNQMLJ1QD3Spr6oMTBU6EhdB4RD8CP2xUxr2u3d6fos36PD98XS6oX8\" ... \"TQjLpsMwncs5DAMiD4nNnR8NBfyghGCWvCVifVwvA8B8TJxE1aiyiv2L429BCWfyzAme5sZW8rDb14NeCQHhZbtNqfXhcp2t\" ... ) >>> asyncio . run ( solana_client . simulate_transaction ( tx_str )) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 218 }, 'value' : { 'err' : null , 'logs' : [ 'BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success' ]}, 'id' : 1 } Source code in solana/rpc/async_api.py async def simulate_transaction ( self , txn : Union [ bytes , str , Transaction ], sig_verify : bool = False , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Simulate sending a transaction. Args: txn: A Transaction object, a transaction in wire format, or a transaction as base-64 encoded string The transaction must have a valid blockhash, but is not required to be signed. sig_verify: If true the transaction signatures will be verified (default: false). commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> tx_str = ( ... \"4hXTCkRzt9WyecNzV1XPgCDfGAZzQKNxLXgynz5QDuWWPSAZBZSHptvWRL3BjCvzUXRdKvHL2b7yGrRQcWyaqsaBCncVG7BF\" ... \"ggS8w9snUts67BSh3EqKpXLUm5UMHfD7ZBe9GhARjbNQMLJ1QD3Spr6oMTBU6EhdB4RD8CP2xUxr2u3d6fos36PD98XS6oX8\" ... \"TQjLpsMwncs5DAMiD4nNnR8NBfyghGCWvCVifVwvA8B8TJxE1aiyiv2L429BCWfyzAme5sZW8rDb14NeCQHhZbtNqfXhcp2t\" ... ) >>> asyncio.run(solana_client.simulate_transaction(tx_str)) # doctest: +SKIP {'jsonrpc' :'2.0', 'result': {'context': {'slot': 218}, 'value': { 'err': null, 'logs': ['BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success']}, 'id':1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _simulate_transaction_args ( txn , sig_verify , commitment ) return await self . _provider . make_request ( * args ) validator_exit ( self ) async Request to have the validator exit. Validator must have booted with RPC exit enabled ( --enable-rpc-exit parameter). Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> solana_client . validator_exit () { 'jsonrpc' : '2.0' , 'result' : true , 'id' : 1 } Source code in solana/rpc/async_api.py async def validator_exit ( self ) -> types . RPCResponse : \"\"\"Request to have the validator exit. Validator must have booted with RPC exit enabled (`--enable-rpc-exit` parameter). Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> solana_client.validator_exit() # doctest: +SKIP {'jsonrpc': '2.0', 'result': true, 'id': 1} \"\"\" return await self . _provider . make_request ( self . _validator_exit )","title":"Async API Client"},{"location":"rpc/async_api/#async-api-client","text":"","title":"Async API Client"},{"location":"rpc/async_api/#solana.rpc.async_api","text":"Async API client to interact with the Solana JSON RPC Endpoint.","title":"async_api"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient","text":"Async client class. Parameters: Name Type Description Default endpoint Optional[str] URL of the RPC endpoint. None commitment Optional[Commitment] Default bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None blockhash_cache Union[solana.blockhash.BlockhashCache, bool] (Experimental) If True, keep a cache of recent blockhashes to make send_transaction calls faster. You can also pass your own BlockhashCache object to customize its parameters. The cache works as follows: Retrieve the oldest unused cached blockhash that is younger than ttl seconds, where ttl is defined in the BlockhashCache (we prefer unused blockhashes because reusing blockhashes can cause errors in some edge cases, and we prefer slightly older blockhashes because they're more likely to be accepted by every validator). If there are no unused blockhashes in the cache, take the oldest used blockhash that is younger than ttl seconds. Fetch a new recent blockhash after sending the transaction. This is to keep the cache up-to-date. If you want something tailored to your use case, run your own loop that fetches the recent blockhash, and pass that value in your .send_transaction calls. False timeout float HTTP request timeout in seconds. 10 Source code in solana/rpc/async_api.py class AsyncClient ( _ClientCore ): # pylint: disable=too-many-public-methods \"\"\"Async client class. Args: endpoint: URL of the RPC endpoint. commitment: Default bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". blockhash_cache: (Experimental) If True, keep a cache of recent blockhashes to make `send_transaction` calls faster. You can also pass your own BlockhashCache object to customize its parameters. The cache works as follows: 1. Retrieve the oldest unused cached blockhash that is younger than `ttl` seconds, where `ttl` is defined in the BlockhashCache (we prefer unused blockhashes because reusing blockhashes can cause errors in some edge cases, and we prefer slightly older blockhashes because they're more likely to be accepted by every validator). 2. If there are no unused blockhashes in the cache, take the oldest used blockhash that is younger than `ttl` seconds. 3. Fetch a new recent blockhash *after* sending the transaction. This is to keep the cache up-to-date. If you want something tailored to your use case, run your own loop that fetches the recent blockhash, and pass that value in your `.send_transaction` calls. timeout: HTTP request timeout in seconds. \"\"\" def __init__ ( self , endpoint : Optional [ str ] = None , commitment : Optional [ Commitment ] = None , blockhash_cache : Union [ BlockhashCache , bool ] = False , timeout : float = 10 , ) -> None : \"\"\"Init API client.\"\"\" super () . __init__ ( commitment , blockhash_cache ) self . _provider = async_http . AsyncHTTPProvider ( endpoint , timeout = timeout ) async def __aenter__ ( self ) -> \"AsyncClient\" : \"\"\"Use as a context manager.\"\"\" await self . _provider . __aenter__ () return self async def __aexit__ ( self , _exc_type , _exc , _tb ): \"\"\"Exits the context manager.\"\"\" await self . close () @property def request ( self ): if getattr ( self , '_provider' ): request_raw = self . _provider . content return self . _provider . json_decode ( request_raw ) return None @property def response_headers ( self ): return self . _provider . response_headers if getattr ( self , '_provider' ) else None async def close ( self ) -> None : \"\"\"Use this when you are done with the client.\"\"\" await self . _provider . close () async def is_connected ( self ) -> bool : \"\"\"Health check. >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.is_connected()) # doctest: +SKIP True Returns: True if the client is connected. \"\"\" return await self . _provider . is_connected () async def get_balance ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the balance of the account of provided Pubkey. Args: pubkey: Pubkey of account to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solana.publickey import PublicKey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_balance(PublicKey(1))) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 228}, 'value': 0}, 'id': 1} \"\"\" args = self . _get_balance_args ( pubkey , commitment ) return await self . _provider . make_request ( * args ) async def get_account_info ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> types . RPCResponse : \"\"\"Returns all the account info for the specified public key. Args: pubkey: Pubkey of account to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. - \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solana.publickey import PublicKey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_account_info(PublicKey(1))) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 33265073}, 'value': {'data': '', 'executable': False, 'lamports': 4459816188034584, 'owner': '11111111111111111111111111111111', 'rentEpoch': 90}}, 'id': 1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_account_info_args ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , min_context_slot = None ) return await self . _provider . make_request ( * args ) async def get_block_commitment ( self , slot : int ) -> types . RPCResponse : \"\"\"Fetch the commitment for particular block. Args: slot: Block, identified by Slot. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_block_commitment(0)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'commitment': [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 497717120], 'totalStake': 497717120}, 'id': 1}} \"\"\" args = self . _get_block_commitment_args ( slot ) return await self . _provider . make_request ( * args ) async def get_block_time ( self , slot : int ) -> types . RPCResponse : \"\"\"Fetch the estimated production time of a block. Args: slot: Block, identified by Slot. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_block_time(5)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1598400007, 'id': 1} \"\"\" args = self . _get_block_time_args ( slot ) return await self . _provider . make_request ( * args ) async def get_cluster_nodes ( self ) -> types . RPCResponse : \"\"\"Returns information about all the nodes participating in the cluster. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_cluster_nodes()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [{'gossip': '127.0.0.1:8001', 'pubkey': 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk', 'rpc': '127.0.0.1:8899', 'tpu': '127.0.0.1:8003', 'version': '1.4.0 5332fcad'}], 'id': 1} \"\"\" return await self . _provider . make_request ( self . _get_cluster_nodes ) async def get_confirmed_block ( self , slot : int , encoding : str = \"json\" , ) -> types . RPCResponse : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_confirmed_block(1)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': {'message': {'accountKeys': ['LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk', 'EKAar3bMQUZvGSonq7vcPF2nPaCYowbnat44FPafW8Po', 'SysvarS1otHashes111111111111111111111111111', 'SysvarC1ock11111111111111111111111111111111', 'Vote111111111111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 3, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [1, 2, 3, 0], 'data': '37u9WtQpcm6ULa3VmTgTKEBCtYMxq84mk82tRvKdFEwj3rALiptAzuMJ1yoVSFAMARMZYp7q', 'programIdIndex': 4}], 'recentBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2'}, 'signatures': ['63jnpMCs7TNnCjnTqUrX7Mvqc5CbJMtVkLxBjPHUQkjXyZrQuZpfhjvzA7A29D9tMqVaiQC3UNP1NeaZKFFHJyQE']}}]}, 'id': 9} >>> asyncio.run(solana_client.get_confirmed_block(1, encoding=\"base64\")) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': ['AfxyKHmHIjXWjkyHODGeAbVxmfQWPj1ydS9nF+ynJHo8I1vCPDp2P9Cj5aA6W1CAHEHCqY0B1FDKomCzRo3qrAsBAAMFBQ6QBWfhQF7rG02xhuEsmmrUtz3AUjBtJKkqaHPJEmvFzziDX0C0robPrl9RbOyXHoc9/Dxa0zoGL6cEjvCjLgan1RcZLwqvxvJl4/t3zHragsUp0L47E24tAFUgAAAABqfVFxjHdMkoVmOYaR1etoteuKObS21cc1VbIQAAAAAHYUgdNXR0u3xNdiTr072z2DVec9EQQ/wNo1OAAAAAAM8NSv7ISDPN9E9XNL9vX7h8LuJHWlopUcX39DxsDx23AQQEAQIDADUCAAAAAQAAAAAAAAAAAAAAAAAAAIWWp5Il3Kg312pzVk6Jt61iyFhTbtmkh/ORbj3JUQRbAA==', 'base64']}]}, 'id': 10} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_confirmed_block_args ( slot , encoding ) return await self . _provider . make_request ( * args ) async def get_recent_performance_samples ( self , limit : Optional [ int ] = None ) -> types . RPCResponse : \"\"\"Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Args: limit: Limit (optional) number of samples to return (maximum 720) Examples: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_recent_performance_samples(4)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [ { 'numSlots': 126, 'numTransactions': 126, 'samplePeriodSecs': 60, 'slot': 348125 }, { 'numSlots': 126, 'numTransactions': 126, 'samplePeriodSecs': 60, 'slot': 347999 }, { 'numSlots': 125, 'numTransactions': 125, 'samplePeriodSecs': 60, 'slot': 347873 }, { 'numSlots': 125, 'numTransactions': 125, 'samplePeriodSecs': 60, 'slot': 347748 } ], 'id': 1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_recent_performance_samples_args ( limit ) return await self . _provider . make_request ( * args ) async def get_block ( self , slot : int , encoding : str = \"json\" , ) -> types . RPCResponse : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_block(1)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockHeight': 0, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': {'message': {'accountKeys': ['LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk', 'EKAar3bMQUZvGSonq7vcPF2nPaCYowbnat44FPafW8Po', 'SysvarS1otHashes111111111111111111111111111', 'SysvarC1ock11111111111111111111111111111111', 'Vote111111111111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 3, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [1, 2, 3, 0], 'data': '37u9WtQpcm6ULa3VmTgTKEBCtYMxq84mk82tRvKdFEwj3rALiptAzuMJ1yoVSFAMARMZYp7q', 'programIdIndex': 4}], 'recentBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2'}, 'signatures': ['63jnpMCs7TNnCjnTqUrX7Mvqc5CbJMtVkLxBjPHUQkjXyZrQuZpfhjvzA7A29D9tMqVaiQC3UNP1NeaZKFFHJyQE']}}]}, 'id': 9} >>> asyncio.run(solana_client.get_block(1, encoding=\"base64\")) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockHeight': 0, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': ['AfxyKHmHIjXWjkyHODGeAbVxmfQWPj1ydS9nF+ynJHo8I1vCPDp2P9Cj5aA6W1CAHEHCqY0B1FDKomCzRo3qrAsBAAMFBQ6QBWfhQF7rG02xhuEsmmrUtz3AUjBtJKkqaHPJEmvFzziDX0C0robPrl9RbOyXHoc9/Dxa0zoGL6cEjvCjLgan1RcZLwqvxvJl4/t3zHragsUp0L47E24tAFUgAAAABqfVFxjHdMkoVmOYaR1etoteuKObS21cc1VbIQAAAAAHYUgdNXR0u3xNdiTr072z2DVec9EQQ/wNo1OAAAAAAM8NSv7ISDPN9E9XNL9vX7h8LuJHWlopUcX39DxsDx23AQQEAQIDADUCAAAAAQAAAAAAAAAAAAAAAAAAAIWWp5Il3Kg312pzVk6Jt61iyFhTbtmkh/ORbj3JUQRbAA==', 'base64']}]}, 'id': 10} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_block_args ( slot , encoding ) return await self . _provider . make_request ( * args ) async def get_block_height ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the current block height of the node. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_block_height()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1233, 'id': 1} \"\"\" args = self . _get_block_height_args ( commitment ) return await self . _provider . make_request ( * args ) async def get_confirmed_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> types . RPCResponse : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_confirmed_blocks(5, 10)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [5, 6, 7, 8, 9, 10], 'id': 1} \"\"\" args = self . _get_confirmed_blocks_args ( start_slot , end_slot ) return await self . _provider . make_request ( * args ) async def get_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> types . RPCResponse : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_blocks(5, 10)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [5, 6, 7, 8, 9, 10], 'id': 1} \"\"\" args = self . _get_blocks_args ( start_slot , end_slot ) return await self . _provider . make_request ( * args ) async def get_confirmed_signature_for_address2 ( self , account : Union [ str , Keypair , PublicKey ], before : Optional [ str ] = None , until : Optional [ str ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optoinal) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_confirmed_signature_for_address2(\"Vote111111111111111111111111111111111111111\", limit=1)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [{'err': None, 'memo': None, 'signature': 'v1BK8XcaPBzAGd7TB1K53pMdi6TBGe5CLCgx8cmZ4Bj63ZNvA6ca2QaxFpBFdvmpoFQ51VorBjifkBGLTDhwpqN', 'slot': 4290}], 'id': 2} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_confirmed_signature_for_address2_args ( account , before , until , limit , commitment ) return await self . _provider . make_request ( * args ) async def get_signatures_for_address ( self , account : Union [ str , Keypair , PublicKey ], before : Optional [ str ] = None , until : Optional [ str ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_signatures_for_address(\"Vote111111111111111111111111111111111111111\", limit=1)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [{'err': None, 'memo': None, 'signature': 'v1BK8XcaPBzAGd7TB1K53pMdi6TBGe5CLCgx8cmZ4Bj63ZNvA6ca2QaxFpBFdvmpoFQ51VorBjifkBGLTDhwpqN', 'slot': 4290}], 'id': 2} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_signatures_for_address_args ( account , before , until , limit , commitment ) return await self . _provider . make_request ( * args ) async def get_confirmed_transaction ( self , tx_sig : str , encoding : str = \"json\" ) -> types . RPCResponse : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_confirmed_transaction(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\")) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'meta': {'err': None, 'fee': 5000, 'postBalances': [498449233720610510, 1000001001987940, 1], 'preBalances': [498449233721615510, 1000001000987940, 1], 'status': {'Ok': None}}, 'slot': 1659335, 'transaction': {'message': {'accountKeys': ['9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g', '2KW2XRd9kwqet15Aha2oK3tYvd3nWbTFH1MBiRAv1BE1', '11111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 1, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [0, 1], 'data': '3Bxs4Bc3VYuGVB19', 'programIdIndex': 2}], 'recentBlockhash': 'FwcsKNptGtMLccXAA9YgnivVFK95mKzECLT1DNPi3SDr'}, 'signatures': ['3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy']}}, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_confirmed_transaction_args ( tx_sig , encoding ) return await self . _provider . make_request ( * args ) async def get_transaction ( self , tx_sig : str , encoding : str = \"json\" , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_transaction(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\")) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'meta': {'err': None, 'fee': 5000, 'rewards': [], 'postBalances': [498449233720610510, 1000001001987940, 1], 'preBalances': [498449233721615510, 1000001000987940, 1], 'status': {'Ok': None}}, 'slot': 1659335, 'transaction': {'message': {'accountKeys': ['9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g', '2KW2XRd9kwqet15Aha2oK3tYvd3nWbTFH1MBiRAv1BE1', '11111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 1, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [0, 1], 'data': '3Bxs4Bc3VYuGVB19', 'programIdIndex': 2}], 'recentBlockhash': 'FwcsKNptGtMLccXAA9YgnivVFK95mKzECLT1DNPi3SDr'}, 'signatures': ['3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy']}}, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_transaction_args ( tx_sig , encoding , commitment ) return await self . _provider . make_request ( * args ) async def get_epoch_info ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns information about the current epoch. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_epoch_info()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'absoluteSlot': 5150, 'blockHeight': 5150, 'epoch': 0, 'slotIndex': 5150, 'slotsInEpoch': 8192}, 'id': 5} \"\"\" args = self . _get_epoch_info_args ( commitment ) return await self . _provider . make_request ( * args ) async def get_epoch_schedule ( self ) -> types . RPCResponse : \"\"\"Returns epoch schedule information from this cluster's genesis config. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_epoch_schedule()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'firstNormalEpoch': 0, 'firstNormalSlot': 0, 'leaderScheduleSlotOffset': 8192, 'slotsPerEpoch': 8192, 'warmup': False}, 'id': 6} \"\"\" return await self . _provider . make_request ( self . _get_epoch_schedule ) async def get_fee_calculator_for_blockhash ( self , blockhash : Union [ str , Blockhash ], commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the fee calculator associated with the query blockhash, or null if the blockhash has expired. Args: blockhash: Blockhash to query as a Base58 encoded string. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_fee_calculator_for_blockhash(\"BaQSR194dC4dZaRxATtxYyEwDkk7VgqUY8NVNkub8HFZ\")) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 7065}, 'value': {'feeCalculator': {'lamportsPerSignature': 5000}}}, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_fee_calculator_for_blockhash_args ( blockhash , commitment ) return await self . _provider . make_request ( * args ) async def get_fee_for_message ( self , message : Message , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the fee for a message. Args: message: Message that the fee is requested for. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solana.keypair import Keypair >>> from solana.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> sender, receiver = Keypair.from_seed(bytes(PublicKey(1))), Keypair.from_seed(bytes(PublicKey(2))) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.public_key, to_pubkey=receiver.public_key, lamports=1000))) >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_fee_for_message(txn.compile_message())) # doctest: +SKIP {'jsonrpc': '2.0', 'result': { 'context': { 'slot': 5068 }, 'value': 5000 }, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long if isinstance ( message , Transaction ): raise TransactionUncompiledError ( \"Transaction uncompiled, please compile to message first.\" ) args = self . _get_fee_for_message_args ( message , commitment ) return await self . _provider . make_request ( * args ) async def get_fee_rate_governor ( self ) -> types . RPCResponse : \"\"\"Return the fee rate governor information from the root bank. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_fee_rate_governor()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 7172}, 'value': {'feeRateGovernor': {'burnPercent': 50, 'maxLamportsPerSignature': 100000, 'minLamportsPerSignature': 5000, 'targetLamportsPerSignature': 10000, 'targetSignaturesPerSlot': 20000}}}, 'id': 5} \"\"\" return await self . _provider . make_request ( self . _get_fee_rate_governor ) async def get_fees ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns a recent block hash from the ledger, a fee schedule and the last slot the blockhash will be valid. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_fees()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 7727}, 'value': {'blockhash': 'GGS6AEDqjF5irU6D6VQNherEZ2hckGaeBiVdfSZKg4gd', 'feeCalculator': {'lamportsPerSignature': 5000}, 'lastValidSlot': 8027}}, 'id': 1} \"\"\" args = self . _get_fees_args ( commitment ) return await self . _provider . make_request ( * args ) async def get_first_available_block ( self ) -> types . RPCResponse : \"\"\"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_fees()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1, 'id': 2} \"\"\" return await self . _provider . make_request ( self . _get_first_available_block ) async def get_genesis_hash ( self ) -> types . RPCResponse : \"\"\"Returns the genesis hash. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_genesis_hash()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'id': 3} \"\"\" return await self . _provider . make_request ( self . _get_genesis_hash ) async def get_identity ( self ) -> types . RPCResponse : \"\"\"Returns the identity pubkey for the current node. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_identity()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'identity': 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk'}, 'id': 4} \"\"\" return await self . _provider . make_request ( self . _get_identity ) async def get_inflation_governor ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the current inflation governor. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_inflation_governor()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'foundation': 0.05, 'foundationTerm': 7.0, 'initial': 0.15, 'taper': 0.15, 'terminal': 0.015}, 'id': 5} \"\"\" args = self . _get_inflation_governor_args ( commitment ) return await self . _provider . make_request ( * args ) async def get_inflation_rate ( self ) -> types . RPCResponse : \"\"\"Returns the specific inflation values for the current epoch. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_inflation_rate()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'epoch': 1, 'foundation': 0.007499746885736559, 'total': 0.14999493771473116, 'validator': 0.1424951908289946}, 'id': 1} \"\"\" return await self . _provider . make_request ( self . _get_inflation_rate ) async def get_largest_accounts ( self , filter_opt : Optional [ str ] = None , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the 20 largest accounts, by lamport balance. Args: filter_opt: Filter results by account type; currently supported: circulating|nonCirculating. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_largest_accounts()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 8890}, 'value': [{'address': '95L7AsBCLRsqghsi6ksZkzjNbs6rqDgHCzKaGZ7bJi75', 'lamports': 500000000000000000}, {'address': 'APnSR52EC1eH676m7qTBHUJ1nrGpHYpV7XKPxgRDD8gX', 'lamports': 164511033098290000}, {'address': '13LeFbG6m2EP1fqCj9k66fcXsoTHMMtgr7c78AivUrYD', 'lamports': 153333632446109120}, {'address': 'GK2zqSsXLA2rwVZk347RYhh6jJpRsCA69FjLW93ZGi3B', 'lamports': 57499999036109120}, {'address': '8HVqyX9jebh31Q9Hp8t5sMVJs665979ZeEr3eCfzitUe', 'lamports': 30301031036109120}, {'address': 'HbZ5FfmKWNHC7uwk6TF1hVi6TCs7dtYfdjEcuPGgzFAg', 'lamports': 14999999036109120}, {'address': '14FUT96s9swbmH7ZjpDvfEDywnAYy9zaNhv4xvezySGu', 'lamports': 4999999036109120}, {'address': '9huDUZfxoJ7wGMTffUE7vh1xePqef7gyrLJu9NApncqA', 'lamports': 4999999036109120}, {'address': 'C7C8odR8oashR5Feyrq2tJKaXL18id1dSj2zbkDGL2C2', 'lamports': 4999999036109120}, {'address': 'AYgECURrvuX6GtFe4tX7aAj87Xc5r5Znx96ntNk1nCv', 'lamports': 2499999518054560}, {'address': 'AogcwQ1ubM76EPMhSD5cw1ES4W5econvQCFmBL6nTW1', 'lamports': 2499999518054560}, {'address': 'gWgqQ4udVxE3uNxRHEwvftTHwpEmPHAd8JR9UzaHbR2', 'lamports': 2499999518054560}, {'address': '3D91zLQPRLamwJfGR5ZYMKQb4C18gsJNaSdmB6b2wLhw', 'lamports': 2499999518054560}, {'address': '3bHbMa5VW3np5AJazuacidrN4xPZgwhcXigmjwHmBg5e', 'lamports': 2499999518054560}, {'address': '4U3RFq7X5kLG6tZ9kcksFL8oXeGNjtuUN1YfkVKXbs5x', 'lamports': 2499999518054560}, {'address': '5cBVGBKY6kBaiTVmsQpxThJ2oqitBYuCAX9Zm2zMuV4y', 'lamports': 2499999518054560}, {'address': '8PjJTv657aeN9p5R2WoM6pPSz385chvTTytUWaEjSjkq', 'lamports': 2499999518054560}, {'address': 'AHB94zKUASftTdqgdfiDSdnPJHkEFp7zX3yMrcSxABsv', 'lamports': 2499999518054560}, {'address': 'Hc36Wh1ZqYGzGAnsJWNT9r2gY3h9n89uDpxZPsmEsiE3', 'lamports': 2499999518054560}, {'address': 'GxyRKP2eVKACaSSnso4VLSAjZKmHsFXHWUfS3A5CtiMA', 'lamports': 1940147018054560}]}, 'id': 2} \"\"\" args = self . _get_largest_accounts_args ( filter_opt , commitment ) return await self . _provider . make_request ( * args ) async def get_leader_schedule ( self , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the leader schedule for an epoch. Args: epoch: Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_leader_schedule()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'EWj2cuEuVhi7RX81cnAY3TzpyFwnHzzVwvuTyfmxmhs3': [0, 1, 2, 3, 4, 5, ...]}, 'id': 6} \"\"\" args = self . _get_leader_schedule_args ( epoch , commitment ) return await self . _provider . make_request ( * args ) async def get_minimum_balance_for_rent_exemption ( self , usize : int , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns minimum balance required to make account rent exempt. Args: usize: Account data length. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_minimum_balance_for_rent_exemption(50)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1238880, 'id': 7} \"\"\" args = self . _get_minimum_balance_for_rent_exemption_args ( usize , commitment ) return await self . _provider . make_request ( * args ) async def get_multiple_accounts ( self , pubkeys : List [ Union [ PublicKey , str ]], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> types . RPCResponse : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. - \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solana.publickey import PublicKey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> pubkeys = [PublicKey(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), PublicKey(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> asyncio.run(solana_client.get_multiple_accounts(pubkeys)) # doctest: +SKIP { \"jsonrpc\": \"2.0\", \"result\": { \"context\": {\"slot\": 97531946}, \"value\": [ { \"data\": [\"\", \"base64\"], \"executable\": False, \"lamports\": 1, \"owner\": \"11111111111111111111111111111111\", \"rentEpoch\": 225, }, { \"data\": [\"\", \"base64\"], \"executable\": False, \"lamports\": 809441127, \"owner\": \"11111111111111111111111111111111\", \"rentEpoch\": 225, }, ], }, \"id\": 1, } \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_multiple_accounts_args ( pubkeys = pubkeys , commitment = commitment , encoding = encoding , data_slice = data_slice ) return await self . _provider . make_request ( * args ) async def get_program_accounts ( # pylint: disable=too-many-arguments self , pubkey : Union [ str , PublicKey ], commitment : Optional [ Commitment ] = Finalized , encoding : Optional [ str ] = None , data_slice : Optional [ types . DataSliceOpts ] = None , data_size : Optional [ int ] = None , memcmp_opts : Optional [ List [ types . MemcmpOpts ]] = None , ) -> types . RPCResponse : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for the returned Transaction, either jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. data_size: (optional) Option to compare the program account data length with the provided data size. memcmp_opts: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> memcmp_opts = [ ... types.MemcmpOpts(offset=4, bytes=\"3Mc6vR\"), ... ] >>> asyncio.run(solana_client.get_program_accounts(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\", data_size=17, memcmp_opts=memcmp_opts)) # doctest: +SKIP {'jsonrpc': \"2.0\", 'result' :[{ 'account' :{ 'data' :'2R9jLfiAQ9bgdcw6h8s44439', 'executable' :false, 'lamports' :15298080, 'owner' :'4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T', 'rentEpoch' :28}, 'pubkey' :'CxELquR1gPP8wHe33gZ4QxqGB3sZ9RSwsJ2KshVewkFY'}], 'id' :1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_program_accounts_args ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , data_size = data_size , memcmp_opts = memcmp_opts , ) return await self . _provider . make_request ( * args ) async def get_recent_blockhash ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns a recent block hash from the ledger. Response also includes a fee schedule that can be used to compute the cost of submitting a transaction using it. Deprecated, please use get_latest_blockhash() instead. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_recent_blockhash()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 1637}, 'value': {'blockhash': 'EALChog1mXQ9nEgEUQpWAtmA5UueUZvZiL16ZivmR7eb', 'feeCalculator': {'lamportsPerSignature': 5000}}}, 'id': 2} \"\"\" args = self . _get_recent_blockhash_args ( commitment ) return await self . _provider . make_request ( * args ) async def get_latest_blockhash ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the latest block hash from the ledger. Response also includes the last valid block height. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_latest_blockhash()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 1637}, 'value': {'blockhash': 'EALChog1mXQ9nEgEUQpWAtmA5UueUZvZiL16ZivmR7eb', 'lastValidBlockHeight': 3090}}, 'id': 2} \"\"\" args = self . _get_latest_blockhash_args ( commitment ) return await self . _provider . make_request ( * args ) async def get_signature_statuses ( self , signatures : List [ Union [ str , bytes ]], search_transaction_history : bool = False ) -> types . RPCResponse : \"\"\"Returns the statuses of a list of signatures. Unless the `search_transaction_history` configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus `MAX_RECENT_BLOCKHASHES` rooted slots. Args: signatures: An array of transaction signatures to confirm. search_transaction_history: If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> signatures = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\", ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\"] >>> asyncio.run(solana_client.get_signature_statuses(signatures)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': { 'context': {'slot':82}, 'value': [{ 'slot': 72, 'confirmations': 10, 'err': null, 'status': {'Ok': null}}, null]}, 'id': 1} \"\"\" args = self . _get_signature_statuses_args ( signatures , search_transaction_history ) return await self . _provider . make_request ( * args ) async def get_slot ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the current slot the node is processing. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_slot()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 7515, 'id': 1} \"\"\" args = self . _get_slot_args ( commitment ) return await self . _provider . make_request ( * args ) async def get_slot_leader ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the current slot leader. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_slot_leader()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'EWj2cuEuVhi7RX81cnAY3TzpyFwnHzzVwvuTyfmxmhs3', 'id': 1} \"\"\" args = self . _get_slot_leader_args ( commitment ) return await self . _provider . make_request ( * args ) async def get_stake_activation ( self , pubkey : Union [ PublicKey , str ], epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns epoch activation information for a stake account. Args: pubkey: Pubkey of stake account to query, as base-58 encoded string or PublicKey object. epoch: (optional) Epoch for which to calculate activation details. If parameter not provided, defaults to current epoch. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_stake_activation()) # doctest: +SKIP {'jsonrpc': '2.0','result': {'active': 124429280, 'inactive': 73287840, 'state': 'activating'}, 'id': 1}} \"\"\" args = self . _get_stake_activation_args ( pubkey , epoch , commitment ) return await self . _provider . make_request ( * args ) async def get_supply ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns information about the current supply. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_supply()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 3846}, 'value': {'circulating': 683635192454157660, 'nonCirculating': 316364808037127120, 'nonCirculatingAccounts': ['ETfDYz7Cg5p9SDFmdpRerjBN5puKK7xydEBZZGM2V4Ay', '7cKxv6UznFoWRuJkgw5bWj5rp5PiKTcXZeEaLqyd3Bbm', 'CV7qh8ZoqeUSTQagosGpkLptXoojf9yCszxkRx1jTD12', 'FZ9S7X9jMbCaMyJjRfSoBhFyarUMVwvx7HWRe4LnZHsg', ...] 'total': 1000000000491284780}}, 'id': 1} \"\"\" args = self . _get_supply_args ( commitment ) return await self . _provider . make_request ( * args ) async def get_token_account_balance ( self , pubkey : Union [ str , PublicKey ], commitment : Optional [ Commitment ] = None ): \"\"\"Returns the token balance of an SPL Token account (UNSTABLE). Args: pubkey: Pubkey of Token account to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_token_account_balance(\"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\")) # noqa: E501 # pylint: disable=line-too-long # doctest: +SKIP {'jsonrpc': '2.0','result': { 'context': {'slot':1114}, 'value': { 'uiAmount': 98.64, 'amount': '9864', 'decimals': 2}, 'id' :1} \"\"\" args = self . _get_token_account_balance_args ( pubkey , commitment ) return await self . _provider . make_request ( * args ) async def get_token_accounts_by_delegate ( self , delegate : PublicKey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" args = self . _get_token_accounts_by_delegate_args ( delegate , opts , commitment ) return await self . __get_token_accounts ( * args ) async def get_token_accounts_by_owner ( self , owner : PublicKey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Returns all SPL Token accounts by token owner (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" args = self . _get_token_accounts_by_owner_args ( owner , opts , commitment ) return await self . __get_token_accounts ( * args ) async def __get_token_accounts ( self , method : types . RPCMethod , pubkey : str , opts : types . TokenAccountOpts , commitment : Commitment , ) -> types . RPCResponse : args = self . _get_token_accounts_args ( method , pubkey , opts , commitment ) return await self . _provider . make_request ( * args ) async def get_token_largest_accounts ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the 20 largest accounts of a particular SPL Token type.\"\"\" args = self . _get_token_largest_account_args ( pubkey , commitment ) return await self . _provider . make_request ( * args ) async def get_token_supply ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the total supply of an SPL Token type.\"\"\" args = self . _get_token_supply_args ( pubkey , commitment ) return await self . _provider . make_request ( * args ) async def get_transaction_count ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the current Transaction count from the ledger. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_transaction_count()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 4554, 'id': 1} \"\"\" args = self . _get_transaction_count_args ( commitment ) return await self . _provider . make_request ( * args ) async def get_minimum_ledger_slot ( self ) -> types . RPCResponse : \"\"\"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_minimum_ledger_slot()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1234, 'id': 1} \"\"\" return await self . _provider . make_request ( self . _minimum_ledger_slot ) async def get_version ( self ) -> types . RPCResponse : \"\"\"Returns the current solana versions running on the node. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_version()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'solana-core': '1.4.0 5332fcad'}, 'id': 1} \"\"\" return await self . _provider . make_request ( self . _get_version ) async def get_vote_accounts ( self , commitment : Optional [ Commitment ] = None ): \"\"\"Returns the account info and associated stake for all the voting accounts in the current bank. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_vote_accounts()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'current': [{'activatedStake': 0, 'commission': 100, 'epochCredits': [[165, 714644, 707372], [166, 722092, 714644], [167, 730285, 722092], [168, 738476, 730285], ...] 'epochVoteAccount': True, 'lastVote': 1872294, 'nodePubkey': 'J7v9ndmcoBuo9to2MnHegLnBkC9x3SAVbQBJo5MMJrN1', 'rootSlot': 1872263, 'votePubkey': 'HiFjzpR7e5Kv2tdU9jtE4FbH1X8Z9Syia3Uadadx18b5'}, {'activatedStake': 500029968930560, 'commission': 100, 'epochCredits': [[165, 1359689, 1351498], [166, 1367881, 1359689], [167, 1376073, 1367881], [168, 1384265, 1376073], ...], 'epochVoteAccount': True, 'lastVote': 1872295, 'nodePubkey': 'dv1LfzJvDF7S1fBKpFgKoKXK5yoSosmkAdfbxBo1GqJ', 'rootSlot': 1872264, 'votePubkey': '5MMCR4NbTZqjthjLGywmeT66iwE9J9f7kjtxzJjwfUx2'}, {'activatedStake': 0, 'commission': 100, 'epochCredits': [[227, 2751, 0], [228, 7188, 2751]], 'epochVoteAccount': True, 'lastVote': 1872295, 'nodePubkey': 'H1wDvJ5HJc1SzhHoWtaycpzQpFbsL7g8peaRV3obKShs', 'rootSlot': 1872264, 'votePubkey': 'DPqpgoLQVU3aq72HEqSMsB9qh4KoXc9fGEpvgEuiwnp6'}], 'delinquent': []}, 'id': 1} \"\"\" args = self . _get_vote_accounts_args ( commitment ) return await self . _provider . make_request ( * args ) async def request_airdrop ( self , pubkey : Union [ PublicKey , str ], lamports : int , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Requests an airdrop of lamports to a Pubkey. Args: pubkey: Pubkey of account to receive lamports, as base-58 encoded string or public key object. lamports: Amount of lamports. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solana.publickey import PublicKey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.request_airdrop(PublicKey(1), 10000)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'uK6gbLbhnTEgjgmwn36D5BRTRkG4AT8r7Q162TLnJzQnHUZVL9r6BYZVfRttrhmkmno6Fp4VQELzL4AiriCo61U', 'id': 1} \"\"\" args = self . _request_airdrop_args ( pubkey , lamports , commitment ) return await self . _provider . make_request ( * args ) async def send_raw_transaction ( self , txn : Union [ bytes , str ], opts : Optional [ types . TxOpts ] = None ) -> types . RPCResponse : \"\"\"Send a transaction that has already been signed and serialized into the wire format. Args: txn: Fully-signed Transaction object, a fully sign transaction in wire format, or a fully transaction as base-64 encoded string. opts: (optional) Transaction options. Before submitting, the following preflight checks are performed (unless disabled with the `skip_preflight` option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> full_signed_tx_str = ( ... \"AbN5XM+qw+7oOLsFw7goQSLBis7c1kXJFP6OF4w7YmQNhhbQYcyBiybKuOzzhV7McvoRP3Mey9AhXojtwDCdbwoBAAEDE5j2\" ... \"LG0aRXxRumpLXz29L2n8qTIWIY3ImX5Ba9F9k8poq0Z3/7HyiU3QphU8Ix1F7ENq5TrmAUnb4V8y5LhwPwAAAAAAAAAAAAAA\" ... \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAg5YY9wG6fpuieuWYJd1ta7ZtFPbV0OriFRYdcYUaEGkBAgIAAQwCAAAAQEIPAAAAAAA=\") >>> asyncio.run(solana_client.send_raw_transaction(full_signed_tx_str)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'CMwyESM2NE74mghfbvsHJDERF7xMYKshwwm6VgH6GFqXzx8LfBFuP5ruccumfhTguha6seUHPpiHzzHUQXzq2kN', 'id': 1} \"\"\" # noqa: E501 # pylint: disable=line-too-long opts_to_use = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts args = self . _send_raw_transaction_args ( txn , opts_to_use ) resp = await self . _provider . make_request ( * args ) if opts_to_use . skip_confirmation : return self . _post_send ( resp ) post_send_args = self . _send_raw_transaction_post_send_args ( resp , opts_to_use ) return await self . __post_send_with_confirm ( * post_send_args ) async def send_transaction ( self , txn : Transaction , * signers : Keypair , opts : Optional [ types . TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> types . RPCResponse : \"\"\"Send a transaction. Args: txn: Transaction object. signers: Signers to sign the transaction. opts: (optional) Transaction options. recent_blockhash: (optional) Pass a valid recent blockhash here if you want to skip fetching the recent blockhash or relying on the cache. Example: >>> from solana.keypair import Keypair >>> from solana.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> sender, receiver = Keypair.from_seed(bytes(PublicKey(1))), Keypair.from_seed(bytes(PublicKey(2))) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.public_key, to_pubkey=receiver.public_key, lamports=1000))) >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.send_transaction(txn, sender)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': '236zSA5w4NaVuLXXHK1mqiBuBxkNBu84X6cfLBh1v6zjPrLfyECz4zdedofBaZFhs4gdwzSmij9VkaSo2tR5LTgG', 'id': 12} \"\"\" last_valid_block_height = None if recent_blockhash is None : if self . blockhash_cache : try : recent_blockhash = self . blockhash_cache . get () except ValueError : blockhash_resp = await self . get_latest_blockhash ( Finalized ) recent_blockhash = self . _process_blockhash_resp ( blockhash_resp , used_immediately = True ) last_valid_block_height = blockhash_resp [ \"result\" ][ \"value\" ][ \"lastValidBlockHeight\" ] else : blockhash_resp = await self . get_latest_blockhash ( Finalized ) recent_blockhash = self . parse_recent_blockhash ( blockhash_resp ) last_valid_block_height = blockhash_resp [ \"result\" ][ \"value\" ][ \"lastValidBlockHeight\" ] txn . recent_blockhash = recent_blockhash txn . sign ( * signers ) opts_to_use = ( types . TxOpts ( preflight_commitment = self . _commitment , last_valid_block_height = last_valid_block_height ) if opts is None else opts ) txn_resp = await self . send_raw_transaction ( txn . serialize (), opts = opts_to_use ) if self . blockhash_cache : blockhash_resp = await self . get_latest_blockhash ( Finalized ) self . _process_blockhash_resp ( blockhash_resp , used_immediately = False ) return txn_resp async def simulate_transaction ( self , txn : Union [ bytes , str , Transaction ], sig_verify : bool = False , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Simulate sending a transaction. Args: txn: A Transaction object, a transaction in wire format, or a transaction as base-64 encoded string The transaction must have a valid blockhash, but is not required to be signed. sig_verify: If true the transaction signatures will be verified (default: false). commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> tx_str = ( ... \"4hXTCkRzt9WyecNzV1XPgCDfGAZzQKNxLXgynz5QDuWWPSAZBZSHptvWRL3BjCvzUXRdKvHL2b7yGrRQcWyaqsaBCncVG7BF\" ... \"ggS8w9snUts67BSh3EqKpXLUm5UMHfD7ZBe9GhARjbNQMLJ1QD3Spr6oMTBU6EhdB4RD8CP2xUxr2u3d6fos36PD98XS6oX8\" ... \"TQjLpsMwncs5DAMiD4nNnR8NBfyghGCWvCVifVwvA8B8TJxE1aiyiv2L429BCWfyzAme5sZW8rDb14NeCQHhZbtNqfXhcp2t\" ... ) >>> asyncio.run(solana_client.simulate_transaction(tx_str)) # doctest: +SKIP {'jsonrpc' :'2.0', 'result': {'context': {'slot': 218}, 'value': { 'err': null, 'logs': ['BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success']}, 'id':1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _simulate_transaction_args ( txn , sig_verify , commitment ) return await self . _provider . make_request ( * args ) async def set_log_filter ( self , log_filter : str ) -> types . RPCResponse : \"\"\"Sets the log filter on the validator. Args: log_filter: The new log filter to use. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.set_log_filter(\"solana_core=debug\")) # doctest: +SKIP {'jsonrpc': '2.0', 'result': None, 'id': 1} \"\"\" args = self . _set_log_filter_args ( log_filter ) return await self . _provider . make_request ( * args ) async def validator_exit ( self ) -> types . RPCResponse : \"\"\"Request to have the validator exit. Validator must have booted with RPC exit enabled (`--enable-rpc-exit` parameter). Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> solana_client.validator_exit() # doctest: +SKIP {'jsonrpc': '2.0', 'result': true, 'id': 1} \"\"\" return await self . _provider . make_request ( self . _validator_exit ) async def __post_send_with_confirm ( self , resp : types . RPCResponse , conf_comm : Commitment , last_valid_block_height : Optional [ int ] ) -> types . RPCResponse : resp = self . _post_send ( resp ) self . _provider . logger . info ( \"Transaction sent to %s . Signature %s : \" , self . _provider . endpoint_uri , resp [ \"result\" ] ) await self . confirm_transaction ( resp [ \"result\" ], conf_comm , last_valid_block_height = last_valid_block_height ) return resp async def confirm_transaction ( self , tx_sig : str , commitment : Optional [ Commitment ] = None , sleep_seconds : float = 0.5 , last_valid_block_height : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Confirm the transaction identified by the specified signature. Args: tx_sig: the transaction signature to confirm. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". sleep_seconds: The number of seconds to sleep when polling the signature status. last_valid_block_height: The block height by which the transaction would become invalid. \"\"\" commitment_to_use = self . _commitment if commitment is None else commitment commitment_rank = COMMITMENT_RANKS [ commitment_to_use ] if last_valid_block_height : # pylint: disable=no-else-return current_blockheight = ( await self . get_block_height ( commitment ))[ \"result\" ] while current_blockheight <= last_valid_block_height : resp = await self . get_signature_statuses ([ tx_sig ]) maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) resp_value = resp [ \"result\" ][ \"value\" ][ 0 ] if resp_value is not None : confirmation_status = resp_value [ \"confirmationStatus\" ] confirmation_rank = COMMITMENT_RANKS [ confirmation_status ] if confirmation_rank >= commitment_rank : break current_blockheight = ( await self . get_block_height ( commitment ))[ \"result\" ] await asyncio . sleep ( sleep_seconds ) else : maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) raise TransactionExpiredBlockheightExceededError ( f \" { tx_sig } has expired: block height exceeded\" ) return resp else : timeout = time () + 30 while time () < timeout : resp = await self . get_signature_statuses ([ tx_sig ]) maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) resp_value = resp [ \"result\" ][ \"value\" ][ 0 ] if resp_value is not None : confirmation_status = resp_value [ \"confirmationStatus\" ] confirmation_rank = COMMITMENT_RANKS [ confirmation_status ] if confirmation_rank >= commitment_rank : break await asyncio . sleep ( sleep_seconds ) else : maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) raise UnconfirmedTxError ( f \"Unable to confirm transaction { tx_sig } \" ) return resp","title":"AsyncClient"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.__init__","text":"Init API client. Source code in solana/rpc/async_api.py def __init__ ( self , endpoint : Optional [ str ] = None , commitment : Optional [ Commitment ] = None , blockhash_cache : Union [ BlockhashCache , bool ] = False , timeout : float = 10 , ) -> None : \"\"\"Init API client.\"\"\" super () . __init__ ( commitment , blockhash_cache ) self . _provider = async_http . AsyncHTTPProvider ( endpoint , timeout = timeout )","title":"__init__()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.close","text":"Use this when you are done with the client. Source code in solana/rpc/async_api.py async def close ( self ) -> None : \"\"\"Use this when you are done with the client.\"\"\" await self . _provider . close ()","title":"close()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.confirm_transaction","text":"Confirm the transaction identified by the specified signature. Parameters: Name Type Description Default tx_sig str the transaction signature to confirm. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None sleep_seconds float The number of seconds to sleep when polling the signature status. 0.5 last_valid_block_height Optional[int] The block height by which the transaction would become invalid. None Source code in solana/rpc/async_api.py async def confirm_transaction ( self , tx_sig : str , commitment : Optional [ Commitment ] = None , sleep_seconds : float = 0.5 , last_valid_block_height : Optional [ int ] = None , ) -> types . RPCResponse : \"\"\"Confirm the transaction identified by the specified signature. Args: tx_sig: the transaction signature to confirm. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". sleep_seconds: The number of seconds to sleep when polling the signature status. last_valid_block_height: The block height by which the transaction would become invalid. \"\"\" commitment_to_use = self . _commitment if commitment is None else commitment commitment_rank = COMMITMENT_RANKS [ commitment_to_use ] if last_valid_block_height : # pylint: disable=no-else-return current_blockheight = ( await self . get_block_height ( commitment ))[ \"result\" ] while current_blockheight <= last_valid_block_height : resp = await self . get_signature_statuses ([ tx_sig ]) maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) resp_value = resp [ \"result\" ][ \"value\" ][ 0 ] if resp_value is not None : confirmation_status = resp_value [ \"confirmationStatus\" ] confirmation_rank = COMMITMENT_RANKS [ confirmation_status ] if confirmation_rank >= commitment_rank : break current_blockheight = ( await self . get_block_height ( commitment ))[ \"result\" ] await asyncio . sleep ( sleep_seconds ) else : maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) raise TransactionExpiredBlockheightExceededError ( f \" { tx_sig } has expired: block height exceeded\" ) return resp else : timeout = time () + 30 while time () < timeout : resp = await self . get_signature_statuses ([ tx_sig ]) maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) resp_value = resp [ \"result\" ][ \"value\" ][ 0 ] if resp_value is not None : confirmation_status = resp_value [ \"confirmationStatus\" ] confirmation_rank = COMMITMENT_RANKS [ confirmation_status ] if confirmation_rank >= commitment_rank : break await asyncio . sleep ( sleep_seconds ) else : maybe_rpc_error = resp . get ( \"error\" ) if maybe_rpc_error is not None : raise RPCException ( maybe_rpc_error ) raise UnconfirmedTxError ( f \"Unable to confirm transaction { tx_sig } \" ) return resp","title":"confirm_transaction()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_account_info","text":"Returns all the account info for the specified public key. Parameters: Name Type Description Default pubkey Union[solana.publickey.PublicKey, str] Pubkey of account to query, as base-58 encoded string or PublicKey object. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding str (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". \"base58\" is limited to Account data of less than 128 bytes. \"base64\" will return base64 encoded data for Account data of any size. \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). 'base64' data_slice Optional[solana.rpc.types.DataSliceOpts] (optional) Option to limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None Examples: >>> from solana.publickey import PublicKey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_account_info ( PublicKey ( 1 ))) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 33265073 }, 'value' : { 'data' : '' , 'executable' : False , 'lamports' : 4459816188034584 , 'owner' : '11111111111111111111111111111111' , 'rentEpoch' : 90 }}, 'id' : 1 } Source code in solana/rpc/async_api.py async def get_account_info ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> types . RPCResponse : \"\"\"Returns all the account info for the specified public key. Args: pubkey: Pubkey of account to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. - \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solana.publickey import PublicKey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_account_info(PublicKey(1))) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 33265073}, 'value': {'data': '', 'executable': False, 'lamports': 4459816188034584, 'owner': '11111111111111111111111111111111', 'rentEpoch': 90}}, 'id': 1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_account_info_args ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , min_context_slot = None ) return await self . _provider . make_request ( * args )","title":"get_account_info()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_balance","text":"Returns the balance of the account of provided Pubkey. Parameters: Name Type Description Default pubkey Union[solana.publickey.PublicKey, str] Pubkey of account to query, as base-58 encoded string or PublicKey object. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solana.publickey import PublicKey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_balance ( PublicKey ( 1 ))) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 228 }, 'value' : 0 }, 'id' : 1 } Source code in solana/rpc/async_api.py async def get_balance ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the balance of the account of provided Pubkey. Args: pubkey: Pubkey of account to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solana.publickey import PublicKey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_balance(PublicKey(1))) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 228}, 'value': 0}, 'id': 1} \"\"\" args = self . _get_balance_args ( pubkey , commitment ) return await self . _provider . make_request ( * args )","title":"get_balance()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_block","text":"Returns identity and transaction information about a confirmed block in the ledger. Parameters: Name Type Description Default slot int Slot, as u64 integer. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_block ( 1 )) { 'jsonrpc' : '2.0' , 'result' : { 'blockTime' : None , 'blockHeight' : 0 , 'blockhash' : '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj' , 'parentSlot' : 0 , 'previousBlockhash' : 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2' , 'rewards' : [], 'transactions' : [{ 'meta' : { 'err' : None , 'fee' : 0 , 'postBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'preBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'status' : { 'Ok' : None }}, 'transaction' : { 'message' : { 'accountKeys' : [ 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk' , 'EKAar3bMQUZvGSonq7vcPF2nPaCYowbnat44FPafW8Po' , 'SysvarS1otHashes111111111111111111111111111' , 'SysvarC1ock11111111111111111111111111111111' , 'Vote111111111111111111111111111111111111111' ], 'header' : { 'numReadonlySignedAccounts' : 0 , 'numReadonlyUnsignedAccounts' : 3 , 'numRequiredSignatures' : 1 }, 'instructions' : [{ 'accounts' : [ 1 , 2 , 3 , 0 ], 'data' : '37u9WtQpcm6ULa3VmTgTKEBCtYMxq84mk82tRvKdFEwj3rALiptAzuMJ1yoVSFAMARMZYp7q' , 'programIdIndex' : 4 }], 'recentBlockhash' : 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2' }, 'signatures' : [ '63jnpMCs7TNnCjnTqUrX7Mvqc5CbJMtVkLxBjPHUQkjXyZrQuZpfhjvzA7A29D9tMqVaiQC3UNP1NeaZKFFHJyQE' ]}}]}, 'id' : 9 } >>> asyncio . run ( solana_client . get_block ( 1 , encoding = \"base64\" )) { 'jsonrpc' : '2.0' , 'result' : { 'blockTime' : None , 'blockHeight' : 0 , 'blockhash' : '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj' , 'parentSlot' : 0 , 'previousBlockhash' : 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2' , 'rewards' : [], 'transactions' : [{ 'meta' : { 'err' : None , 'fee' : 0 , 'postBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'preBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'status' : { 'Ok' : None }}, 'transaction' : [ 'AfxyKHmHIjXWjkyHODGeAbVxmfQWPj1ydS9nF+ynJHo8I1vCPDp2P9Cj5aA6W1CAHEHCqY0B1FDKomCzRo3qrAsBAAMFBQ6QBWfhQF7rG02xhuEsmmrUtz3AUjBtJKkqaHPJEmvFzziDX0C0robPrl9RbOyXHoc9/Dxa0zoGL6cEjvCjLgan1RcZLwqvxvJl4/t3zHragsUp0L47E24tAFUgAAAABqfVFxjHdMkoVmOYaR1etoteuKObS21cc1VbIQAAAAAHYUgdNXR0u3xNdiTr072z2DVec9EQQ/wNo1OAAAAAAM8NSv7ISDPN9E9XNL9vX7h8LuJHWlopUcX39DxsDx23AQQEAQIDADUCAAAAAQAAAAAAAAAAAAAAAAAAAIWWp5Il3Kg312pzVk6Jt61iyFhTbtmkh/ORbj3JUQRbAA==' , 'base64' ]}]}, 'id' : 10 } Source code in solana/rpc/async_api.py async def get_block ( self , slot : int , encoding : str = \"json\" , ) -> types . RPCResponse : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_block(1)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockHeight': 0, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': {'message': {'accountKeys': ['LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk', 'EKAar3bMQUZvGSonq7vcPF2nPaCYowbnat44FPafW8Po', 'SysvarS1otHashes111111111111111111111111111', 'SysvarC1ock11111111111111111111111111111111', 'Vote111111111111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 3, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [1, 2, 3, 0], 'data': '37u9WtQpcm6ULa3VmTgTKEBCtYMxq84mk82tRvKdFEwj3rALiptAzuMJ1yoVSFAMARMZYp7q', 'programIdIndex': 4}], 'recentBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2'}, 'signatures': ['63jnpMCs7TNnCjnTqUrX7Mvqc5CbJMtVkLxBjPHUQkjXyZrQuZpfhjvzA7A29D9tMqVaiQC3UNP1NeaZKFFHJyQE']}}]}, 'id': 9} >>> asyncio.run(solana_client.get_block(1, encoding=\"base64\")) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockHeight': 0, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': ['AfxyKHmHIjXWjkyHODGeAbVxmfQWPj1ydS9nF+ynJHo8I1vCPDp2P9Cj5aA6W1CAHEHCqY0B1FDKomCzRo3qrAsBAAMFBQ6QBWfhQF7rG02xhuEsmmrUtz3AUjBtJKkqaHPJEmvFzziDX0C0robPrl9RbOyXHoc9/Dxa0zoGL6cEjvCjLgan1RcZLwqvxvJl4/t3zHragsUp0L47E24tAFUgAAAABqfVFxjHdMkoVmOYaR1etoteuKObS21cc1VbIQAAAAAHYUgdNXR0u3xNdiTr072z2DVec9EQQ/wNo1OAAAAAAM8NSv7ISDPN9E9XNL9vX7h8LuJHWlopUcX39DxsDx23AQQEAQIDADUCAAAAAQAAAAAAAAAAAAAAAAAAAIWWp5Il3Kg312pzVk6Jt61iyFhTbtmkh/ORbj3JUQRbAA==', 'base64']}]}, 'id': 10} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_block_args ( slot , encoding ) return await self . _provider . make_request ( * args )","title":"get_block()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_block_commitment","text":"Fetch the commitment for particular block. Parameters: Name Type Description Default slot int Block, identified by Slot. required Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_block_commitment ( 0 )) { 'jsonrpc' : '2.0' , 'result' : { 'commitment' : [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 497717120 ], 'totalStake' : 497717120 }, 'id' : 1 }} Source code in solana/rpc/async_api.py async def get_block_commitment ( self , slot : int ) -> types . RPCResponse : \"\"\"Fetch the commitment for particular block. Args: slot: Block, identified by Slot. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_block_commitment(0)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'commitment': [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 497717120], 'totalStake': 497717120}, 'id': 1}} \"\"\" args = self . _get_block_commitment_args ( slot ) return await self . _provider . make_request ( * args )","title":"get_block_commitment()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_block_height","text":"Returns the current block height of the node. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_block_height ()) { 'jsonrpc' : '2.0' , 'result' : 1233 , 'id' : 1 } Source code in solana/rpc/async_api.py async def get_block_height ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the current block height of the node. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_block_height()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1233, 'id': 1} \"\"\" args = self . _get_block_height_args ( commitment ) return await self . _provider . make_request ( * args )","title":"get_block_height()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_block_time","text":"Fetch the estimated production time of a block. Parameters: Name Type Description Default slot int Block, identified by Slot. required Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_block_time ( 5 )) { 'jsonrpc' : '2.0' , 'result' : 1598400007 , 'id' : 1 } Source code in solana/rpc/async_api.py async def get_block_time ( self , slot : int ) -> types . RPCResponse : \"\"\"Fetch the estimated production time of a block. Args: slot: Block, identified by Slot. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_block_time(5)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1598400007, 'id': 1} \"\"\" args = self . _get_block_time_args ( slot ) return await self . _provider . make_request ( * args )","title":"get_block_time()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_blocks","text":"Returns a list of confirmed blocks. Parameters: Name Type Description Default start_slot int Start slot, as u64 integer. required end_slot Optional[int] (optional) End slot, as u64 integer. None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_blocks ( 5 , 10 )) { 'jsonrpc' : '2.0' , 'result' : [ 5 , 6 , 7 , 8 , 9 , 10 ], 'id' : 1 } Source code in solana/rpc/async_api.py async def get_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> types . RPCResponse : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_blocks(5, 10)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [5, 6, 7, 8, 9, 10], 'id': 1} \"\"\" args = self . _get_blocks_args ( start_slot , end_slot ) return await self . _provider . make_request ( * args )","title":"get_blocks()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_cluster_nodes","text":"Returns information about all the nodes participating in the cluster. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_cluster_nodes ()) { 'jsonrpc' : '2.0' , 'result' : [{ 'gossip' : '127.0.0.1:8001' , 'pubkey' : 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk' , 'rpc' : '127.0.0.1:8899' , 'tpu' : '127.0.0.1:8003' , 'version' : '1.4.0 5332fcad' }], 'id' : 1 } Source code in solana/rpc/async_api.py async def get_cluster_nodes ( self ) -> types . RPCResponse : \"\"\"Returns information about all the nodes participating in the cluster. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_cluster_nodes()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [{'gossip': '127.0.0.1:8001', 'pubkey': 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk', 'rpc': '127.0.0.1:8899', 'tpu': '127.0.0.1:8003', 'version': '1.4.0 5332fcad'}], 'id': 1} \"\"\" return await self . _provider . make_request ( self . _get_cluster_nodes )","title":"get_cluster_nodes()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_confirmed_block","text":"Returns identity and transaction information about a confirmed block in the ledger. Parameters: Name Type Description Default slot int Slot, as u64 integer. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_confirmed_block ( 1 )) { 'jsonrpc' : '2.0' , 'result' : { 'blockTime' : None , 'blockhash' : '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj' , 'parentSlot' : 0 , 'previousBlockhash' : 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2' , 'rewards' : [], 'transactions' : [{ 'meta' : { 'err' : None , 'fee' : 0 , 'postBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'preBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'status' : { 'Ok' : None }}, 'transaction' : { 'message' : { 'accountKeys' : [ 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk' , 'EKAar3bMQUZvGSonq7vcPF2nPaCYowbnat44FPafW8Po' , 'SysvarS1otHashes111111111111111111111111111' , 'SysvarC1ock11111111111111111111111111111111' , 'Vote111111111111111111111111111111111111111' ], 'header' : { 'numReadonlySignedAccounts' : 0 , 'numReadonlyUnsignedAccounts' : 3 , 'numRequiredSignatures' : 1 }, 'instructions' : [{ 'accounts' : [ 1 , 2 , 3 , 0 ], 'data' : '37u9WtQpcm6ULa3VmTgTKEBCtYMxq84mk82tRvKdFEwj3rALiptAzuMJ1yoVSFAMARMZYp7q' , 'programIdIndex' : 4 }], 'recentBlockhash' : 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2' }, 'signatures' : [ '63jnpMCs7TNnCjnTqUrX7Mvqc5CbJMtVkLxBjPHUQkjXyZrQuZpfhjvzA7A29D9tMqVaiQC3UNP1NeaZKFFHJyQE' ]}}]}, 'id' : 9 } >>> asyncio . run ( solana_client . get_confirmed_block ( 1 , encoding = \"base64\" )) { 'jsonrpc' : '2.0' , 'result' : { 'blockTime' : None , 'blockhash' : '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj' , 'parentSlot' : 0 , 'previousBlockhash' : 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2' , 'rewards' : [], 'transactions' : [{ 'meta' : { 'err' : None , 'fee' : 0 , 'postBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'preBalances' : [ 500000000000 , 26858640 , 1 , 1 , 1 ], 'status' : { 'Ok' : None }}, 'transaction' : [ 'AfxyKHmHIjXWjkyHODGeAbVxmfQWPj1ydS9nF+ynJHo8I1vCPDp2P9Cj5aA6W1CAHEHCqY0B1FDKomCzRo3qrAsBAAMFBQ6QBWfhQF7rG02xhuEsmmrUtz3AUjBtJKkqaHPJEmvFzziDX0C0robPrl9RbOyXHoc9/Dxa0zoGL6cEjvCjLgan1RcZLwqvxvJl4/t3zHragsUp0L47E24tAFUgAAAABqfVFxjHdMkoVmOYaR1etoteuKObS21cc1VbIQAAAAAHYUgdNXR0u3xNdiTr072z2DVec9EQQ/wNo1OAAAAAAM8NSv7ISDPN9E9XNL9vX7h8LuJHWlopUcX39DxsDx23AQQEAQIDADUCAAAAAQAAAAAAAAAAAAAAAAAAAIWWp5Il3Kg312pzVk6Jt61iyFhTbtmkh/ORbj3JUQRbAA==' , 'base64' ]}]}, 'id' : 10 } Source code in solana/rpc/async_api.py async def get_confirmed_block ( self , slot : int , encoding : str = \"json\" , ) -> types . RPCResponse : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_confirmed_block(1)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': {'message': {'accountKeys': ['LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk', 'EKAar3bMQUZvGSonq7vcPF2nPaCYowbnat44FPafW8Po', 'SysvarS1otHashes111111111111111111111111111', 'SysvarC1ock11111111111111111111111111111111', 'Vote111111111111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 3, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [1, 2, 3, 0], 'data': '37u9WtQpcm6ULa3VmTgTKEBCtYMxq84mk82tRvKdFEwj3rALiptAzuMJ1yoVSFAMARMZYp7q', 'programIdIndex': 4}], 'recentBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2'}, 'signatures': ['63jnpMCs7TNnCjnTqUrX7Mvqc5CbJMtVkLxBjPHUQkjXyZrQuZpfhjvzA7A29D9tMqVaiQC3UNP1NeaZKFFHJyQE']}}]}, 'id': 9} >>> asyncio.run(solana_client.get_confirmed_block(1, encoding=\"base64\")) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'blockTime': None, 'blockhash': '39pJzWsPn59k2PuHqhB7xNYBNGFXcFVkXLertHPBV4Tj', 'parentSlot': 0, 'previousBlockhash': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'rewards': [], 'transactions': [{'meta': {'err': None, 'fee': 0, 'postBalances': [500000000000, 26858640, 1, 1, 1], 'preBalances': [500000000000, 26858640, 1, 1, 1], 'status': {'Ok': None}}, 'transaction': ['AfxyKHmHIjXWjkyHODGeAbVxmfQWPj1ydS9nF+ynJHo8I1vCPDp2P9Cj5aA6W1CAHEHCqY0B1FDKomCzRo3qrAsBAAMFBQ6QBWfhQF7rG02xhuEsmmrUtz3AUjBtJKkqaHPJEmvFzziDX0C0robPrl9RbOyXHoc9/Dxa0zoGL6cEjvCjLgan1RcZLwqvxvJl4/t3zHragsUp0L47E24tAFUgAAAABqfVFxjHdMkoVmOYaR1etoteuKObS21cc1VbIQAAAAAHYUgdNXR0u3xNdiTr072z2DVec9EQQ/wNo1OAAAAAAM8NSv7ISDPN9E9XNL9vX7h8LuJHWlopUcX39DxsDx23AQQEAQIDADUCAAAAAQAAAAAAAAAAAAAAAAAAAIWWp5Il3Kg312pzVk6Jt61iyFhTbtmkh/ORbj3JUQRbAA==', 'base64']}]}, 'id': 10} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_confirmed_block_args ( slot , encoding ) return await self . _provider . make_request ( * args )","title":"get_confirmed_block()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_confirmed_blocks","text":"Returns a list of confirmed blocks. Parameters: Name Type Description Default start_slot int Start slot, as u64 integer. required end_slot Optional[int] (optional) End slot, as u64 integer. None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_confirmed_blocks ( 5 , 10 )) { 'jsonrpc' : '2.0' , 'result' : [ 5 , 6 , 7 , 8 , 9 , 10 ], 'id' : 1 } Source code in solana/rpc/async_api.py async def get_confirmed_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> types . RPCResponse : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_confirmed_blocks(5, 10)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [5, 6, 7, 8, 9, 10], 'id': 1} \"\"\" args = self . _get_confirmed_blocks_args ( start_slot , end_slot ) return await self . _provider . make_request ( * args )","title":"get_confirmed_blocks()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_confirmed_signature_for_address2","text":"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Parameters: Name Type Description Default account Union[str, solana.keypair.Keypair, solana.publickey.PublicKey] Account to be queried. required before Optional[str] (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. None until Optional[str] (optional) Search until this transaction signature, if found before limit reached. None limit Optional[int] (optoinal) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). None commitment Optional[Commitment] (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_confirmed_signature_for_address2 ( \"Vote111111111111111111111111111111111111111\" , limit = 1 )) { 'jsonrpc' : '2.0' , 'result' : [{ 'err' : None , 'memo' : None , 'signature' : 'v1BK8XcaPBzAGd7TB1K53pMdi6TBGe5CLCgx8cmZ4Bj63ZNvA6ca2QaxFpBFdvmpoFQ51VorBjifkBGLTDhwpqN' , 'slot' : 4290 }], 'id' : 2 } Source code in solana/rpc/async_api.py async def get_confirmed_signature_for_address2 ( self , account : Union [ str , Keypair , PublicKey ], before : Optional [ str ] = None , until : Optional [ str ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optoinal) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_confirmed_signature_for_address2(\"Vote111111111111111111111111111111111111111\", limit=1)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [{'err': None, 'memo': None, 'signature': 'v1BK8XcaPBzAGd7TB1K53pMdi6TBGe5CLCgx8cmZ4Bj63ZNvA6ca2QaxFpBFdvmpoFQ51VorBjifkBGLTDhwpqN', 'slot': 4290}], 'id': 2} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_confirmed_signature_for_address2_args ( account , before , until , limit , commitment ) return await self . _provider . make_request ( * args )","title":"get_confirmed_signature_for_address2()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_confirmed_transaction","text":"Returns transaction details for a confirmed transaction. Parameters: Name Type Description Default tx_sig str Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the transaction.message.instructions list. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_confirmed_transaction ( \"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\" )) { 'jsonrpc' : '2.0' , 'result' : { 'meta' : { 'err' : None , 'fee' : 5000 , 'postBalances' : [ 498449233720610510 , 1000001001987940 , 1 ], 'preBalances' : [ 498449233721615510 , 1000001000987940 , 1 ], 'status' : { 'Ok' : None }}, 'slot' : 1659335 , 'transaction' : { 'message' : { 'accountKeys' : [ '9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g' , '2KW2XRd9kwqet15Aha2oK3tYvd3nWbTFH1MBiRAv1BE1' , '11111111111111111111111111111111' ], 'header' : { 'numReadonlySignedAccounts' : 0 , 'numReadonlyUnsignedAccounts' : 1 , 'numRequiredSignatures' : 1 }, 'instructions' : [{ 'accounts' : [ 0 , 1 ], 'data' : '3Bxs4Bc3VYuGVB19' , 'programIdIndex' : 2 }], 'recentBlockhash' : 'FwcsKNptGtMLccXAA9YgnivVFK95mKzECLT1DNPi3SDr' }, 'signatures' : [ '3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy' ]}}, 'id' : 4 } Source code in solana/rpc/async_api.py async def get_confirmed_transaction ( self , tx_sig : str , encoding : str = \"json\" ) -> types . RPCResponse : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_confirmed_transaction(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\")) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'meta': {'err': None, 'fee': 5000, 'postBalances': [498449233720610510, 1000001001987940, 1], 'preBalances': [498449233721615510, 1000001000987940, 1], 'status': {'Ok': None}}, 'slot': 1659335, 'transaction': {'message': {'accountKeys': ['9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g', '2KW2XRd9kwqet15Aha2oK3tYvd3nWbTFH1MBiRAv1BE1', '11111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 1, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [0, 1], 'data': '3Bxs4Bc3VYuGVB19', 'programIdIndex': 2}], 'recentBlockhash': 'FwcsKNptGtMLccXAA9YgnivVFK95mKzECLT1DNPi3SDr'}, 'signatures': ['3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy']}}, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_confirmed_transaction_args ( tx_sig , encoding ) return await self . _provider . make_request ( * args )","title":"get_confirmed_transaction()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_epoch_info","text":"Returns information about the current epoch. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_epoch_info ()) { 'jsonrpc' : '2.0' , 'result' : { 'absoluteSlot' : 5150 , 'blockHeight' : 5150 , 'epoch' : 0 , 'slotIndex' : 5150 , 'slotsInEpoch' : 8192 }, 'id' : 5 } Source code in solana/rpc/async_api.py async def get_epoch_info ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns information about the current epoch. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_epoch_info()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'absoluteSlot': 5150, 'blockHeight': 5150, 'epoch': 0, 'slotIndex': 5150, 'slotsInEpoch': 8192}, 'id': 5} \"\"\" args = self . _get_epoch_info_args ( commitment ) return await self . _provider . make_request ( * args )","title":"get_epoch_info()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_epoch_schedule","text":"Returns epoch schedule information from this cluster's genesis config. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_epoch_schedule ()) { 'jsonrpc' : '2.0' , 'result' : { 'firstNormalEpoch' : 0 , 'firstNormalSlot' : 0 , 'leaderScheduleSlotOffset' : 8192 , 'slotsPerEpoch' : 8192 , 'warmup' : False }, 'id' : 6 } Source code in solana/rpc/async_api.py async def get_epoch_schedule ( self ) -> types . RPCResponse : \"\"\"Returns epoch schedule information from this cluster's genesis config. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_epoch_schedule()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'firstNormalEpoch': 0, 'firstNormalSlot': 0, 'leaderScheduleSlotOffset': 8192, 'slotsPerEpoch': 8192, 'warmup': False}, 'id': 6} \"\"\" return await self . _provider . make_request ( self . _get_epoch_schedule )","title":"get_epoch_schedule()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_fee_calculator_for_blockhash","text":"Returns the fee calculator associated with the query blockhash, or null if the blockhash has expired. Parameters: Name Type Description Default blockhash Union[str, Blockhash] Blockhash to query as a Base58 encoded string. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_fee_calculator_for_blockhash ( \"BaQSR194dC4dZaRxATtxYyEwDkk7VgqUY8NVNkub8HFZ\" )) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 7065 }, 'value' : { 'feeCalculator' : { 'lamportsPerSignature' : 5000 }}}, 'id' : 4 } Source code in solana/rpc/async_api.py async def get_fee_calculator_for_blockhash ( self , blockhash : Union [ str , Blockhash ], commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the fee calculator associated with the query blockhash, or null if the blockhash has expired. Args: blockhash: Blockhash to query as a Base58 encoded string. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_fee_calculator_for_blockhash(\"BaQSR194dC4dZaRxATtxYyEwDkk7VgqUY8NVNkub8HFZ\")) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 7065}, 'value': {'feeCalculator': {'lamportsPerSignature': 5000}}}, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_fee_calculator_for_blockhash_args ( blockhash , commitment ) return await self . _provider . make_request ( * args )","title":"get_fee_calculator_for_blockhash()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_fee_for_message","text":"Returns the fee for a message. Parameters: Name Type Description Default message Message Message that the fee is requested for. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solana.keypair import Keypair >>> from solana.system_program import TransferParams , transfer >>> from solana.transaction import Transaction >>> sender , receiver = Keypair . from_seed ( bytes ( PublicKey ( 1 ))), Keypair . from_seed ( bytes ( PublicKey ( 2 ))) >>> txn = Transaction () . add ( transfer ( TransferParams ( ... from_pubkey = sender . public_key , to_pubkey = receiver . public_key , lamports = 1000 ))) >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_fee_for_message ( txn . compile_message ())) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 5068 }, 'value' : 5000 }, 'id' : 4 } Source code in solana/rpc/async_api.py async def get_fee_for_message ( self , message : Message , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the fee for a message. Args: message: Message that the fee is requested for. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solana.keypair import Keypair >>> from solana.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> sender, receiver = Keypair.from_seed(bytes(PublicKey(1))), Keypair.from_seed(bytes(PublicKey(2))) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.public_key, to_pubkey=receiver.public_key, lamports=1000))) >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_fee_for_message(txn.compile_message())) # doctest: +SKIP {'jsonrpc': '2.0', 'result': { 'context': { 'slot': 5068 }, 'value': 5000 }, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long if isinstance ( message , Transaction ): raise TransactionUncompiledError ( \"Transaction uncompiled, please compile to message first.\" ) args = self . _get_fee_for_message_args ( message , commitment ) return await self . _provider . make_request ( * args )","title":"get_fee_for_message()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_fee_rate_governor","text":"Return the fee rate governor information from the root bank. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_fee_rate_governor ()) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 7172 }, 'value' : { 'feeRateGovernor' : { 'burnPercent' : 50 , 'maxLamportsPerSignature' : 100000 , 'minLamportsPerSignature' : 5000 , 'targetLamportsPerSignature' : 10000 , 'targetSignaturesPerSlot' : 20000 }}}, 'id' : 5 } Source code in solana/rpc/async_api.py async def get_fee_rate_governor ( self ) -> types . RPCResponse : \"\"\"Return the fee rate governor information from the root bank. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_fee_rate_governor()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 7172}, 'value': {'feeRateGovernor': {'burnPercent': 50, 'maxLamportsPerSignature': 100000, 'minLamportsPerSignature': 5000, 'targetLamportsPerSignature': 10000, 'targetSignaturesPerSlot': 20000}}}, 'id': 5} \"\"\" return await self . _provider . make_request ( self . _get_fee_rate_governor )","title":"get_fee_rate_governor()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_fees","text":"Returns a recent block hash from the ledger, a fee schedule and the last slot the blockhash will be valid. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_fees ()) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 7727 }, 'value' : { 'blockhash' : 'GGS6AEDqjF5irU6D6VQNherEZ2hckGaeBiVdfSZKg4gd' , 'feeCalculator' : { 'lamportsPerSignature' : 5000 }, 'lastValidSlot' : 8027 }}, 'id' : 1 } Source code in solana/rpc/async_api.py async def get_fees ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns a recent block hash from the ledger, a fee schedule and the last slot the blockhash will be valid. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_fees()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 7727}, 'value': {'blockhash': 'GGS6AEDqjF5irU6D6VQNherEZ2hckGaeBiVdfSZKg4gd', 'feeCalculator': {'lamportsPerSignature': 5000}, 'lastValidSlot': 8027}}, 'id': 1} \"\"\" args = self . _get_fees_args ( commitment ) return await self . _provider . make_request ( * args )","title":"get_fees()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_first_available_block","text":"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_fees ()) { 'jsonrpc' : '2.0' , 'result' : 1 , 'id' : 2 } Source code in solana/rpc/async_api.py async def get_first_available_block ( self ) -> types . RPCResponse : \"\"\"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_fees()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1, 'id': 2} \"\"\" return await self . _provider . make_request ( self . _get_first_available_block )","title":"get_first_available_block()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_genesis_hash","text":"Returns the genesis hash. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_genesis_hash ()) { 'jsonrpc' : '2.0' , 'result' : 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2' , 'id' : 3 } Source code in solana/rpc/async_api.py async def get_genesis_hash ( self ) -> types . RPCResponse : \"\"\"Returns the genesis hash. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_genesis_hash()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'EwF9gtehrrvPUoNticgmiEadAWzn4XeN8bNaNVBkS6S2', 'id': 3} \"\"\" return await self . _provider . make_request ( self . _get_genesis_hash )","title":"get_genesis_hash()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_identity","text":"Returns the identity pubkey for the current node. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_identity ()) { 'jsonrpc' : '2.0' , 'result' : { 'identity' : 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk' }, 'id' : 4 } Source code in solana/rpc/async_api.py async def get_identity ( self ) -> types . RPCResponse : \"\"\"Returns the identity pubkey for the current node. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_identity()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'identity': 'LjvEBM78ufAikBfxqtj4RNiAECUi7Xqtz9k3QM3DzPk'}, 'id': 4} \"\"\" return await self . _provider . make_request ( self . _get_identity )","title":"get_identity()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_inflation_governor","text":"Returns the current inflation governor. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_inflation_governor ()) { 'jsonrpc' : '2.0' , 'result' : { 'foundation' : 0.05 , 'foundationTerm' : 7.0 , 'initial' : 0.15 , 'taper' : 0.15 , 'terminal' : 0.015 }, 'id' : 5 } Source code in solana/rpc/async_api.py async def get_inflation_governor ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the current inflation governor. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_inflation_governor()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'foundation': 0.05, 'foundationTerm': 7.0, 'initial': 0.15, 'taper': 0.15, 'terminal': 0.015}, 'id': 5} \"\"\" args = self . _get_inflation_governor_args ( commitment ) return await self . _provider . make_request ( * args )","title":"get_inflation_governor()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_inflation_rate","text":"Returns the specific inflation values for the current epoch. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_inflation_rate ()) { 'jsonrpc' : '2.0' , 'result' : { 'epoch' : 1 , 'foundation' : 0.007499746885736559 , 'total' : 0.14999493771473116 , 'validator' : 0.1424951908289946 }, 'id' : 1 } Source code in solana/rpc/async_api.py async def get_inflation_rate ( self ) -> types . RPCResponse : \"\"\"Returns the specific inflation values for the current epoch. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_inflation_rate()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'epoch': 1, 'foundation': 0.007499746885736559, 'total': 0.14999493771473116, 'validator': 0.1424951908289946}, 'id': 1} \"\"\" return await self . _provider . make_request ( self . _get_inflation_rate )","title":"get_inflation_rate()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_largest_accounts","text":"Returns the 20 largest accounts, by lamport balance. Parameters: Name Type Description Default filter_opt Optional[str] Filter results by account type; currently supported: circulating|nonCirculating. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_largest_accounts ()) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 8890 }, 'value' : [{ 'address' : '95L7AsBCLRsqghsi6ksZkzjNbs6rqDgHCzKaGZ7bJi75' , 'lamports' : 500000000000000000 }, { 'address' : 'APnSR52EC1eH676m7qTBHUJ1nrGpHYpV7XKPxgRDD8gX' , 'lamports' : 164511033098290000 }, { 'address' : '13LeFbG6m2EP1fqCj9k66fcXsoTHMMtgr7c78AivUrYD' , 'lamports' : 153333632446109120 }, { 'address' : 'GK2zqSsXLA2rwVZk347RYhh6jJpRsCA69FjLW93ZGi3B' , 'lamports' : 57499999036109120 }, { 'address' : '8HVqyX9jebh31Q9Hp8t5sMVJs665979ZeEr3eCfzitUe' , 'lamports' : 30301031036109120 }, { 'address' : 'HbZ5FfmKWNHC7uwk6TF1hVi6TCs7dtYfdjEcuPGgzFAg' , 'lamports' : 14999999036109120 }, { 'address' : '14FUT96s9swbmH7ZjpDvfEDywnAYy9zaNhv4xvezySGu' , 'lamports' : 4999999036109120 }, { 'address' : '9huDUZfxoJ7wGMTffUE7vh1xePqef7gyrLJu9NApncqA' , 'lamports' : 4999999036109120 }, { 'address' : 'C7C8odR8oashR5Feyrq2tJKaXL18id1dSj2zbkDGL2C2' , 'lamports' : 4999999036109120 }, { 'address' : 'AYgECURrvuX6GtFe4tX7aAj87Xc5r5Znx96ntNk1nCv' , 'lamports' : 2499999518054560 }, { 'address' : 'AogcwQ1ubM76EPMhSD5cw1ES4W5econvQCFmBL6nTW1' , 'lamports' : 2499999518054560 }, { 'address' : 'gWgqQ4udVxE3uNxRHEwvftTHwpEmPHAd8JR9UzaHbR2' , 'lamports' : 2499999518054560 }, { 'address' : '3D91zLQPRLamwJfGR5ZYMKQb4C18gsJNaSdmB6b2wLhw' , 'lamports' : 2499999518054560 }, { 'address' : '3bHbMa5VW3np5AJazuacidrN4xPZgwhcXigmjwHmBg5e' , 'lamports' : 2499999518054560 }, { 'address' : '4U3RFq7X5kLG6tZ9kcksFL8oXeGNjtuUN1YfkVKXbs5x' , 'lamports' : 2499999518054560 }, { 'address' : '5cBVGBKY6kBaiTVmsQpxThJ2oqitBYuCAX9Zm2zMuV4y' , 'lamports' : 2499999518054560 }, { 'address' : '8PjJTv657aeN9p5R2WoM6pPSz385chvTTytUWaEjSjkq' , 'lamports' : 2499999518054560 }, { 'address' : 'AHB94zKUASftTdqgdfiDSdnPJHkEFp7zX3yMrcSxABsv' , 'lamports' : 2499999518054560 }, { 'address' : 'Hc36Wh1ZqYGzGAnsJWNT9r2gY3h9n89uDpxZPsmEsiE3' , 'lamports' : 2499999518054560 }, { 'address' : 'GxyRKP2eVKACaSSnso4VLSAjZKmHsFXHWUfS3A5CtiMA' , 'lamports' : 1940147018054560 }]}, 'id' : 2 } Source code in solana/rpc/async_api.py async def get_largest_accounts ( self , filter_opt : Optional [ str ] = None , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the 20 largest accounts, by lamport balance. Args: filter_opt: Filter results by account type; currently supported: circulating|nonCirculating. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_largest_accounts()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 8890}, 'value': [{'address': '95L7AsBCLRsqghsi6ksZkzjNbs6rqDgHCzKaGZ7bJi75', 'lamports': 500000000000000000}, {'address': 'APnSR52EC1eH676m7qTBHUJ1nrGpHYpV7XKPxgRDD8gX', 'lamports': 164511033098290000}, {'address': '13LeFbG6m2EP1fqCj9k66fcXsoTHMMtgr7c78AivUrYD', 'lamports': 153333632446109120}, {'address': 'GK2zqSsXLA2rwVZk347RYhh6jJpRsCA69FjLW93ZGi3B', 'lamports': 57499999036109120}, {'address': '8HVqyX9jebh31Q9Hp8t5sMVJs665979ZeEr3eCfzitUe', 'lamports': 30301031036109120}, {'address': 'HbZ5FfmKWNHC7uwk6TF1hVi6TCs7dtYfdjEcuPGgzFAg', 'lamports': 14999999036109120}, {'address': '14FUT96s9swbmH7ZjpDvfEDywnAYy9zaNhv4xvezySGu', 'lamports': 4999999036109120}, {'address': '9huDUZfxoJ7wGMTffUE7vh1xePqef7gyrLJu9NApncqA', 'lamports': 4999999036109120}, {'address': 'C7C8odR8oashR5Feyrq2tJKaXL18id1dSj2zbkDGL2C2', 'lamports': 4999999036109120}, {'address': 'AYgECURrvuX6GtFe4tX7aAj87Xc5r5Znx96ntNk1nCv', 'lamports': 2499999518054560}, {'address': 'AogcwQ1ubM76EPMhSD5cw1ES4W5econvQCFmBL6nTW1', 'lamports': 2499999518054560}, {'address': 'gWgqQ4udVxE3uNxRHEwvftTHwpEmPHAd8JR9UzaHbR2', 'lamports': 2499999518054560}, {'address': '3D91zLQPRLamwJfGR5ZYMKQb4C18gsJNaSdmB6b2wLhw', 'lamports': 2499999518054560}, {'address': '3bHbMa5VW3np5AJazuacidrN4xPZgwhcXigmjwHmBg5e', 'lamports': 2499999518054560}, {'address': '4U3RFq7X5kLG6tZ9kcksFL8oXeGNjtuUN1YfkVKXbs5x', 'lamports': 2499999518054560}, {'address': '5cBVGBKY6kBaiTVmsQpxThJ2oqitBYuCAX9Zm2zMuV4y', 'lamports': 2499999518054560}, {'address': '8PjJTv657aeN9p5R2WoM6pPSz385chvTTytUWaEjSjkq', 'lamports': 2499999518054560}, {'address': 'AHB94zKUASftTdqgdfiDSdnPJHkEFp7zX3yMrcSxABsv', 'lamports': 2499999518054560}, {'address': 'Hc36Wh1ZqYGzGAnsJWNT9r2gY3h9n89uDpxZPsmEsiE3', 'lamports': 2499999518054560}, {'address': 'GxyRKP2eVKACaSSnso4VLSAjZKmHsFXHWUfS3A5CtiMA', 'lamports': 1940147018054560}]}, 'id': 2} \"\"\" args = self . _get_largest_accounts_args ( filter_opt , commitment ) return await self . _provider . make_request ( * args )","title":"get_largest_accounts()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_latest_blockhash","text":"Returns the latest block hash from the ledger. Response also includes the last valid block height. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_latest_blockhash ()) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 1637 }, 'value' : { 'blockhash' : 'EALChog1mXQ9nEgEUQpWAtmA5UueUZvZiL16ZivmR7eb' , 'lastValidBlockHeight' : 3090 }}, 'id' : 2 } Source code in solana/rpc/async_api.py async def get_latest_blockhash ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the latest block hash from the ledger. Response also includes the last valid block height. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_latest_blockhash()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 1637}, 'value': {'blockhash': 'EALChog1mXQ9nEgEUQpWAtmA5UueUZvZiL16ZivmR7eb', 'lastValidBlockHeight': 3090}}, 'id': 2} \"\"\" args = self . _get_latest_blockhash_args ( commitment ) return await self . _provider . make_request ( * args )","title":"get_latest_blockhash()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_leader_schedule","text":"Returns the leader schedule for an epoch. Parameters: Name Type Description Default epoch Optional[int] Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_leader_schedule ()) { 'jsonrpc' : '2.0' , 'result' : { 'EWj2cuEuVhi7RX81cnAY3TzpyFwnHzzVwvuTyfmxmhs3' : [ 0 , 1 , 2 , 3 , 4 , 5 , ... ]}, 'id' : 6 } Source code in solana/rpc/async_api.py async def get_leader_schedule ( self , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the leader schedule for an epoch. Args: epoch: Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_leader_schedule()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'EWj2cuEuVhi7RX81cnAY3TzpyFwnHzzVwvuTyfmxmhs3': [0, 1, 2, 3, 4, 5, ...]}, 'id': 6} \"\"\" args = self . _get_leader_schedule_args ( epoch , commitment ) return await self . _provider . make_request ( * args )","title":"get_leader_schedule()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_minimum_balance_for_rent_exemption","text":"Returns minimum balance required to make account rent exempt. Parameters: Name Type Description Default usize int Account data length. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_minimum_balance_for_rent_exemption ( 50 )) { 'jsonrpc' : '2.0' , 'result' : 1238880 , 'id' : 7 } Source code in solana/rpc/async_api.py async def get_minimum_balance_for_rent_exemption ( self , usize : int , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns minimum balance required to make account rent exempt. Args: usize: Account data length. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_minimum_balance_for_rent_exemption(50)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1238880, 'id': 7} \"\"\" args = self . _get_minimum_balance_for_rent_exemption_args ( usize , commitment ) return await self . _provider . make_request ( * args )","title":"get_minimum_balance_for_rent_exemption()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_minimum_ledger_slot","text":"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_minimum_ledger_slot ()) { 'jsonrpc' : '2.0' , 'result' : 1234 , 'id' : 1 } Source code in solana/rpc/async_api.py async def get_minimum_ledger_slot ( self ) -> types . RPCResponse : \"\"\"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_minimum_ledger_slot()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 1234, 'id': 1} \"\"\" return await self . _provider . make_request ( self . _minimum_ledger_slot )","title":"get_minimum_ledger_slot()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_multiple_accounts","text":"Returns all the account info for a list of public keys. Parameters: Name Type Description Default pubkeys List[Union[solana.publickey.PublicKey, str]] list of Pubkeys to query, as base-58 encoded string or PublicKey object. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding str (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". \"base58\" is limited to Account data of less than 128 bytes. \"base64\" will return base64 encoded data for Account data of any size. \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). 'base64' data_slice Optional[solana.rpc.types.DataSliceOpts] (optional) Option to limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None Examples: >>> from solana.publickey import PublicKey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> pubkeys = [ PublicKey ( \"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\" ), PublicKey ( \"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\" )] >>> asyncio . run ( solana_client . get_multiple_accounts ( pubkeys )) { \"jsonrpc\" : \"2.0\" , \"result\" : { \"context\" : { \"slot\" : 97531946 }, \"value\" : [ { \"data\" : [ \"\" , \"base64\" ], \"executable\" : False , \"lamports\" : 1 , \"owner\" : \"11111111111111111111111111111111\" , \"rentEpoch\" : 225 , }, { \"data\" : [ \"\" , \"base64\" ], \"executable\" : False , \"lamports\" : 809441127 , \"owner\" : \"11111111111111111111111111111111\" , \"rentEpoch\" : 225 , }, ], }, \"id\" : 1 , } Source code in solana/rpc/async_api.py async def get_multiple_accounts ( self , pubkeys : List [ Union [ PublicKey , str ]], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> types . RPCResponse : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. - \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solana.publickey import PublicKey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> pubkeys = [PublicKey(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), PublicKey(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> asyncio.run(solana_client.get_multiple_accounts(pubkeys)) # doctest: +SKIP { \"jsonrpc\": \"2.0\", \"result\": { \"context\": {\"slot\": 97531946}, \"value\": [ { \"data\": [\"\", \"base64\"], \"executable\": False, \"lamports\": 1, \"owner\": \"11111111111111111111111111111111\", \"rentEpoch\": 225, }, { \"data\": [\"\", \"base64\"], \"executable\": False, \"lamports\": 809441127, \"owner\": \"11111111111111111111111111111111\", \"rentEpoch\": 225, }, ], }, \"id\": 1, } \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_multiple_accounts_args ( pubkeys = pubkeys , commitment = commitment , encoding = encoding , data_slice = data_slice ) return await self . _provider . make_request ( * args )","title":"get_multiple_accounts()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_program_accounts","text":"Returns all accounts owned by the provided program Pubkey. Parameters: Name Type Description Default pubkey Union[str, solana.publickey.PublicKey] Pubkey of program, as base-58 encoded string or PublicKey object. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". 'finalized' encoding Optional[str] (optional) Encoding for the returned Transaction, either jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. None data_slice Optional[solana.rpc.types.DataSliceOpts] (optional) Limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None data_size Optional[int] (optional) Option to compare the program account data length with the provided data size. None memcmp_opts Optional[List[solana.rpc.types.MemcmpOpts]] (optional) Options to compare a provided series of bytes with program account data at a particular offset. None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> memcmp_opts = [ ... types . MemcmpOpts ( offset = 4 , bytes = \"3Mc6vR\" ), ... ] >>> asyncio . run ( solana_client . get_program_accounts ( \"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\" , data_size = 17 , memcmp_opts = memcmp_opts )) { 'jsonrpc' : \"2.0\" , 'result' :[{ 'account' :{ 'data' : '2R9jLfiAQ9bgdcw6h8s44439' , 'executable' : false , 'lamports' : 15298080 , 'owner' : '4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T' , 'rentEpoch' : 28 }, 'pubkey' : 'CxELquR1gPP8wHe33gZ4QxqGB3sZ9RSwsJ2KshVewkFY' }], 'id' : 1 } Source code in solana/rpc/async_api.py async def get_program_accounts ( # pylint: disable=too-many-arguments self , pubkey : Union [ str , PublicKey ], commitment : Optional [ Commitment ] = Finalized , encoding : Optional [ str ] = None , data_slice : Optional [ types . DataSliceOpts ] = None , data_size : Optional [ int ] = None , memcmp_opts : Optional [ List [ types . MemcmpOpts ]] = None , ) -> types . RPCResponse : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for the returned Transaction, either jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. data_size: (optional) Option to compare the program account data length with the provided data size. memcmp_opts: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> memcmp_opts = [ ... types.MemcmpOpts(offset=4, bytes=\"3Mc6vR\"), ... ] >>> asyncio.run(solana_client.get_program_accounts(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\", data_size=17, memcmp_opts=memcmp_opts)) # doctest: +SKIP {'jsonrpc': \"2.0\", 'result' :[{ 'account' :{ 'data' :'2R9jLfiAQ9bgdcw6h8s44439', 'executable' :false, 'lamports' :15298080, 'owner' :'4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T', 'rentEpoch' :28}, 'pubkey' :'CxELquR1gPP8wHe33gZ4QxqGB3sZ9RSwsJ2KshVewkFY'}], 'id' :1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_program_accounts_args ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , data_size = data_size , memcmp_opts = memcmp_opts , ) return await self . _provider . make_request ( * args )","title":"get_program_accounts()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_recent_blockhash","text":"Returns a recent block hash from the ledger. Response also includes a fee schedule that can be used to compute the cost of submitting a transaction using it. Deprecated, please use get_latest_blockhash() instead. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_recent_blockhash ()) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 1637 }, 'value' : { 'blockhash' : 'EALChog1mXQ9nEgEUQpWAtmA5UueUZvZiL16ZivmR7eb' , 'feeCalculator' : { 'lamportsPerSignature' : 5000 }}}, 'id' : 2 } Source code in solana/rpc/async_api.py async def get_recent_blockhash ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns a recent block hash from the ledger. Response also includes a fee schedule that can be used to compute the cost of submitting a transaction using it. Deprecated, please use get_latest_blockhash() instead. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_recent_blockhash()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 1637}, 'value': {'blockhash': 'EALChog1mXQ9nEgEUQpWAtmA5UueUZvZiL16ZivmR7eb', 'feeCalculator': {'lamportsPerSignature': 5000}}}, 'id': 2} \"\"\" args = self . _get_recent_blockhash_args ( commitment ) return await self . _provider . make_request ( * args )","title":"get_recent_blockhash()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_recent_performance_samples","text":"Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Parameters: Name Type Description Default limit Optional[int] Limit (optional) number of samples to return (maximum 720) None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_recent_performance_samples ( 4 )) { 'jsonrpc' : '2.0' , 'result' : [ { 'numSlots' : 126 , 'numTransactions' : 126 , 'samplePeriodSecs' : 60 , 'slot' : 348125 }, { 'numSlots' : 126 , 'numTransactions' : 126 , 'samplePeriodSecs' : 60 , 'slot' : 347999 }, { 'numSlots' : 125 , 'numTransactions' : 125 , 'samplePeriodSecs' : 60 , 'slot' : 347873 }, { 'numSlots' : 125 , 'numTransactions' : 125 , 'samplePeriodSecs' : 60 , 'slot' : 347748 } ], 'id' : 1 } Source code in solana/rpc/async_api.py async def get_recent_performance_samples ( self , limit : Optional [ int ] = None ) -> types . RPCResponse : \"\"\"Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Args: limit: Limit (optional) number of samples to return (maximum 720) Examples: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_recent_performance_samples(4)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [ { 'numSlots': 126, 'numTransactions': 126, 'samplePeriodSecs': 60, 'slot': 348125 }, { 'numSlots': 126, 'numTransactions': 126, 'samplePeriodSecs': 60, 'slot': 347999 }, { 'numSlots': 125, 'numTransactions': 125, 'samplePeriodSecs': 60, 'slot': 347873 }, { 'numSlots': 125, 'numTransactions': 125, 'samplePeriodSecs': 60, 'slot': 347748 } ], 'id': 1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_recent_performance_samples_args ( limit ) return await self . _provider . make_request ( * args )","title":"get_recent_performance_samples()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_signature_statuses","text":"Returns the statuses of a list of signatures. Unless the search_transaction_history configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus MAX_RECENT_BLOCKHASHES rooted slots. Parameters: Name Type Description Default signatures List[Union[str, bytes]] An array of transaction signatures to confirm. required search_transaction_history bool If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. False Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> signatures = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\" , ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\" ] >>> asyncio . run ( solana_client . get_signature_statuses ( signatures )) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 82 }, 'value' : [{ 'slot' : 72 , 'confirmations' : 10 , 'err' : null , 'status' : { 'Ok' : null }}, null ]}, 'id' : 1 } Source code in solana/rpc/async_api.py async def get_signature_statuses ( self , signatures : List [ Union [ str , bytes ]], search_transaction_history : bool = False ) -> types . RPCResponse : \"\"\"Returns the statuses of a list of signatures. Unless the `search_transaction_history` configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus `MAX_RECENT_BLOCKHASHES` rooted slots. Args: signatures: An array of transaction signatures to confirm. search_transaction_history: If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> signatures = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\", ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\"] >>> asyncio.run(solana_client.get_signature_statuses(signatures)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': { 'context': {'slot':82}, 'value': [{ 'slot': 72, 'confirmations': 10, 'err': null, 'status': {'Ok': null}}, null]}, 'id': 1} \"\"\" args = self . _get_signature_statuses_args ( signatures , search_transaction_history ) return await self . _provider . make_request ( * args )","title":"get_signature_statuses()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_signatures_for_address","text":"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Parameters: Name Type Description Default account Union[str, solana.keypair.Keypair, solana.publickey.PublicKey] Account to be queried. required before Optional[str] (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. None until Optional[str] (optional) Search until this transaction signature, if found before limit reached. None limit Optional[int] (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). None commitment Optional[Commitment] (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_signatures_for_address ( \"Vote111111111111111111111111111111111111111\" , limit = 1 )) { 'jsonrpc' : '2.0' , 'result' : [{ 'err' : None , 'memo' : None , 'signature' : 'v1BK8XcaPBzAGd7TB1K53pMdi6TBGe5CLCgx8cmZ4Bj63ZNvA6ca2QaxFpBFdvmpoFQ51VorBjifkBGLTDhwpqN' , 'slot' : 4290 }], 'id' : 2 } Source code in solana/rpc/async_api.py async def get_signatures_for_address ( self , account : Union [ str , Keypair , PublicKey ], before : Optional [ str ] = None , until : Optional [ str ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_signatures_for_address(\"Vote111111111111111111111111111111111111111\", limit=1)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': [{'err': None, 'memo': None, 'signature': 'v1BK8XcaPBzAGd7TB1K53pMdi6TBGe5CLCgx8cmZ4Bj63ZNvA6ca2QaxFpBFdvmpoFQ51VorBjifkBGLTDhwpqN', 'slot': 4290}], 'id': 2} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_signatures_for_address_args ( account , before , until , limit , commitment ) return await self . _provider . make_request ( * args )","title":"get_signatures_for_address()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_slot","text":"Returns the current slot the node is processing. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_slot ()) { 'jsonrpc' : '2.0' , 'result' : 7515 , 'id' : 1 } Source code in solana/rpc/async_api.py async def get_slot ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the current slot the node is processing. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_slot()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 7515, 'id': 1} \"\"\" args = self . _get_slot_args ( commitment ) return await self . _provider . make_request ( * args )","title":"get_slot()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_slot_leader","text":"Returns the current slot leader. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_slot_leader ()) { 'jsonrpc' : '2.0' , 'result' : 'EWj2cuEuVhi7RX81cnAY3TzpyFwnHzzVwvuTyfmxmhs3' , 'id' : 1 } Source code in solana/rpc/async_api.py async def get_slot_leader ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the current slot leader. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_slot_leader()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'EWj2cuEuVhi7RX81cnAY3TzpyFwnHzzVwvuTyfmxmhs3', 'id': 1} \"\"\" args = self . _get_slot_leader_args ( commitment ) return await self . _provider . make_request ( * args )","title":"get_slot_leader()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_stake_activation","text":"Returns epoch activation information for a stake account. Parameters: Name Type Description Default pubkey Union[solana.publickey.PublicKey, str] Pubkey of stake account to query, as base-58 encoded string or PublicKey object. required epoch Optional[int] (optional) Epoch for which to calculate activation details. If parameter not provided, defaults to current epoch. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_stake_activation ()) { 'jsonrpc' : '2.0' , 'result' : { 'active' : 124429280 , 'inactive' : 73287840 , 'state' : 'activating' }, 'id' : 1 }} Source code in solana/rpc/async_api.py async def get_stake_activation ( self , pubkey : Union [ PublicKey , str ], epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns epoch activation information for a stake account. Args: pubkey: Pubkey of stake account to query, as base-58 encoded string or PublicKey object. epoch: (optional) Epoch for which to calculate activation details. If parameter not provided, defaults to current epoch. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_stake_activation()) # doctest: +SKIP {'jsonrpc': '2.0','result': {'active': 124429280, 'inactive': 73287840, 'state': 'activating'}, 'id': 1}} \"\"\" args = self . _get_stake_activation_args ( pubkey , epoch , commitment ) return await self . _provider . make_request ( * args )","title":"get_stake_activation()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_supply","text":"Returns information about the current supply. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_supply ()) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 3846 }, 'value' : { 'circulating' : 683635192454157660 , 'nonCirculating' : 316364808037127120 , 'nonCirculatingAccounts' : [ 'ETfDYz7Cg5p9SDFmdpRerjBN5puKK7xydEBZZGM2V4Ay' , '7cKxv6UznFoWRuJkgw5bWj5rp5PiKTcXZeEaLqyd3Bbm' , 'CV7qh8ZoqeUSTQagosGpkLptXoojf9yCszxkRx1jTD12' , 'FZ9S7X9jMbCaMyJjRfSoBhFyarUMVwvx7HWRe4LnZHsg' , ... ] 'total' : 1000000000491284780 }}, 'id' : 1 } Source code in solana/rpc/async_api.py async def get_supply ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns information about the current supply. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_supply()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'context': {'slot': 3846}, 'value': {'circulating': 683635192454157660, 'nonCirculating': 316364808037127120, 'nonCirculatingAccounts': ['ETfDYz7Cg5p9SDFmdpRerjBN5puKK7xydEBZZGM2V4Ay', '7cKxv6UznFoWRuJkgw5bWj5rp5PiKTcXZeEaLqyd3Bbm', 'CV7qh8ZoqeUSTQagosGpkLptXoojf9yCszxkRx1jTD12', 'FZ9S7X9jMbCaMyJjRfSoBhFyarUMVwvx7HWRe4LnZHsg', ...] 'total': 1000000000491284780}}, 'id': 1} \"\"\" args = self . _get_supply_args ( commitment ) return await self . _provider . make_request ( * args )","title":"get_supply()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_token_account_balance","text":"Returns the token balance of an SPL Token account (UNSTABLE). Parameters: Name Type Description Default pubkey Union[str, solana.publickey.PublicKey] Pubkey of Token account to query, as base-58 encoded string or PublicKey object. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_token_account_balance ( \"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\" )) # noqa: E501 # pylint: disable=line-too-long { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 1114 }, 'value' : { 'uiAmount' : 98.64 , 'amount' : '9864' , 'decimals' : 2 }, 'id' : 1 } Source code in solana/rpc/async_api.py async def get_token_account_balance ( self , pubkey : Union [ str , PublicKey ], commitment : Optional [ Commitment ] = None ): \"\"\"Returns the token balance of an SPL Token account (UNSTABLE). Args: pubkey: Pubkey of Token account to query, as base-58 encoded string or PublicKey object. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_token_account_balance(\"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\")) # noqa: E501 # pylint: disable=line-too-long # doctest: +SKIP {'jsonrpc': '2.0','result': { 'context': {'slot':1114}, 'value': { 'uiAmount': 98.64, 'amount': '9864', 'decimals': 2}, 'id' :1} \"\"\" args = self . _get_token_account_balance_args ( pubkey , commitment ) return await self . _provider . make_request ( * args )","title":"get_token_account_balance()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_token_accounts_by_delegate","text":"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Parameters: Name Type Description Default delegate PublicKey Public key of the delegate owner to query. required opts TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/async_api.py async def get_token_accounts_by_delegate ( self , delegate : PublicKey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" args = self . _get_token_accounts_by_delegate_args ( delegate , opts , commitment ) return await self . __get_token_accounts ( * args )","title":"get_token_accounts_by_delegate()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_token_accounts_by_owner","text":"Returns all SPL Token accounts by token owner (UNSTABLE). Parameters: Name Type Description Default owner PublicKey Public key of the account owner to query. required opts TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/async_api.py async def get_token_accounts_by_owner ( self , owner : PublicKey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> types . RPCResponse : \"\"\"Returns all SPL Token accounts by token owner (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" args = self . _get_token_accounts_by_owner_args ( owner , opts , commitment ) return await self . __get_token_accounts ( * args )","title":"get_token_accounts_by_owner()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_token_largest_accounts","text":"Returns the 20 largest accounts of a particular SPL Token type. Source code in solana/rpc/async_api.py async def get_token_largest_accounts ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the 20 largest accounts of a particular SPL Token type.\"\"\" args = self . _get_token_largest_account_args ( pubkey , commitment ) return await self . _provider . make_request ( * args )","title":"get_token_largest_accounts()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_token_supply","text":"Returns the total supply of an SPL Token type. Source code in solana/rpc/async_api.py async def get_token_supply ( self , pubkey : Union [ PublicKey , str ], commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the total supply of an SPL Token type.\"\"\" args = self . _get_token_supply_args ( pubkey , commitment ) return await self . _provider . make_request ( * args )","title":"get_token_supply()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_transaction","text":"Returns transaction details for a confirmed transaction. Parameters: Name Type Description Default tx_sig str Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the transaction.message.instructions list. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_transaction ( \"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\" )) { 'jsonrpc' : '2.0' , 'result' : { 'meta' : { 'err' : None , 'fee' : 5000 , 'rewards' : [], 'postBalances' : [ 498449233720610510 , 1000001001987940 , 1 ], 'preBalances' : [ 498449233721615510 , 1000001000987940 , 1 ], 'status' : { 'Ok' : None }}, 'slot' : 1659335 , 'transaction' : { 'message' : { 'accountKeys' : [ '9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g' , '2KW2XRd9kwqet15Aha2oK3tYvd3nWbTFH1MBiRAv1BE1' , '11111111111111111111111111111111' ], 'header' : { 'numReadonlySignedAccounts' : 0 , 'numReadonlyUnsignedAccounts' : 1 , 'numRequiredSignatures' : 1 }, 'instructions' : [{ 'accounts' : [ 0 , 1 ], 'data' : '3Bxs4Bc3VYuGVB19' , 'programIdIndex' : 2 }], 'recentBlockhash' : 'FwcsKNptGtMLccXAA9YgnivVFK95mKzECLT1DNPi3SDr' }, 'signatures' : [ '3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy' ]}}, 'id' : 4 } Source code in solana/rpc/async_api.py async def get_transaction ( self , tx_sig : str , encoding : str = \"json\" , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_transaction(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\")) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'meta': {'err': None, 'fee': 5000, 'rewards': [], 'postBalances': [498449233720610510, 1000001001987940, 1], 'preBalances': [498449233721615510, 1000001000987940, 1], 'status': {'Ok': None}}, 'slot': 1659335, 'transaction': {'message': {'accountKeys': ['9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g', '2KW2XRd9kwqet15Aha2oK3tYvd3nWbTFH1MBiRAv1BE1', '11111111111111111111111111111111'], 'header': {'numReadonlySignedAccounts': 0, 'numReadonlyUnsignedAccounts': 1, 'numRequiredSignatures': 1}, 'instructions': [{'accounts': [0, 1], 'data': '3Bxs4Bc3VYuGVB19', 'programIdIndex': 2}], 'recentBlockhash': 'FwcsKNptGtMLccXAA9YgnivVFK95mKzECLT1DNPi3SDr'}, 'signatures': ['3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy']}}, 'id': 4} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _get_transaction_args ( tx_sig , encoding , commitment ) return await self . _provider . make_request ( * args )","title":"get_transaction()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_transaction_count","text":"Returns the current Transaction count from the ledger. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_transaction_count ()) { 'jsonrpc' : '2.0' , 'result' : 4554 , 'id' : 1 } Source code in solana/rpc/async_api.py async def get_transaction_count ( self , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Returns the current Transaction count from the ledger. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_transaction_count()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 4554, 'id': 1} \"\"\" args = self . _get_transaction_count_args ( commitment ) return await self . _provider . make_request ( * args )","title":"get_transaction_count()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_version","text":"Returns the current solana versions running on the node. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_version ()) { 'jsonrpc' : '2.0' , 'result' : { 'solana-core' : '1.4.0 5332fcad' }, 'id' : 1 } Source code in solana/rpc/async_api.py async def get_version ( self ) -> types . RPCResponse : \"\"\"Returns the current solana versions running on the node. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_version()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'solana-core': '1.4.0 5332fcad'}, 'id': 1} \"\"\" return await self . _provider . make_request ( self . _get_version )","title":"get_version()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_vote_accounts","text":"Returns the account info and associated stake for all the voting accounts in the current bank. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . get_vote_accounts ()) { 'jsonrpc' : '2.0' , 'result' : { 'current' : [{ 'activatedStake' : 0 , 'commission' : 100 , 'epochCredits' : [[ 165 , 714644 , 707372 ], [ 166 , 722092 , 714644 ], [ 167 , 730285 , 722092 ], [ 168 , 738476 , 730285 ], ... ] 'epochVoteAccount' : True , 'lastVote' : 1872294 , 'nodePubkey' : 'J7v9ndmcoBuo9to2MnHegLnBkC9x3SAVbQBJo5MMJrN1' , 'rootSlot' : 1872263 , 'votePubkey' : 'HiFjzpR7e5Kv2tdU9jtE4FbH1X8Z9Syia3Uadadx18b5' }, { 'activatedStake' : 500029968930560 , 'commission' : 100 , 'epochCredits' : [[ 165 , 1359689 , 1351498 ], [ 166 , 1367881 , 1359689 ], [ 167 , 1376073 , 1367881 ], [ 168 , 1384265 , 1376073 ], ... ], 'epochVoteAccount' : True , 'lastVote' : 1872295 , 'nodePubkey' : 'dv1LfzJvDF7S1fBKpFgKoKXK5yoSosmkAdfbxBo1GqJ' , 'rootSlot' : 1872264 , 'votePubkey' : '5MMCR4NbTZqjthjLGywmeT66iwE9J9f7kjtxzJjwfUx2' }, { 'activatedStake' : 0 , 'commission' : 100 , 'epochCredits' : [[ 227 , 2751 , 0 ], [ 228 , 7188 , 2751 ]], 'epochVoteAccount' : True , 'lastVote' : 1872295 , 'nodePubkey' : 'H1wDvJ5HJc1SzhHoWtaycpzQpFbsL7g8peaRV3obKShs' , 'rootSlot' : 1872264 , 'votePubkey' : 'DPqpgoLQVU3aq72HEqSMsB9qh4KoXc9fGEpvgEuiwnp6' }], 'delinquent' : []}, 'id' : 1 } Source code in solana/rpc/async_api.py async def get_vote_accounts ( self , commitment : Optional [ Commitment ] = None ): \"\"\"Returns the account info and associated stake for all the voting accounts in the current bank. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.get_vote_accounts()) # doctest: +SKIP {'jsonrpc': '2.0', 'result': {'current': [{'activatedStake': 0, 'commission': 100, 'epochCredits': [[165, 714644, 707372], [166, 722092, 714644], [167, 730285, 722092], [168, 738476, 730285], ...] 'epochVoteAccount': True, 'lastVote': 1872294, 'nodePubkey': 'J7v9ndmcoBuo9to2MnHegLnBkC9x3SAVbQBJo5MMJrN1', 'rootSlot': 1872263, 'votePubkey': 'HiFjzpR7e5Kv2tdU9jtE4FbH1X8Z9Syia3Uadadx18b5'}, {'activatedStake': 500029968930560, 'commission': 100, 'epochCredits': [[165, 1359689, 1351498], [166, 1367881, 1359689], [167, 1376073, 1367881], [168, 1384265, 1376073], ...], 'epochVoteAccount': True, 'lastVote': 1872295, 'nodePubkey': 'dv1LfzJvDF7S1fBKpFgKoKXK5yoSosmkAdfbxBo1GqJ', 'rootSlot': 1872264, 'votePubkey': '5MMCR4NbTZqjthjLGywmeT66iwE9J9f7kjtxzJjwfUx2'}, {'activatedStake': 0, 'commission': 100, 'epochCredits': [[227, 2751, 0], [228, 7188, 2751]], 'epochVoteAccount': True, 'lastVote': 1872295, 'nodePubkey': 'H1wDvJ5HJc1SzhHoWtaycpzQpFbsL7g8peaRV3obKShs', 'rootSlot': 1872264, 'votePubkey': 'DPqpgoLQVU3aq72HEqSMsB9qh4KoXc9fGEpvgEuiwnp6'}], 'delinquent': []}, 'id': 1} \"\"\" args = self . _get_vote_accounts_args ( commitment ) return await self . _provider . make_request ( * args )","title":"get_vote_accounts()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.is_connected","text":"Health check. solana_client = AsyncClient(\"http://localhost:8899\") asyncio.run(solana_client.is_connected()) # doctest: +SKIP True Returns: Type Description bool True if the client is connected. Source code in solana/rpc/async_api.py async def is_connected ( self ) -> bool : \"\"\"Health check. >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.is_connected()) # doctest: +SKIP True Returns: True if the client is connected. \"\"\" return await self . _provider . is_connected ()","title":"is_connected()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.request_airdrop","text":"Requests an airdrop of lamports to a Pubkey. Parameters: Name Type Description Default pubkey Union[solana.publickey.PublicKey, str] Pubkey of account to receive lamports, as base-58 encoded string or public key object. required lamports int Amount of lamports. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solana.publickey import PublicKey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . request_airdrop ( PublicKey ( 1 ), 10000 )) { 'jsonrpc' : '2.0' , 'result' : 'uK6gbLbhnTEgjgmwn36D5BRTRkG4AT8r7Q162TLnJzQnHUZVL9r6BYZVfRttrhmkmno6Fp4VQELzL4AiriCo61U' , 'id' : 1 } Source code in solana/rpc/async_api.py async def request_airdrop ( self , pubkey : Union [ PublicKey , str ], lamports : int , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Requests an airdrop of lamports to a Pubkey. Args: pubkey: Pubkey of account to receive lamports, as base-58 encoded string or public key object. lamports: Amount of lamports. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solana.publickey import PublicKey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.request_airdrop(PublicKey(1), 10000)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'uK6gbLbhnTEgjgmwn36D5BRTRkG4AT8r7Q162TLnJzQnHUZVL9r6BYZVfRttrhmkmno6Fp4VQELzL4AiriCo61U', 'id': 1} \"\"\" args = self . _request_airdrop_args ( pubkey , lamports , commitment ) return await self . _provider . make_request ( * args )","title":"request_airdrop()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.send_raw_transaction","text":"Send a transaction that has already been signed and serialized into the wire format. Parameters: Name Type Description Default txn Union[bytes, str] Fully-signed Transaction object, a fully sign transaction in wire format, or a fully transaction as base-64 encoded string. required opts Optional[solana.rpc.types.TxOpts] (optional) Transaction options. None Before submitting, the following preflight checks are performed (unless disabled with the skip_preflight option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> full_signed_tx_str = ( ... \"AbN5XM+qw+7oOLsFw7goQSLBis7c1kXJFP6OF4w7YmQNhhbQYcyBiybKuOzzhV7McvoRP3Mey9AhXojtwDCdbwoBAAEDE5j2\" ... \"LG0aRXxRumpLXz29L2n8qTIWIY3ImX5Ba9F9k8poq0Z3/7HyiU3QphU8Ix1F7ENq5TrmAUnb4V8y5LhwPwAAAAAAAAAAAAAA\" ... \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAg5YY9wG6fpuieuWYJd1ta7ZtFPbV0OriFRYdcYUaEGkBAgIAAQwCAAAAQEIPAAAAAAA=\" ) >>> asyncio . run ( solana_client . send_raw_transaction ( full_signed_tx_str )) { 'jsonrpc' : '2.0' , 'result' : 'CMwyESM2NE74mghfbvsHJDERF7xMYKshwwm6VgH6GFqXzx8LfBFuP5ruccumfhTguha6seUHPpiHzzHUQXzq2kN' , 'id' : 1 } Source code in solana/rpc/async_api.py async def send_raw_transaction ( self , txn : Union [ bytes , str ], opts : Optional [ types . TxOpts ] = None ) -> types . RPCResponse : \"\"\"Send a transaction that has already been signed and serialized into the wire format. Args: txn: Fully-signed Transaction object, a fully sign transaction in wire format, or a fully transaction as base-64 encoded string. opts: (optional) Transaction options. Before submitting, the following preflight checks are performed (unless disabled with the `skip_preflight` option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> full_signed_tx_str = ( ... \"AbN5XM+qw+7oOLsFw7goQSLBis7c1kXJFP6OF4w7YmQNhhbQYcyBiybKuOzzhV7McvoRP3Mey9AhXojtwDCdbwoBAAEDE5j2\" ... \"LG0aRXxRumpLXz29L2n8qTIWIY3ImX5Ba9F9k8poq0Z3/7HyiU3QphU8Ix1F7ENq5TrmAUnb4V8y5LhwPwAAAAAAAAAAAAAA\" ... \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAg5YY9wG6fpuieuWYJd1ta7ZtFPbV0OriFRYdcYUaEGkBAgIAAQwCAAAAQEIPAAAAAAA=\") >>> asyncio.run(solana_client.send_raw_transaction(full_signed_tx_str)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': 'CMwyESM2NE74mghfbvsHJDERF7xMYKshwwm6VgH6GFqXzx8LfBFuP5ruccumfhTguha6seUHPpiHzzHUQXzq2kN', 'id': 1} \"\"\" # noqa: E501 # pylint: disable=line-too-long opts_to_use = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts args = self . _send_raw_transaction_args ( txn , opts_to_use ) resp = await self . _provider . make_request ( * args ) if opts_to_use . skip_confirmation : return self . _post_send ( resp ) post_send_args = self . _send_raw_transaction_post_send_args ( resp , opts_to_use ) return await self . __post_send_with_confirm ( * post_send_args )","title":"send_raw_transaction()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.send_transaction","text":"Send a transaction. Parameters: Name Type Description Default txn Transaction Transaction object. required signers Keypair Signers to sign the transaction. () opts Optional[solana.rpc.types.TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) Pass a valid recent blockhash here if you want to skip fetching the recent blockhash or relying on the cache. None Examples: >>> from solana.keypair import Keypair >>> from solana.system_program import TransferParams , transfer >>> from solana.transaction import Transaction >>> sender , receiver = Keypair . from_seed ( bytes ( PublicKey ( 1 ))), Keypair . from_seed ( bytes ( PublicKey ( 2 ))) >>> txn = Transaction () . add ( transfer ( TransferParams ( ... from_pubkey = sender . public_key , to_pubkey = receiver . public_key , lamports = 1000 ))) >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . send_transaction ( txn , sender )) { 'jsonrpc' : '2.0' , 'result' : '236zSA5w4NaVuLXXHK1mqiBuBxkNBu84X6cfLBh1v6zjPrLfyECz4zdedofBaZFhs4gdwzSmij9VkaSo2tR5LTgG' , 'id' : 12 } Source code in solana/rpc/async_api.py async def send_transaction ( self , txn : Transaction , * signers : Keypair , opts : Optional [ types . TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> types . RPCResponse : \"\"\"Send a transaction. Args: txn: Transaction object. signers: Signers to sign the transaction. opts: (optional) Transaction options. recent_blockhash: (optional) Pass a valid recent blockhash here if you want to skip fetching the recent blockhash or relying on the cache. Example: >>> from solana.keypair import Keypair >>> from solana.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> sender, receiver = Keypair.from_seed(bytes(PublicKey(1))), Keypair.from_seed(bytes(PublicKey(2))) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.public_key, to_pubkey=receiver.public_key, lamports=1000))) >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.send_transaction(txn, sender)) # doctest: +SKIP {'jsonrpc': '2.0', 'result': '236zSA5w4NaVuLXXHK1mqiBuBxkNBu84X6cfLBh1v6zjPrLfyECz4zdedofBaZFhs4gdwzSmij9VkaSo2tR5LTgG', 'id': 12} \"\"\" last_valid_block_height = None if recent_blockhash is None : if self . blockhash_cache : try : recent_blockhash = self . blockhash_cache . get () except ValueError : blockhash_resp = await self . get_latest_blockhash ( Finalized ) recent_blockhash = self . _process_blockhash_resp ( blockhash_resp , used_immediately = True ) last_valid_block_height = blockhash_resp [ \"result\" ][ \"value\" ][ \"lastValidBlockHeight\" ] else : blockhash_resp = await self . get_latest_blockhash ( Finalized ) recent_blockhash = self . parse_recent_blockhash ( blockhash_resp ) last_valid_block_height = blockhash_resp [ \"result\" ][ \"value\" ][ \"lastValidBlockHeight\" ] txn . recent_blockhash = recent_blockhash txn . sign ( * signers ) opts_to_use = ( types . TxOpts ( preflight_commitment = self . _commitment , last_valid_block_height = last_valid_block_height ) if opts is None else opts ) txn_resp = await self . send_raw_transaction ( txn . serialize (), opts = opts_to_use ) if self . blockhash_cache : blockhash_resp = await self . get_latest_blockhash ( Finalized ) self . _process_blockhash_resp ( blockhash_resp , used_immediately = False ) return txn_resp","title":"send_transaction()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.set_log_filter","text":"Sets the log filter on the validator. Parameters: Name Type Description Default log_filter str The new log filter to use. required Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> asyncio . run ( solana_client . set_log_filter ( \"solana_core=debug\" )) { 'jsonrpc' : '2.0' , 'result' : None , 'id' : 1 } Source code in solana/rpc/async_api.py async def set_log_filter ( self , log_filter : str ) -> types . RPCResponse : \"\"\"Sets the log filter on the validator. Args: log_filter: The new log filter to use. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.set_log_filter(\"solana_core=debug\")) # doctest: +SKIP {'jsonrpc': '2.0', 'result': None, 'id': 1} \"\"\" args = self . _set_log_filter_args ( log_filter ) return await self . _provider . make_request ( * args )","title":"set_log_filter()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.simulate_transaction","text":"Simulate sending a transaction. Parameters: Name Type Description Default txn Union[bytes, str, solana.transaction.Transaction] A Transaction object, a transaction in wire format, or a transaction as base-64 encoded string The transaction must have a valid blockhash, but is not required to be signed. required sig_verify bool If true the transaction signatures will be verified (default: false). False commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> tx_str = ( ... \"4hXTCkRzt9WyecNzV1XPgCDfGAZzQKNxLXgynz5QDuWWPSAZBZSHptvWRL3BjCvzUXRdKvHL2b7yGrRQcWyaqsaBCncVG7BF\" ... \"ggS8w9snUts67BSh3EqKpXLUm5UMHfD7ZBe9GhARjbNQMLJ1QD3Spr6oMTBU6EhdB4RD8CP2xUxr2u3d6fos36PD98XS6oX8\" ... \"TQjLpsMwncs5DAMiD4nNnR8NBfyghGCWvCVifVwvA8B8TJxE1aiyiv2L429BCWfyzAme5sZW8rDb14NeCQHhZbtNqfXhcp2t\" ... ) >>> asyncio . run ( solana_client . simulate_transaction ( tx_str )) { 'jsonrpc' : '2.0' , 'result' : { 'context' : { 'slot' : 218 }, 'value' : { 'err' : null , 'logs' : [ 'BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success' ]}, 'id' : 1 } Source code in solana/rpc/async_api.py async def simulate_transaction ( self , txn : Union [ bytes , str , Transaction ], sig_verify : bool = False , commitment : Optional [ Commitment ] = None ) -> types . RPCResponse : \"\"\"Simulate sending a transaction. Args: txn: A Transaction object, a transaction in wire format, or a transaction as base-64 encoded string The transaction must have a valid blockhash, but is not required to be signed. sig_verify: If true the transaction signatures will be verified (default: false). commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> tx_str = ( ... \"4hXTCkRzt9WyecNzV1XPgCDfGAZzQKNxLXgynz5QDuWWPSAZBZSHptvWRL3BjCvzUXRdKvHL2b7yGrRQcWyaqsaBCncVG7BF\" ... \"ggS8w9snUts67BSh3EqKpXLUm5UMHfD7ZBe9GhARjbNQMLJ1QD3Spr6oMTBU6EhdB4RD8CP2xUxr2u3d6fos36PD98XS6oX8\" ... \"TQjLpsMwncs5DAMiD4nNnR8NBfyghGCWvCVifVwvA8B8TJxE1aiyiv2L429BCWfyzAme5sZW8rDb14NeCQHhZbtNqfXhcp2t\" ... ) >>> asyncio.run(solana_client.simulate_transaction(tx_str)) # doctest: +SKIP {'jsonrpc' :'2.0', 'result': {'context': {'slot': 218}, 'value': { 'err': null, 'logs': ['BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success']}, 'id':1} \"\"\" # noqa: E501 # pylint: disable=line-too-long args = self . _simulate_transaction_args ( txn , sig_verify , commitment ) return await self . _provider . make_request ( * args )","title":"simulate_transaction()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.validator_exit","text":"Request to have the validator exit. Validator must have booted with RPC exit enabled ( --enable-rpc-exit parameter). Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> solana_client . validator_exit () { 'jsonrpc' : '2.0' , 'result' : true , 'id' : 1 } Source code in solana/rpc/async_api.py async def validator_exit ( self ) -> types . RPCResponse : \"\"\"Request to have the validator exit. Validator must have booted with RPC exit enabled (`--enable-rpc-exit` parameter). Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> solana_client.validator_exit() # doctest: +SKIP {'jsonrpc': '2.0', 'result': true, 'id': 1} \"\"\" return await self . _provider . make_request ( self . _validator_exit )","title":"validator_exit()"},{"location":"rpc/commitment/","text":"Commitment solana.rpc.commitment Commitment options. Solana nodes choose which bank state to query based on a commitment requirement set by the client. In descending order of commitment (most finalized to least finalized), clients may specify: Commitment Type for commitment. Confirmed The node will query the most recent block that has been voted on by supermajority of the cluster. It incorporates votes from gossip and replay. It does not count votes on descendants of a block, only direct votes on that block. This confirmation level also upholds \"optimistic confirmation\" guarantees in release 1.3 and onwards. Finalized The node will query the most recent block confirmed by supermajority of the cluster as having reached maximum lockout, meaning the cluster has recognized this block as finalized. Max Deprecated Processed The node will query its most recent block. Note that the block may not be complete. Recent Deprecated Root Deprecated Single Deprecated SingleGossip Deprecated","title":"Commitment"},{"location":"rpc/commitment/#commitment","text":"","title":"Commitment"},{"location":"rpc/commitment/#solana.rpc.commitment","text":"Commitment options. Solana nodes choose which bank state to query based on a commitment requirement set by the client. In descending order of commitment (most finalized to least finalized), clients may specify:","title":"commitment"},{"location":"rpc/commitment/#solana.rpc.commitment.Commitment","text":"Type for commitment.","title":"Commitment"},{"location":"rpc/commitment/#solana.rpc.commitment.Confirmed","text":"The node will query the most recent block that has been voted on by supermajority of the cluster. It incorporates votes from gossip and replay. It does not count votes on descendants of a block, only direct votes on that block. This confirmation level also upholds \"optimistic confirmation\" guarantees in release 1.3 and onwards.","title":"Confirmed"},{"location":"rpc/commitment/#solana.rpc.commitment.Finalized","text":"The node will query the most recent block confirmed by supermajority of the cluster as having reached maximum lockout, meaning the cluster has recognized this block as finalized.","title":"Finalized"},{"location":"rpc/commitment/#solana.rpc.commitment.Max","text":"Deprecated","title":"Max"},{"location":"rpc/commitment/#solana.rpc.commitment.Processed","text":"The node will query its most recent block. Note that the block may not be complete.","title":"Processed"},{"location":"rpc/commitment/#solana.rpc.commitment.Recent","text":"Deprecated","title":"Recent"},{"location":"rpc/commitment/#solana.rpc.commitment.Root","text":"Deprecated","title":"Root"},{"location":"rpc/commitment/#solana.rpc.commitment.Single","text":"Deprecated","title":"Single"},{"location":"rpc/commitment/#solana.rpc.commitment.SingleGossip","text":"Deprecated","title":"SingleGossip"},{"location":"rpc/providers/","text":"RPC Providers solana.rpc.providers special RPC Providers. async_base Async base RPC Provider. AsyncBaseProvider Base class for async RPC providers to implement. Source code in solana/rpc/providers/async_base.py class AsyncBaseProvider : \"\"\"Base class for async RPC providers to implement.\"\"\" async def make_request ( self , method : RPCMethod , * params : Any ) -> RPCResponse : \"\"\"Make a request ot the rpc endpoint.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" ) async def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" ) is_connected ( self ) async Health check. Source code in solana/rpc/providers/async_base.py async def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" ) make_request ( self , method , * params ) async Make a request ot the rpc endpoint. Source code in solana/rpc/providers/async_base.py async def make_request ( self , method : RPCMethod , * params : Any ) -> RPCResponse : \"\"\"Make a request ot the rpc endpoint.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" ) async_http Async HTTP RPC Provider. AsyncHTTPProvider Async HTTP provider to interact with the http rpc endpoint. Source code in solana/rpc/providers/async_http.py class AsyncHTTPProvider ( AsyncBaseProvider , _HTTPProviderCore ): \"\"\"Async HTTP provider to interact with the http rpc endpoint.\"\"\" def __init__ ( self , endpoint : Optional [ str ] = None , timeout : float = DEFAULT_TIMEOUT ): \"\"\"Init AsyncHTTPProvider.\"\"\" super () . __init__ ( endpoint ) self . session = httpx . AsyncClient ( timeout = timeout ) def __str__ ( self ) -> str : \"\"\"String definition for HTTPProvider.\"\"\" return f \"Async HTTP RPC connection { self . endpoint_uri } \" @handle_async_exceptions ( SolanaRpcException , Exception ) async def make_request ( self , method : RPCMethod , * params : Any ) -> RPCResponse : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_request ( method = method , params = params , is_async = True ) raw_response = await self . session . post ( ** request_kwargs ) return self . _after_request ( raw_response = raw_response , method = method ) async def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" try : response = await self . session . get ( self . health_uri ) response . raise_for_status () except ( IOError , httpx . HTTPError ) as err : self . logger . error ( \"Health check failed with error: %s \" , str ( err )) return False return response . status_code == httpx . codes . OK async def __aenter__ ( self ) -> \"AsyncHTTPProvider\" : \"\"\"Use as a context manager.\"\"\" await self . session . __aenter__ () return self async def __aexit__ ( self , _exc_type , _exc , _tb ): \"\"\"Exits the context manager.\"\"\" await self . close () async def close ( self ) -> None : \"\"\"Close session.\"\"\" await self . session . aclose () __init__ ( self , endpoint = None , timeout = 30 ) special Init AsyncHTTPProvider. Source code in solana/rpc/providers/async_http.py def __init__ ( self , endpoint : Optional [ str ] = None , timeout : float = DEFAULT_TIMEOUT ): \"\"\"Init AsyncHTTPProvider.\"\"\" super () . __init__ ( endpoint ) self . session = httpx . AsyncClient ( timeout = timeout ) close ( self ) async Close session. Source code in solana/rpc/providers/async_http.py async def close ( self ) -> None : \"\"\"Close session.\"\"\" await self . session . aclose () is_connected ( self ) async Health check. Source code in solana/rpc/providers/async_http.py async def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" try : response = await self . session . get ( self . health_uri ) response . raise_for_status () except ( IOError , httpx . HTTPError ) as err : self . logger . error ( \"Health check failed with error: %s \" , str ( err )) return False return response . status_code == httpx . codes . OK base Base RPC Provider. BaseProvider Base class for RPC providers to implement. Source code in solana/rpc/providers/base.py class BaseProvider : \"\"\"Base class for RPC providers to implement.\"\"\" def make_request ( self , method : RPCMethod , * params : Any , header_opt : Optional [ dict ] = None ) -> RPCResponse : \"\"\"Make a request ot the rpc endpoint.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" ) def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" ) is_connected ( self ) Health check. Source code in solana/rpc/providers/base.py def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" ) make_request ( self , method , * params , * , header_opt = None ) Make a request ot the rpc endpoint. Source code in solana/rpc/providers/base.py def make_request ( self , method : RPCMethod , * params : Any , header_opt : Optional [ dict ] = None ) -> RPCResponse : \"\"\"Make a request ot the rpc endpoint.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" ) core Helper code for HTTP provider classes. get_default_endpoint () Get the default http rpc endpoint. Source code in solana/rpc/providers/core.py def get_default_endpoint () -> URI : \"\"\"Get the default http rpc endpoint.\"\"\" return URI ( os . environ . get ( \"SOLANARPC_HTTP_URI\" , \"http://localhost:8899\" )) http HTTP RPC Provider. HTTPProvider HTTP provider to interact with the http rpc endpoint. Source code in solana/rpc/providers/http.py class HTTPProvider ( BaseProvider , _HTTPProviderCore ): \"\"\"HTTP provider to interact with the http rpc endpoint.\"\"\" def __str__ ( self ) -> str : \"\"\"String definition for HTTPProvider.\"\"\" return f \"HTTP RPC connection { self . endpoint_uri } \" @handle_exceptions ( SolanaRpcException , requests . exceptions . RequestException ) def make_request ( self , method : RPCMethod , * params : Any , header_opt : Optional [ dict ] = None ) -> Union [ RPCResponse , requests . Response ]: \"\"\"Make a HTTP request to a http rpc endpoint.\"\"\" request_kwargs = self . _before_request ( method = method , params = params , is_async = False ) if header_opt : headers = request_kwargs [ \"headers\" ] data = request_kwargs [ \"data\" ] . encode ( \"utf-8\" ) authorization_values = [] if \"authority_pair\" in header_opt : data_authority_signature = header_opt [ \"authority_pair\" ] . sign ( data ) authorization_values . append ( f \"authority: { header_opt [ 'authority_pair' ] . public_key } =\" f \" { b58encode ( bytes ( data_authority_signature )) . decode ( 'utf-8' ) } \" ) if \"identity_pair\" in header_opt : data_identity_signature = header_opt [ \"identity_pair\" ] . sign ( data ) authorization_values . append ( f \"identity: { header_opt [ 'identity_pair' ] . public_key } =\" f \" { b58encode ( bytes ( data_identity_signature )) . decode ( 'utf-8' ) } \" ) headers . update ({ \"authorization\" : \",\" . join ( authorization_values )}) raw_response = requests . post ( ** request_kwargs , timeout = self . timeout ) if raw_response . status_code == 200 : return self . _after_request ( raw_response = raw_response , method = method ) else : return raw_response def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" try : response = requests . get ( self . health_uri ) response . raise_for_status () except ( IOError , requests . HTTPError ) as err : self . logger . error ( \"Health check failed with error: %s \" , str ( err )) return False return response . ok is_connected ( self ) Health check. Source code in solana/rpc/providers/http.py def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" try : response = requests . get ( self . health_uri ) response . raise_for_status () except ( IOError , requests . HTTPError ) as err : self . logger . error ( \"Health check failed with error: %s \" , str ( err )) return False return response . ok","title":"RPC Providers"},{"location":"rpc/providers/#rpc-providers","text":"","title":"RPC Providers"},{"location":"rpc/providers/#solana.rpc.providers","text":"RPC Providers.","title":"providers"},{"location":"rpc/providers/#solana.rpc.providers.async_base","text":"Async base RPC Provider.","title":"async_base"},{"location":"rpc/providers/#solana.rpc.providers.async_base.AsyncBaseProvider","text":"Base class for async RPC providers to implement. Source code in solana/rpc/providers/async_base.py class AsyncBaseProvider : \"\"\"Base class for async RPC providers to implement.\"\"\" async def make_request ( self , method : RPCMethod , * params : Any ) -> RPCResponse : \"\"\"Make a request ot the rpc endpoint.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" ) async def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" )","title":"AsyncBaseProvider"},{"location":"rpc/providers/#solana.rpc.providers.async_base.AsyncBaseProvider.is_connected","text":"Health check. Source code in solana/rpc/providers/async_base.py async def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" )","title":"is_connected()"},{"location":"rpc/providers/#solana.rpc.providers.async_base.AsyncBaseProvider.make_request","text":"Make a request ot the rpc endpoint. Source code in solana/rpc/providers/async_base.py async def make_request ( self , method : RPCMethod , * params : Any ) -> RPCResponse : \"\"\"Make a request ot the rpc endpoint.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" )","title":"make_request()"},{"location":"rpc/providers/#solana.rpc.providers.async_http","text":"Async HTTP RPC Provider.","title":"async_http"},{"location":"rpc/providers/#solana.rpc.providers.async_http.AsyncHTTPProvider","text":"Async HTTP provider to interact with the http rpc endpoint. Source code in solana/rpc/providers/async_http.py class AsyncHTTPProvider ( AsyncBaseProvider , _HTTPProviderCore ): \"\"\"Async HTTP provider to interact with the http rpc endpoint.\"\"\" def __init__ ( self , endpoint : Optional [ str ] = None , timeout : float = DEFAULT_TIMEOUT ): \"\"\"Init AsyncHTTPProvider.\"\"\" super () . __init__ ( endpoint ) self . session = httpx . AsyncClient ( timeout = timeout ) def __str__ ( self ) -> str : \"\"\"String definition for HTTPProvider.\"\"\" return f \"Async HTTP RPC connection { self . endpoint_uri } \" @handle_async_exceptions ( SolanaRpcException , Exception ) async def make_request ( self , method : RPCMethod , * params : Any ) -> RPCResponse : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_request ( method = method , params = params , is_async = True ) raw_response = await self . session . post ( ** request_kwargs ) return self . _after_request ( raw_response = raw_response , method = method ) async def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" try : response = await self . session . get ( self . health_uri ) response . raise_for_status () except ( IOError , httpx . HTTPError ) as err : self . logger . error ( \"Health check failed with error: %s \" , str ( err )) return False return response . status_code == httpx . codes . OK async def __aenter__ ( self ) -> \"AsyncHTTPProvider\" : \"\"\"Use as a context manager.\"\"\" await self . session . __aenter__ () return self async def __aexit__ ( self , _exc_type , _exc , _tb ): \"\"\"Exits the context manager.\"\"\" await self . close () async def close ( self ) -> None : \"\"\"Close session.\"\"\" await self . session . aclose ()","title":"AsyncHTTPProvider"},{"location":"rpc/providers/#solana.rpc.providers.async_http.AsyncHTTPProvider.__init__","text":"Init AsyncHTTPProvider. Source code in solana/rpc/providers/async_http.py def __init__ ( self , endpoint : Optional [ str ] = None , timeout : float = DEFAULT_TIMEOUT ): \"\"\"Init AsyncHTTPProvider.\"\"\" super () . __init__ ( endpoint ) self . session = httpx . AsyncClient ( timeout = timeout )","title":"__init__()"},{"location":"rpc/providers/#solana.rpc.providers.async_http.AsyncHTTPProvider.close","text":"Close session. Source code in solana/rpc/providers/async_http.py async def close ( self ) -> None : \"\"\"Close session.\"\"\" await self . session . aclose ()","title":"close()"},{"location":"rpc/providers/#solana.rpc.providers.async_http.AsyncHTTPProvider.is_connected","text":"Health check. Source code in solana/rpc/providers/async_http.py async def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" try : response = await self . session . get ( self . health_uri ) response . raise_for_status () except ( IOError , httpx . HTTPError ) as err : self . logger . error ( \"Health check failed with error: %s \" , str ( err )) return False return response . status_code == httpx . codes . OK","title":"is_connected()"},{"location":"rpc/providers/#solana.rpc.providers.base","text":"Base RPC Provider.","title":"base"},{"location":"rpc/providers/#solana.rpc.providers.base.BaseProvider","text":"Base class for RPC providers to implement. Source code in solana/rpc/providers/base.py class BaseProvider : \"\"\"Base class for RPC providers to implement.\"\"\" def make_request ( self , method : RPCMethod , * params : Any , header_opt : Optional [ dict ] = None ) -> RPCResponse : \"\"\"Make a request ot the rpc endpoint.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" ) def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" )","title":"BaseProvider"},{"location":"rpc/providers/#solana.rpc.providers.base.BaseProvider.is_connected","text":"Health check. Source code in solana/rpc/providers/base.py def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" )","title":"is_connected()"},{"location":"rpc/providers/#solana.rpc.providers.base.BaseProvider.make_request","text":"Make a request ot the rpc endpoint. Source code in solana/rpc/providers/base.py def make_request ( self , method : RPCMethod , * params : Any , header_opt : Optional [ dict ] = None ) -> RPCResponse : \"\"\"Make a request ot the rpc endpoint.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" )","title":"make_request()"},{"location":"rpc/providers/#solana.rpc.providers.core","text":"Helper code for HTTP provider classes.","title":"core"},{"location":"rpc/providers/#solana.rpc.providers.core.get_default_endpoint","text":"Get the default http rpc endpoint. Source code in solana/rpc/providers/core.py def get_default_endpoint () -> URI : \"\"\"Get the default http rpc endpoint.\"\"\" return URI ( os . environ . get ( \"SOLANARPC_HTTP_URI\" , \"http://localhost:8899\" ))","title":"get_default_endpoint()"},{"location":"rpc/providers/#solana.rpc.providers.http","text":"HTTP RPC Provider.","title":"http"},{"location":"rpc/providers/#solana.rpc.providers.http.HTTPProvider","text":"HTTP provider to interact with the http rpc endpoint. Source code in solana/rpc/providers/http.py class HTTPProvider ( BaseProvider , _HTTPProviderCore ): \"\"\"HTTP provider to interact with the http rpc endpoint.\"\"\" def __str__ ( self ) -> str : \"\"\"String definition for HTTPProvider.\"\"\" return f \"HTTP RPC connection { self . endpoint_uri } \" @handle_exceptions ( SolanaRpcException , requests . exceptions . RequestException ) def make_request ( self , method : RPCMethod , * params : Any , header_opt : Optional [ dict ] = None ) -> Union [ RPCResponse , requests . Response ]: \"\"\"Make a HTTP request to a http rpc endpoint.\"\"\" request_kwargs = self . _before_request ( method = method , params = params , is_async = False ) if header_opt : headers = request_kwargs [ \"headers\" ] data = request_kwargs [ \"data\" ] . encode ( \"utf-8\" ) authorization_values = [] if \"authority_pair\" in header_opt : data_authority_signature = header_opt [ \"authority_pair\" ] . sign ( data ) authorization_values . append ( f \"authority: { header_opt [ 'authority_pair' ] . public_key } =\" f \" { b58encode ( bytes ( data_authority_signature )) . decode ( 'utf-8' ) } \" ) if \"identity_pair\" in header_opt : data_identity_signature = header_opt [ \"identity_pair\" ] . sign ( data ) authorization_values . append ( f \"identity: { header_opt [ 'identity_pair' ] . public_key } =\" f \" { b58encode ( bytes ( data_identity_signature )) . decode ( 'utf-8' ) } \" ) headers . update ({ \"authorization\" : \",\" . join ( authorization_values )}) raw_response = requests . post ( ** request_kwargs , timeout = self . timeout ) if raw_response . status_code == 200 : return self . _after_request ( raw_response = raw_response , method = method ) else : return raw_response def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" try : response = requests . get ( self . health_uri ) response . raise_for_status () except ( IOError , requests . HTTPError ) as err : self . logger . error ( \"Health check failed with error: %s \" , str ( err )) return False return response . ok","title":"HTTPProvider"},{"location":"rpc/providers/#solana.rpc.providers.http.HTTPProvider.is_connected","text":"Health check. Source code in solana/rpc/providers/http.py def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" try : response = requests . get ( self . health_uri ) response . raise_for_status () except ( IOError , requests . HTTPError ) as err : self . logger . error ( \"Health check failed with error: %s \" , str ( err )) return False return response . ok","title":"is_connected()"},{"location":"rpc/types/","text":"RPC Types solana.rpc.types RPC types. RPCMethod Type for RPC method. URI Type for endpoint URI. DataSliceOpts Option to limit the returned account data, only available for \"base58\" or \"base64\" encoding. Source code in solana/rpc/types.py class DataSliceOpts ( NamedTuple ): \"\"\"Option to limit the returned account data, only available for \"base58\" or \"base64\" encoding.\"\"\" offset : int \"\"\"Limit the returned account data using the provided offset: <usize>.\"\"\" length : int \"\"\"Limit the returned account data using the provided length: <usize>.\"\"\" length : int Limit the returned account data using the provided length: . offset : int Limit the returned account data using the provided offset: . MemcmpOpts Option to compare a provided series of bytes with program account data at a particular offset. Source code in solana/rpc/types.py class MemcmpOpts ( NamedTuple ): \"\"\"Option to compare a provided series of bytes with program account data at a particular offset.\"\"\" offset : int \"\"\"Offset into program account data to start comparison: <usize>.\"\"\" bytes : str \"\"\"Data to match, as base-58 encoded string: <string>.\"\"\" bytes : str Data to match, as base-58 encoded string: . offset : int Offset into program account data to start comparison: . RPCError RPC error. Source code in solana/rpc/types.py class RPCError ( TypedDict ): \"\"\"RPC error.\"\"\" code : int \"\"\"HTTP status code.\"\"\" message : str \"\"\"Error message.\"\"\" RPCResponse RPC Response. Source code in solana/rpc/types.py class RPCResponse ( TypedDict , total = False ): \"\"\"RPC Response.\"\"\" error : Union [ RPCError , str ] \"\"\"RPC error.\"\"\" id : int \"\"\"Request ID.\"\"\" jsonrpc : Literal [ \"2.0\" ] \"\"\"Protocol.\"\"\" result : Any \"\"\"Response results.\"\"\" TokenAccountOpts Options when querying token accounts. Provide one of mint or program_id. Source code in solana/rpc/types.py class TokenAccountOpts ( NamedTuple ): \"\"\"Options when querying token accounts. Provide one of mint or program_id. \"\"\" mint : Optional [ PublicKey ] = None \"\"\"Public key of the specific token Mint to limit accounts to.\"\"\" program_id : Optional [ PublicKey ] = None \"\"\"Public key of the Token program ID that owns the accounts.\"\"\" encoding : str = \"base64\" \"\"\"Encoding for Account data, either \"base58\" (slow), \"base64\" or jsonParsed\". Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" data_slice : Optional [ DataSliceOpts ] = None \"\"\"Option to limit the returned account data, only available for \"base58\" or \"base64\" encoding.\"\"\" min_context_slot : Optional [ int ] = None \"\"\"Set the minimum slot that the request can be evaluated at. \"\"\" data_slice : Optional [ solana . rpc . types . DataSliceOpts ] Option to limit the returned account data, only available for \"base58\" or \"base64\" encoding. encoding : str Encoding for Account data, either \"base58\" (slow), \"base64\" or jsonParsed\". Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. min_context_slot : Optional [ int ] Set the minimum slot that the request can be evaluated at. mint : Optional [ solana . publickey . PublicKey ] Public key of the specific token Mint to limit accounts to. program_id : Optional [ solana . publickey . PublicKey ] Public key of the Token program ID that owns the accounts. TxOpts Options to specify when broadcasting a transaction. Source code in solana/rpc/types.py class TxOpts ( NamedTuple ): \"\"\"Options to specify when broadcasting a transaction.\"\"\" skip_confirmation : bool = True \"\"\"If false, `send_transaction` will try to confirm that the transaction was successfully broadcasted. When confirming a transaction, `send_transaction` will block for a maximum of 30 seconds. Wrap the call inside a thread to make it asynchronous. \"\"\" skip_preflight : bool = False \"\"\"If true, skip the preflight transaction checks.\"\"\" preflight_commitment : Commitment = Finalized \"\"\"Commitment level to use for preflight.\"\"\" max_retries : Optional [ int ] = None \"\"\"Maximum number of times for the RPC node to retry sending the transaction to the leader. If this parameter not provided, the RPC node will retry the transaction until it is finalized or until the blockhash expires. \"\"\" last_valid_block_height : Optional [ int ] = None \"\"\"Pass the latest valid block height here, to be consumed by confirm_transaction. Valid only if skip_confirmation is False. \"\"\" min_context_slot : Optional [ int ] = None \"\"\"Set the minimum slot that the request can be evaluated at. \"\"\" last_valid_block_height : Optional [ int ] Pass the latest valid block height here, to be consumed by confirm_transaction. Valid only if skip_confirmation is False. max_retries : Optional [ int ] Maximum number of times for the RPC node to retry sending the transaction to the leader. If this parameter not provided, the RPC node will retry the transaction until it is finalized or until the blockhash expires. min_context_slot : Optional [ int ] Set the minimum slot that the request can be evaluated at. preflight_commitment : < function NewType .< locals >. new_type at 0x7f7a949b1700 > Commitment level to use for preflight. skip_confirmation : bool If false, send_transaction will try to confirm that the transaction was successfully broadcasted. When confirming a transaction, send_transaction will block for a maximum of 30 seconds. Wrap the call inside a thread to make it asynchronous. skip_preflight : bool If true, skip the preflight transaction checks.","title":"RPC Types"},{"location":"rpc/types/#rpc-types","text":"","title":"RPC Types"},{"location":"rpc/types/#solana.rpc.types","text":"RPC types.","title":"types"},{"location":"rpc/types/#solana.rpc.types.RPCMethod","text":"Type for RPC method.","title":"RPCMethod"},{"location":"rpc/types/#solana.rpc.types.URI","text":"Type for endpoint URI.","title":"URI"},{"location":"rpc/types/#solana.rpc.types.DataSliceOpts","text":"Option to limit the returned account data, only available for \"base58\" or \"base64\" encoding. Source code in solana/rpc/types.py class DataSliceOpts ( NamedTuple ): \"\"\"Option to limit the returned account data, only available for \"base58\" or \"base64\" encoding.\"\"\" offset : int \"\"\"Limit the returned account data using the provided offset: <usize>.\"\"\" length : int \"\"\"Limit the returned account data using the provided length: <usize>.\"\"\"","title":"DataSliceOpts"},{"location":"rpc/types/#solana.rpc.types.DataSliceOpts.length","text":"Limit the returned account data using the provided length: .","title":"length"},{"location":"rpc/types/#solana.rpc.types.DataSliceOpts.offset","text":"Limit the returned account data using the provided offset: .","title":"offset"},{"location":"rpc/types/#solana.rpc.types.MemcmpOpts","text":"Option to compare a provided series of bytes with program account data at a particular offset. Source code in solana/rpc/types.py class MemcmpOpts ( NamedTuple ): \"\"\"Option to compare a provided series of bytes with program account data at a particular offset.\"\"\" offset : int \"\"\"Offset into program account data to start comparison: <usize>.\"\"\" bytes : str \"\"\"Data to match, as base-58 encoded string: <string>.\"\"\"","title":"MemcmpOpts"},{"location":"rpc/types/#solana.rpc.types.MemcmpOpts.bytes","text":"Data to match, as base-58 encoded string: .","title":"bytes"},{"location":"rpc/types/#solana.rpc.types.MemcmpOpts.offset","text":"Offset into program account data to start comparison: .","title":"offset"},{"location":"rpc/types/#solana.rpc.types.RPCError","text":"RPC error. Source code in solana/rpc/types.py class RPCError ( TypedDict ): \"\"\"RPC error.\"\"\" code : int \"\"\"HTTP status code.\"\"\" message : str \"\"\"Error message.\"\"\"","title":"RPCError"},{"location":"rpc/types/#solana.rpc.types.RPCResponse","text":"RPC Response. Source code in solana/rpc/types.py class RPCResponse ( TypedDict , total = False ): \"\"\"RPC Response.\"\"\" error : Union [ RPCError , str ] \"\"\"RPC error.\"\"\" id : int \"\"\"Request ID.\"\"\" jsonrpc : Literal [ \"2.0\" ] \"\"\"Protocol.\"\"\" result : Any \"\"\"Response results.\"\"\"","title":"RPCResponse"},{"location":"rpc/types/#solana.rpc.types.TokenAccountOpts","text":"Options when querying token accounts. Provide one of mint or program_id. Source code in solana/rpc/types.py class TokenAccountOpts ( NamedTuple ): \"\"\"Options when querying token accounts. Provide one of mint or program_id. \"\"\" mint : Optional [ PublicKey ] = None \"\"\"Public key of the specific token Mint to limit accounts to.\"\"\" program_id : Optional [ PublicKey ] = None \"\"\"Public key of the Token program ID that owns the accounts.\"\"\" encoding : str = \"base64\" \"\"\"Encoding for Account data, either \"base58\" (slow), \"base64\" or jsonParsed\". Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" data_slice : Optional [ DataSliceOpts ] = None \"\"\"Option to limit the returned account data, only available for \"base58\" or \"base64\" encoding.\"\"\" min_context_slot : Optional [ int ] = None \"\"\"Set the minimum slot that the request can be evaluated at. \"\"\"","title":"TokenAccountOpts"},{"location":"rpc/types/#solana.rpc.types.TokenAccountOpts.data_slice","text":"Option to limit the returned account data, only available for \"base58\" or \"base64\" encoding.","title":"data_slice"},{"location":"rpc/types/#solana.rpc.types.TokenAccountOpts.encoding","text":"Encoding for Account data, either \"base58\" (slow), \"base64\" or jsonParsed\". Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE.","title":"encoding"},{"location":"rpc/types/#solana.rpc.types.TokenAccountOpts.min_context_slot","text":"Set the minimum slot that the request can be evaluated at.","title":"min_context_slot"},{"location":"rpc/types/#solana.rpc.types.TokenAccountOpts.mint","text":"Public key of the specific token Mint to limit accounts to.","title":"mint"},{"location":"rpc/types/#solana.rpc.types.TokenAccountOpts.program_id","text":"Public key of the Token program ID that owns the accounts.","title":"program_id"},{"location":"rpc/types/#solana.rpc.types.TxOpts","text":"Options to specify when broadcasting a transaction. Source code in solana/rpc/types.py class TxOpts ( NamedTuple ): \"\"\"Options to specify when broadcasting a transaction.\"\"\" skip_confirmation : bool = True \"\"\"If false, `send_transaction` will try to confirm that the transaction was successfully broadcasted. When confirming a transaction, `send_transaction` will block for a maximum of 30 seconds. Wrap the call inside a thread to make it asynchronous. \"\"\" skip_preflight : bool = False \"\"\"If true, skip the preflight transaction checks.\"\"\" preflight_commitment : Commitment = Finalized \"\"\"Commitment level to use for preflight.\"\"\" max_retries : Optional [ int ] = None \"\"\"Maximum number of times for the RPC node to retry sending the transaction to the leader. If this parameter not provided, the RPC node will retry the transaction until it is finalized or until the blockhash expires. \"\"\" last_valid_block_height : Optional [ int ] = None \"\"\"Pass the latest valid block height here, to be consumed by confirm_transaction. Valid only if skip_confirmation is False. \"\"\" min_context_slot : Optional [ int ] = None \"\"\"Set the minimum slot that the request can be evaluated at. \"\"\"","title":"TxOpts"},{"location":"rpc/types/#solana.rpc.types.TxOpts.last_valid_block_height","text":"Pass the latest valid block height here, to be consumed by confirm_transaction. Valid only if skip_confirmation is False.","title":"last_valid_block_height"},{"location":"rpc/types/#solana.rpc.types.TxOpts.max_retries","text":"Maximum number of times for the RPC node to retry sending the transaction to the leader. If this parameter not provided, the RPC node will retry the transaction until it is finalized or until the blockhash expires.","title":"max_retries"},{"location":"rpc/types/#solana.rpc.types.TxOpts.min_context_slot","text":"Set the minimum slot that the request can be evaluated at.","title":"min_context_slot"},{"location":"rpc/types/#solana.rpc.types.TxOpts.preflight_commitment","text":"Commitment level to use for preflight.","title":"preflight_commitment"},{"location":"rpc/types/#solana.rpc.types.TxOpts.skip_confirmation","text":"If false, send_transaction will try to confirm that the transaction was successfully broadcasted. When confirming a transaction, send_transaction will block for a maximum of 30 seconds. Wrap the call inside a thread to make it asynchronous.","title":"skip_confirmation"},{"location":"rpc/types/#solana.rpc.types.TxOpts.skip_preflight","text":"If true, skip the preflight transaction checks.","title":"skip_preflight"},{"location":"rpc/websocket/","text":"Websocket Client solana.rpc.websocket_api This module contains code for interacting with the RPC Websocket endpoint. SolanaWsClientProtocol Subclass of websockets.WebSocketClientProtocol tailored for Solana RPC websockets. Source code in solana/rpc/websocket_api.py class SolanaWsClientProtocol ( WebSocketClientProtocol ): \"\"\"Subclass of `websockets.WebSocketClientProtocol` tailored for Solana RPC websockets.\"\"\" def __init__ ( self , * args , ** kwargs ): \"\"\"Init. Args and kwargs are passed to `websockets.WebSocketClientProtocol`.\"\"\" super () . __init__ ( * args , ** kwargs ) self . subscriptions = {} self . sent_subscriptions = {} self . failed_subscriptions = {} async def _send ( self , data : Union [ Dict [ str , Any ], list ]) -> None : as_json_str = dumps ( data ) await super () . send ( as_json_str ) if isinstance ( data , dict ): self . sent_subscriptions [ data [ \"id\" ]] = data else : for req in data : self . sent_subscriptions [ req [ \"id\" ]] = req async def send_data ( self , message : Union [ RequestBody , List [ RequestBody ]]) -> None : \"\"\"Send a subscribe/unsubscribe request or list of requests. Basically `.send` from `websockets` with extra parsing. Args: message: The request(s) to send. \"\"\" to_send = message . to_request () if isinstance ( message , RequestBody ) else [ msg . to_request () for msg in message ] await self . _send ( to_send ) # type: ignore async def recv ( # type: ignore self , ) -> Union [ List [ Union [ SubscriptionNotification , Error , Ok ]], SubscriptionNotification , Error , Ok ]: \"\"\"Receive the next message. Basically `.recv` from `websockets` with extra parsing. \"\"\" data = await super () . recv () as_json = loads ( data ) if isinstance ( as_json , list ): return [ self . _process_rpc_response ( item ) for item in as_json ] return self . _process_rpc_response ( as_json ) async def account_subscribe ( self , pubkey : PublicKey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None ) -> None : \"\"\"Subscribe to an account to receive notifications when the lamports or data change. Args: pubkey: Account pubkey. commitment: Commitment level. encoding: Encoding to use. \"\"\" req = AccountSubscribe ( pubkey , commitment , encoding ) await self . send_data ( req ) async def account_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from account notifications. Args: subscription: ID of subscription to cancel. \"\"\" req = AccountUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def logs_subscribe ( self , filter_ : Union [ str , MentionsFilter ] = LogsSubscribeFilter . ALL , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , ) -> None : \"\"\"Subscribe to transaction logging. Args: filter_: filter criteria for the logs. Use `LogsSubscribeFilter` to build the filter. commitment: The commitment level to use. encoding: The encoding to use. \"\"\" req = LogsSubscribe ( filter_ , commitment , encoding ) await self . send_data ( req ) async def logs_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from transaction logging. Args: subscription: ID of subscription to cancel. \"\"\" req = LogsUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def program_subscribe ( # pylint: disable=too-many-arguments self , program_id : PublicKey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , data_size : Optional [ int ] = None , memcmp_opts : Optional [ List [ types . MemcmpOpts ]] = None , ) -> None : \"\"\"Receive notifications when the lamports or data for a given account owned by the program changes. Args: program_id: The program ID. commitment: Commitment level to use. encoding: Encoding to use. data_size: Data size filter. memcmp_opts: memcmp options. \"\"\" # noqa: E501 req = ProgramSubscribe ( program_id , commitment , encoding , data_size , memcmp_opts ) await self . send_data ( req ) async def program_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from program account notifications. Args: subscription: ID of subscription to cancel. \"\"\" req = ProgramUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def signature_subscribe ( self , signature : TransactionSignature , commitment : Optional [ Commitment ] = None , ) -> None : \"\"\"Subscribe to a transaction signature to receive notification when the transaction is confirmed. Args: signature: The transaction signature to subscribe to. commitment: Commitment level. \"\"\" req = SignatureSubscribe ( signature , commitment ) await self . send_data ( req ) async def signature_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from signature notifications. Args: subscription: ID of subscription to cancel. \"\"\" req = SignatureUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def slot_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a slot is processed by the validator.\"\"\" req = SlotSubscribe () await self . send_data ( req ) async def slot_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from slot notifications. Args: subscription: ID of subscription to cancel. \"\"\" req = SlotUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def slots_updates_subscribe ( self ) -> None : \"\"\"Subscribe to receive a notification from the validator on a variety of updates on every slot.\"\"\" req = SlotsUpdatesSubscribe () await self . send_data ( req ) async def slots_updates_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from slot update notifications. Args: subscription: ID of subscription to cancel. \"\"\" req = SlotsUpdatesUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def root_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a new root is set by the validator.\"\"\" req = RootSubscribe () await self . send_data ( req ) async def root_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from root notifications. Args: subscription: ID of subscription to cancel. \"\"\" req = RootUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def vote_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a new vote is observed in gossip.\"\"\" req = VoteSubscribe () await self . send_data ( req ) async def vote_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from vote notifications. Args: subscription: ID of subscription to cancel. \"\"\" req = VoteUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ] def _process_rpc_response ( self , data : dict ) -> Union [ SubscriptionNotification , Error , Ok ]: parsed = _parse_rpc_response ( data ) if isinstance ( parsed , Error ): subscription = self . sent_subscriptions [ parsed . id ] self . failed_subscriptions [ parsed . id ] = subscription raise SubscriptionError ( parsed , subscription ) parsed_result = parsed . result if type ( parsed_result ) is int and type ( parsed ) is Ok : # pylint: disable=unidiomatic-typecheck self . subscriptions [ parsed_result ] = self . sent_subscriptions [ parsed . id ] return parsed __init__ ( self , * args , ** kwargs ) special Init. Args and kwargs are passed to websockets.WebSocketClientProtocol . Source code in solana/rpc/websocket_api.py def __init__ ( self , * args , ** kwargs ): \"\"\"Init. Args and kwargs are passed to `websockets.WebSocketClientProtocol`.\"\"\" super () . __init__ ( * args , ** kwargs ) self . subscriptions = {} self . sent_subscriptions = {} self . failed_subscriptions = {} account_subscribe ( self , pubkey , commitment = None , encoding = None ) async Subscribe to an account to receive notifications when the lamports or data change. Parameters: Name Type Description Default pubkey PublicKey Account pubkey. required commitment Optional[Commitment] Commitment level. None encoding Optional[str] Encoding to use. None Source code in solana/rpc/websocket_api.py async def account_subscribe ( self , pubkey : PublicKey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None ) -> None : \"\"\"Subscribe to an account to receive notifications when the lamports or data change. Args: pubkey: Account pubkey. commitment: Commitment level. encoding: Encoding to use. \"\"\" req = AccountSubscribe ( pubkey , commitment , encoding ) await self . send_data ( req ) account_unsubscribe ( self , subscription ) async Unsubscribe from account notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def account_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from account notifications. Args: subscription: ID of subscription to cancel. \"\"\" req = AccountUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ] logs_subscribe ( self , filter_ = 'all' , commitment = None , encoding = None ) async Subscribe to transaction logging. Parameters: Name Type Description Default filter_ Union[str, Dict[Literal['mentions'], List[str]]] filter criteria for the logs. Use LogsSubscribeFilter to build the filter. 'all' commitment Optional[Commitment] The commitment level to use. None encoding Optional[str] The encoding to use. None Source code in solana/rpc/websocket_api.py async def logs_subscribe ( self , filter_ : Union [ str , MentionsFilter ] = LogsSubscribeFilter . ALL , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , ) -> None : \"\"\"Subscribe to transaction logging. Args: filter_: filter criteria for the logs. Use `LogsSubscribeFilter` to build the filter. commitment: The commitment level to use. encoding: The encoding to use. \"\"\" req = LogsSubscribe ( filter_ , commitment , encoding ) await self . send_data ( req ) logs_unsubscribe ( self , subscription ) async Unsubscribe from transaction logging. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def logs_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from transaction logging. Args: subscription: ID of subscription to cancel. \"\"\" req = LogsUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ] program_subscribe ( self , program_id , commitment = None , encoding = None , data_size = None , memcmp_opts = None ) async Receive notifications when the lamports or data for a given account owned by the program changes. Parameters: Name Type Description Default program_id PublicKey The program ID. required commitment Optional[Commitment] Commitment level to use. None encoding Optional[str] Encoding to use. None data_size Optional[int] Data size filter. None memcmp_opts Optional[List[solana.rpc.types.MemcmpOpts]] memcmp options. None Source code in solana/rpc/websocket_api.py async def program_subscribe ( # pylint: disable=too-many-arguments self , program_id : PublicKey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , data_size : Optional [ int ] = None , memcmp_opts : Optional [ List [ types . MemcmpOpts ]] = None , ) -> None : \"\"\"Receive notifications when the lamports or data for a given account owned by the program changes. Args: program_id: The program ID. commitment: Commitment level to use. encoding: Encoding to use. data_size: Data size filter. memcmp_opts: memcmp options. \"\"\" # noqa: E501 req = ProgramSubscribe ( program_id , commitment , encoding , data_size , memcmp_opts ) await self . send_data ( req ) program_unsubscribe ( self , subscription ) async Unsubscribe from program account notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def program_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from program account notifications. Args: subscription: ID of subscription to cancel. \"\"\" req = ProgramUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ] recv ( self ) async Receive the next message. Basically .recv from websockets with extra parsing. Source code in solana/rpc/websocket_api.py async def recv ( # type: ignore self , ) -> Union [ List [ Union [ SubscriptionNotification , Error , Ok ]], SubscriptionNotification , Error , Ok ]: \"\"\"Receive the next message. Basically `.recv` from `websockets` with extra parsing. \"\"\" data = await super () . recv () as_json = loads ( data ) if isinstance ( as_json , list ): return [ self . _process_rpc_response ( item ) for item in as_json ] return self . _process_rpc_response ( as_json ) root_subscribe ( self ) async Subscribe to receive notification anytime a new root is set by the validator. Source code in solana/rpc/websocket_api.py async def root_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a new root is set by the validator.\"\"\" req = RootSubscribe () await self . send_data ( req ) root_unsubscribe ( self , subscription ) async Unsubscribe from root notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def root_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from root notifications. Args: subscription: ID of subscription to cancel. \"\"\" req = RootUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ] send_data ( self , message ) async Send a subscribe/unsubscribe request or list of requests. Basically .send from websockets with extra parsing. Parameters: Name Type Description Default message Union[solana.rpc.request_builder.RequestBody, List[solana.rpc.request_builder.RequestBody]] The request(s) to send. required Source code in solana/rpc/websocket_api.py async def send_data ( self , message : Union [ RequestBody , List [ RequestBody ]]) -> None : \"\"\"Send a subscribe/unsubscribe request or list of requests. Basically `.send` from `websockets` with extra parsing. Args: message: The request(s) to send. \"\"\" to_send = message . to_request () if isinstance ( message , RequestBody ) else [ msg . to_request () for msg in message ] await self . _send ( to_send ) # type: ignore signature_subscribe ( self , signature , commitment = None ) async Subscribe to a transaction signature to receive notification when the transaction is confirmed. Parameters: Name Type Description Default signature <function NewType.<locals>.new_type at 0x7f7a95701700> The transaction signature to subscribe to. required commitment Optional[Commitment] Commitment level. None Source code in solana/rpc/websocket_api.py async def signature_subscribe ( self , signature : TransactionSignature , commitment : Optional [ Commitment ] = None , ) -> None : \"\"\"Subscribe to a transaction signature to receive notification when the transaction is confirmed. Args: signature: The transaction signature to subscribe to. commitment: Commitment level. \"\"\" req = SignatureSubscribe ( signature , commitment ) await self . send_data ( req ) signature_unsubscribe ( self , subscription ) async Unsubscribe from signature notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def signature_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from signature notifications. Args: subscription: ID of subscription to cancel. \"\"\" req = SignatureUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ] slot_subscribe ( self ) async Subscribe to receive notification anytime a slot is processed by the validator. Source code in solana/rpc/websocket_api.py async def slot_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a slot is processed by the validator.\"\"\" req = SlotSubscribe () await self . send_data ( req ) slot_unsubscribe ( self , subscription ) async Unsubscribe from slot notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def slot_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from slot notifications. Args: subscription: ID of subscription to cancel. \"\"\" req = SlotUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ] slots_updates_subscribe ( self ) async Subscribe to receive a notification from the validator on a variety of updates on every slot. Source code in solana/rpc/websocket_api.py async def slots_updates_subscribe ( self ) -> None : \"\"\"Subscribe to receive a notification from the validator on a variety of updates on every slot.\"\"\" req = SlotsUpdatesSubscribe () await self . send_data ( req ) slots_updates_unsubscribe ( self , subscription ) async Unsubscribe from slot update notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def slots_updates_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from slot update notifications. Args: subscription: ID of subscription to cancel. \"\"\" req = SlotsUpdatesUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ] vote_subscribe ( self ) async Subscribe to receive notification anytime a new vote is observed in gossip. Source code in solana/rpc/websocket_api.py async def vote_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a new vote is observed in gossip.\"\"\" req = VoteSubscribe () await self . send_data ( req ) vote_unsubscribe ( self , subscription ) async Unsubscribe from vote notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def vote_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from vote notifications. Args: subscription: ID of subscription to cancel. \"\"\" req = VoteUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ] SubscriptionError Raise when subscribing to an RPC feed fails. Source code in solana/rpc/websocket_api.py class SubscriptionError ( Exception ): \"\"\"Raise when subscribing to an RPC feed fails.\"\"\" def __init__ ( self , err : Error , subscription : dict ) -> None : \"\"\"Init. Args: err: The RPC error object. subscription: The subscription message that caused the error. \"\"\" self . code = err . code self . msg = err . message self . subscription = subscription super () . __init__ ( f \" { self . code } : { self . msg } \\n Caused by subscription: { subscription } \" ) __init__ ( self , err , subscription ) special Init. Parameters: Name Type Description Default err Error The RPC error object. required subscription dict The subscription message that caused the error. required Source code in solana/rpc/websocket_api.py def __init__ ( self , err : Error , subscription : dict ) -> None : \"\"\"Init. Args: err: The RPC error object. subscription: The subscription message that caused the error. \"\"\" self . code = err . code self . msg = err . message self . subscription = subscription super () . __init__ ( f \" { self . code } : { self . msg } \\n Caused by subscription: { subscription } \" ) connect Solana RPC websocket connector. Source code in solana/rpc/websocket_api.py class connect ( ws_connect ): # pylint: disable=invalid-name,too-few-public-methods \"\"\"Solana RPC websocket connector.\"\"\" def __init__ ( self , uri : str = \"ws://localhost:8900\" , ** kwargs : Any ) -> None : \"\"\"Init. Kwargs are passed to `websockets.connect`. Args: uri: The websocket endpoint. \"\"\" super () . __init__ ( uri , ** kwargs , create_protocol = SolanaWsClientProtocol ) __init__ ( self , uri = 'ws://localhost:8900' , ** kwargs ) special Init. Kwargs are passed to websockets.connect . Parameters: Name Type Description Default uri str The websocket endpoint. 'ws://localhost:8900' Source code in solana/rpc/websocket_api.py def __init__ ( self , uri : str = \"ws://localhost:8900\" , ** kwargs : Any ) -> None : \"\"\"Init. Kwargs are passed to `websockets.connect`. Args: uri: The websocket endpoint. \"\"\" super () . __init__ ( uri , ** kwargs , create_protocol = SolanaWsClientProtocol )","title":"Websocket Client"},{"location":"rpc/websocket/#websocket-client","text":"","title":"Websocket Client"},{"location":"rpc/websocket/#solana.rpc.websocket_api","text":"This module contains code for interacting with the RPC Websocket endpoint.","title":"websocket_api"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol","text":"Subclass of websockets.WebSocketClientProtocol tailored for Solana RPC websockets. Source code in solana/rpc/websocket_api.py class SolanaWsClientProtocol ( WebSocketClientProtocol ): \"\"\"Subclass of `websockets.WebSocketClientProtocol` tailored for Solana RPC websockets.\"\"\" def __init__ ( self , * args , ** kwargs ): \"\"\"Init. Args and kwargs are passed to `websockets.WebSocketClientProtocol`.\"\"\" super () . __init__ ( * args , ** kwargs ) self . subscriptions = {} self . sent_subscriptions = {} self . failed_subscriptions = {} async def _send ( self , data : Union [ Dict [ str , Any ], list ]) -> None : as_json_str = dumps ( data ) await super () . send ( as_json_str ) if isinstance ( data , dict ): self . sent_subscriptions [ data [ \"id\" ]] = data else : for req in data : self . sent_subscriptions [ req [ \"id\" ]] = req async def send_data ( self , message : Union [ RequestBody , List [ RequestBody ]]) -> None : \"\"\"Send a subscribe/unsubscribe request or list of requests. Basically `.send` from `websockets` with extra parsing. Args: message: The request(s) to send. \"\"\" to_send = message . to_request () if isinstance ( message , RequestBody ) else [ msg . to_request () for msg in message ] await self . _send ( to_send ) # type: ignore async def recv ( # type: ignore self , ) -> Union [ List [ Union [ SubscriptionNotification , Error , Ok ]], SubscriptionNotification , Error , Ok ]: \"\"\"Receive the next message. Basically `.recv` from `websockets` with extra parsing. \"\"\" data = await super () . recv () as_json = loads ( data ) if isinstance ( as_json , list ): return [ self . _process_rpc_response ( item ) for item in as_json ] return self . _process_rpc_response ( as_json ) async def account_subscribe ( self , pubkey : PublicKey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None ) -> None : \"\"\"Subscribe to an account to receive notifications when the lamports or data change. Args: pubkey: Account pubkey. commitment: Commitment level. encoding: Encoding to use. \"\"\" req = AccountSubscribe ( pubkey , commitment , encoding ) await self . send_data ( req ) async def account_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from account notifications. Args: subscription: ID of subscription to cancel. \"\"\" req = AccountUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def logs_subscribe ( self , filter_ : Union [ str , MentionsFilter ] = LogsSubscribeFilter . ALL , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , ) -> None : \"\"\"Subscribe to transaction logging. Args: filter_: filter criteria for the logs. Use `LogsSubscribeFilter` to build the filter. commitment: The commitment level to use. encoding: The encoding to use. \"\"\" req = LogsSubscribe ( filter_ , commitment , encoding ) await self . send_data ( req ) async def logs_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from transaction logging. Args: subscription: ID of subscription to cancel. \"\"\" req = LogsUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def program_subscribe ( # pylint: disable=too-many-arguments self , program_id : PublicKey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , data_size : Optional [ int ] = None , memcmp_opts : Optional [ List [ types . MemcmpOpts ]] = None , ) -> None : \"\"\"Receive notifications when the lamports or data for a given account owned by the program changes. Args: program_id: The program ID. commitment: Commitment level to use. encoding: Encoding to use. data_size: Data size filter. memcmp_opts: memcmp options. \"\"\" # noqa: E501 req = ProgramSubscribe ( program_id , commitment , encoding , data_size , memcmp_opts ) await self . send_data ( req ) async def program_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from program account notifications. Args: subscription: ID of subscription to cancel. \"\"\" req = ProgramUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def signature_subscribe ( self , signature : TransactionSignature , commitment : Optional [ Commitment ] = None , ) -> None : \"\"\"Subscribe to a transaction signature to receive notification when the transaction is confirmed. Args: signature: The transaction signature to subscribe to. commitment: Commitment level. \"\"\" req = SignatureSubscribe ( signature , commitment ) await self . send_data ( req ) async def signature_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from signature notifications. Args: subscription: ID of subscription to cancel. \"\"\" req = SignatureUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def slot_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a slot is processed by the validator.\"\"\" req = SlotSubscribe () await self . send_data ( req ) async def slot_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from slot notifications. Args: subscription: ID of subscription to cancel. \"\"\" req = SlotUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def slots_updates_subscribe ( self ) -> None : \"\"\"Subscribe to receive a notification from the validator on a variety of updates on every slot.\"\"\" req = SlotsUpdatesSubscribe () await self . send_data ( req ) async def slots_updates_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from slot update notifications. Args: subscription: ID of subscription to cancel. \"\"\" req = SlotsUpdatesUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def root_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a new root is set by the validator.\"\"\" req = RootSubscribe () await self . send_data ( req ) async def root_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from root notifications. Args: subscription: ID of subscription to cancel. \"\"\" req = RootUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def vote_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a new vote is observed in gossip.\"\"\" req = VoteSubscribe () await self . send_data ( req ) async def vote_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from vote notifications. Args: subscription: ID of subscription to cancel. \"\"\" req = VoteUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ] def _process_rpc_response ( self , data : dict ) -> Union [ SubscriptionNotification , Error , Ok ]: parsed = _parse_rpc_response ( data ) if isinstance ( parsed , Error ): subscription = self . sent_subscriptions [ parsed . id ] self . failed_subscriptions [ parsed . id ] = subscription raise SubscriptionError ( parsed , subscription ) parsed_result = parsed . result if type ( parsed_result ) is int and type ( parsed ) is Ok : # pylint: disable=unidiomatic-typecheck self . subscriptions [ parsed_result ] = self . sent_subscriptions [ parsed . id ] return parsed","title":"SolanaWsClientProtocol"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.__init__","text":"Init. Args and kwargs are passed to websockets.WebSocketClientProtocol . Source code in solana/rpc/websocket_api.py def __init__ ( self , * args , ** kwargs ): \"\"\"Init. Args and kwargs are passed to `websockets.WebSocketClientProtocol`.\"\"\" super () . __init__ ( * args , ** kwargs ) self . subscriptions = {} self . sent_subscriptions = {} self . failed_subscriptions = {}","title":"__init__()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.account_subscribe","text":"Subscribe to an account to receive notifications when the lamports or data change. Parameters: Name Type Description Default pubkey PublicKey Account pubkey. required commitment Optional[Commitment] Commitment level. None encoding Optional[str] Encoding to use. None Source code in solana/rpc/websocket_api.py async def account_subscribe ( self , pubkey : PublicKey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None ) -> None : \"\"\"Subscribe to an account to receive notifications when the lamports or data change. Args: pubkey: Account pubkey. commitment: Commitment level. encoding: Encoding to use. \"\"\" req = AccountSubscribe ( pubkey , commitment , encoding ) await self . send_data ( req )","title":"account_subscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.account_unsubscribe","text":"Unsubscribe from account notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def account_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from account notifications. Args: subscription: ID of subscription to cancel. \"\"\" req = AccountUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ]","title":"account_unsubscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.logs_subscribe","text":"Subscribe to transaction logging. Parameters: Name Type Description Default filter_ Union[str, Dict[Literal['mentions'], List[str]]] filter criteria for the logs. Use LogsSubscribeFilter to build the filter. 'all' commitment Optional[Commitment] The commitment level to use. None encoding Optional[str] The encoding to use. None Source code in solana/rpc/websocket_api.py async def logs_subscribe ( self , filter_ : Union [ str , MentionsFilter ] = LogsSubscribeFilter . ALL , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , ) -> None : \"\"\"Subscribe to transaction logging. Args: filter_: filter criteria for the logs. Use `LogsSubscribeFilter` to build the filter. commitment: The commitment level to use. encoding: The encoding to use. \"\"\" req = LogsSubscribe ( filter_ , commitment , encoding ) await self . send_data ( req )","title":"logs_subscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.logs_unsubscribe","text":"Unsubscribe from transaction logging. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def logs_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from transaction logging. Args: subscription: ID of subscription to cancel. \"\"\" req = LogsUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ]","title":"logs_unsubscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.program_subscribe","text":"Receive notifications when the lamports or data for a given account owned by the program changes. Parameters: Name Type Description Default program_id PublicKey The program ID. required commitment Optional[Commitment] Commitment level to use. None encoding Optional[str] Encoding to use. None data_size Optional[int] Data size filter. None memcmp_opts Optional[List[solana.rpc.types.MemcmpOpts]] memcmp options. None Source code in solana/rpc/websocket_api.py async def program_subscribe ( # pylint: disable=too-many-arguments self , program_id : PublicKey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , data_size : Optional [ int ] = None , memcmp_opts : Optional [ List [ types . MemcmpOpts ]] = None , ) -> None : \"\"\"Receive notifications when the lamports or data for a given account owned by the program changes. Args: program_id: The program ID. commitment: Commitment level to use. encoding: Encoding to use. data_size: Data size filter. memcmp_opts: memcmp options. \"\"\" # noqa: E501 req = ProgramSubscribe ( program_id , commitment , encoding , data_size , memcmp_opts ) await self . send_data ( req )","title":"program_subscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.program_unsubscribe","text":"Unsubscribe from program account notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def program_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from program account notifications. Args: subscription: ID of subscription to cancel. \"\"\" req = ProgramUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ]","title":"program_unsubscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.recv","text":"Receive the next message. Basically .recv from websockets with extra parsing. Source code in solana/rpc/websocket_api.py async def recv ( # type: ignore self , ) -> Union [ List [ Union [ SubscriptionNotification , Error , Ok ]], SubscriptionNotification , Error , Ok ]: \"\"\"Receive the next message. Basically `.recv` from `websockets` with extra parsing. \"\"\" data = await super () . recv () as_json = loads ( data ) if isinstance ( as_json , list ): return [ self . _process_rpc_response ( item ) for item in as_json ] return self . _process_rpc_response ( as_json )","title":"recv()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.root_subscribe","text":"Subscribe to receive notification anytime a new root is set by the validator. Source code in solana/rpc/websocket_api.py async def root_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a new root is set by the validator.\"\"\" req = RootSubscribe () await self . send_data ( req )","title":"root_subscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.root_unsubscribe","text":"Unsubscribe from root notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def root_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from root notifications. Args: subscription: ID of subscription to cancel. \"\"\" req = RootUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ]","title":"root_unsubscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.send_data","text":"Send a subscribe/unsubscribe request or list of requests. Basically .send from websockets with extra parsing. Parameters: Name Type Description Default message Union[solana.rpc.request_builder.RequestBody, List[solana.rpc.request_builder.RequestBody]] The request(s) to send. required Source code in solana/rpc/websocket_api.py async def send_data ( self , message : Union [ RequestBody , List [ RequestBody ]]) -> None : \"\"\"Send a subscribe/unsubscribe request or list of requests. Basically `.send` from `websockets` with extra parsing. Args: message: The request(s) to send. \"\"\" to_send = message . to_request () if isinstance ( message , RequestBody ) else [ msg . to_request () for msg in message ] await self . _send ( to_send ) # type: ignore","title":"send_data()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.signature_subscribe","text":"Subscribe to a transaction signature to receive notification when the transaction is confirmed. Parameters: Name Type Description Default signature <function NewType.<locals>.new_type at 0x7f7a95701700> The transaction signature to subscribe to. required commitment Optional[Commitment] Commitment level. None Source code in solana/rpc/websocket_api.py async def signature_subscribe ( self , signature : TransactionSignature , commitment : Optional [ Commitment ] = None , ) -> None : \"\"\"Subscribe to a transaction signature to receive notification when the transaction is confirmed. Args: signature: The transaction signature to subscribe to. commitment: Commitment level. \"\"\" req = SignatureSubscribe ( signature , commitment ) await self . send_data ( req )","title":"signature_subscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.signature_unsubscribe","text":"Unsubscribe from signature notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def signature_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from signature notifications. Args: subscription: ID of subscription to cancel. \"\"\" req = SignatureUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ]","title":"signature_unsubscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.slot_subscribe","text":"Subscribe to receive notification anytime a slot is processed by the validator. Source code in solana/rpc/websocket_api.py async def slot_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a slot is processed by the validator.\"\"\" req = SlotSubscribe () await self . send_data ( req )","title":"slot_subscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.slot_unsubscribe","text":"Unsubscribe from slot notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def slot_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from slot notifications. Args: subscription: ID of subscription to cancel. \"\"\" req = SlotUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ]","title":"slot_unsubscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.slots_updates_subscribe","text":"Subscribe to receive a notification from the validator on a variety of updates on every slot. Source code in solana/rpc/websocket_api.py async def slots_updates_subscribe ( self ) -> None : \"\"\"Subscribe to receive a notification from the validator on a variety of updates on every slot.\"\"\" req = SlotsUpdatesSubscribe () await self . send_data ( req )","title":"slots_updates_subscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.slots_updates_unsubscribe","text":"Unsubscribe from slot update notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def slots_updates_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from slot update notifications. Args: subscription: ID of subscription to cancel. \"\"\" req = SlotsUpdatesUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ]","title":"slots_updates_unsubscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.vote_subscribe","text":"Subscribe to receive notification anytime a new vote is observed in gossip. Source code in solana/rpc/websocket_api.py async def vote_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a new vote is observed in gossip.\"\"\" req = VoteSubscribe () await self . send_data ( req )","title":"vote_subscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.vote_unsubscribe","text":"Unsubscribe from vote notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def vote_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from vote notifications. Args: subscription: ID of subscription to cancel. \"\"\" req = VoteUnsubscribe ( subscription ) await self . send_data ( req ) del self . subscriptions [ subscription ]","title":"vote_unsubscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SubscriptionError","text":"Raise when subscribing to an RPC feed fails. Source code in solana/rpc/websocket_api.py class SubscriptionError ( Exception ): \"\"\"Raise when subscribing to an RPC feed fails.\"\"\" def __init__ ( self , err : Error , subscription : dict ) -> None : \"\"\"Init. Args: err: The RPC error object. subscription: The subscription message that caused the error. \"\"\" self . code = err . code self . msg = err . message self . subscription = subscription super () . __init__ ( f \" { self . code } : { self . msg } \\n Caused by subscription: { subscription } \" )","title":"SubscriptionError"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SubscriptionError.__init__","text":"Init. Parameters: Name Type Description Default err Error The RPC error object. required subscription dict The subscription message that caused the error. required Source code in solana/rpc/websocket_api.py def __init__ ( self , err : Error , subscription : dict ) -> None : \"\"\"Init. Args: err: The RPC error object. subscription: The subscription message that caused the error. \"\"\" self . code = err . code self . msg = err . message self . subscription = subscription super () . __init__ ( f \" { self . code } : { self . msg } \\n Caused by subscription: { subscription } \" )","title":"__init__()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.connect","text":"Solana RPC websocket connector. Source code in solana/rpc/websocket_api.py class connect ( ws_connect ): # pylint: disable=invalid-name,too-few-public-methods \"\"\"Solana RPC websocket connector.\"\"\" def __init__ ( self , uri : str = \"ws://localhost:8900\" , ** kwargs : Any ) -> None : \"\"\"Init. Kwargs are passed to `websockets.connect`. Args: uri: The websocket endpoint. \"\"\" super () . __init__ ( uri , ** kwargs , create_protocol = SolanaWsClientProtocol )","title":"connect"},{"location":"rpc/websocket/#solana.rpc.websocket_api.connect.__init__","text":"Init. Kwargs are passed to websockets.connect . Parameters: Name Type Description Default uri str The websocket endpoint. 'ws://localhost:8900' Source code in solana/rpc/websocket_api.py def __init__ ( self , uri : str = \"ws://localhost:8900\" , ** kwargs : Any ) -> None : \"\"\"Init. Kwargs are passed to `websockets.connect`. Args: uri: The websocket endpoint. \"\"\" super () . __init__ ( uri , ** kwargs , create_protocol = SolanaWsClientProtocol )","title":"__init__()"},{"location":"spl/intro/","text":"Solana Program Library (SPL) The Solana Program Library (SPL) is a collection of on-chain programs targeting the Sealevel parallel runtime . These programs are tested against Solana's implementation of Sealevel, solana-runtime, and deployed to its mainnet. Note The Python SPL library is separate from the main Python Solana library, so you import it with import spl instead of import solana . You don't install it separately though: it gets installed when you run pip install solana .","title":"Solana Program Library (SPL)"},{"location":"spl/intro/#solana-program-library-spl","text":"The Solana Program Library (SPL) is a collection of on-chain programs targeting the Sealevel parallel runtime . These programs are tested against Solana's implementation of Sealevel, solana-runtime, and deployed to its mainnet. Note The Python SPL library is separate from the main Python Solana library, so you import it with import spl instead of import solana . You don't install it separately though: it gets installed when you run pip install solana .","title":"Solana Program Library (SPL)"},{"location":"spl/memo/constants/","text":"Constants spl.memo.constants Memo program constants. MEMO_PROGRAM_ID : PublicKey Public key that identifies the Memo program.","title":"Constants"},{"location":"spl/memo/constants/#constants","text":"","title":"Constants"},{"location":"spl/memo/constants/#spl.memo.constants","text":"Memo program constants.","title":"constants"},{"location":"spl/memo/constants/#spl.memo.constants.MEMO_PROGRAM_ID","text":"Public key that identifies the Memo program.","title":"MEMO_PROGRAM_ID"},{"location":"spl/memo/instructions/","text":"Memo Program spl.memo.instructions Memo program instructions. MemoParams Create memo transaction params. Source code in spl/memo/instructions.py class MemoParams ( NamedTuple ): \"\"\"Create memo transaction params.\"\"\" program_id : PublicKey \"\"\"Memo program account.\"\"\" signer : PublicKey \"\"\"Signing account.\"\"\" message : bytes \"\"\"Memo message in bytes.\"\"\" message : bytes Memo message in bytes. program_id : PublicKey Memo program account. signer : PublicKey Signing account. create_memo ( params ) Creates a transaction instruction that creates a memo. Message need to be encoded in bytes. Examples: >>> signer , memo_program = PublicKey ( 1 ), PublicKey ( 2 ) >>> message = bytes ( \"test\" , encoding = \"utf8\" ) >>> params = MemoParams ( ... program_id = memo_program , ... message = message , ... signer = signer ... ) >>> type ( create_memo ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The instruction to create a memo. Source code in spl/memo/instructions.py def create_memo ( params : MemoParams ) -> TransactionInstruction : \"\"\"Creates a transaction instruction that creates a memo. Message need to be encoded in bytes. Example: >>> signer, memo_program = PublicKey(1), PublicKey(2) >>> message = bytes(\"test\", encoding=\"utf8\") >>> params = MemoParams( ... program_id=memo_program, ... message=message, ... signer=signer ... ) >>> type(create_memo(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The instruction to create a memo. \"\"\" keys = [ AccountMeta ( pubkey = params . signer , is_signer = True , is_writable = True ), ] return TransactionInstruction ( keys = keys , program_id = params . program_id , data = params . message , ) decode_create_memo ( instruction ) Decode a create_memo_instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description MemoParams The decoded instruction. Source code in spl/memo/instructions.py def decode_create_memo ( instruction : TransactionInstruction ) -> MemoParams : \"\"\"Decode a create_memo_instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" return MemoParams ( signer = instruction . keys [ 0 ] . pubkey , message = instruction . data , program_id = instruction . program_id )","title":"Memo Program"},{"location":"spl/memo/instructions/#memo-program","text":"","title":"Memo Program"},{"location":"spl/memo/instructions/#spl.memo.instructions","text":"Memo program instructions.","title":"instructions"},{"location":"spl/memo/instructions/#spl.memo.instructions.MemoParams","text":"Create memo transaction params. Source code in spl/memo/instructions.py class MemoParams ( NamedTuple ): \"\"\"Create memo transaction params.\"\"\" program_id : PublicKey \"\"\"Memo program account.\"\"\" signer : PublicKey \"\"\"Signing account.\"\"\" message : bytes \"\"\"Memo message in bytes.\"\"\"","title":"MemoParams"},{"location":"spl/memo/instructions/#spl.memo.instructions.MemoParams.message","text":"Memo message in bytes.","title":"message"},{"location":"spl/memo/instructions/#spl.memo.instructions.MemoParams.program_id","text":"Memo program account.","title":"program_id"},{"location":"spl/memo/instructions/#spl.memo.instructions.MemoParams.signer","text":"Signing account.","title":"signer"},{"location":"spl/memo/instructions/#spl.memo.instructions.create_memo","text":"Creates a transaction instruction that creates a memo. Message need to be encoded in bytes. Examples: >>> signer , memo_program = PublicKey ( 1 ), PublicKey ( 2 ) >>> message = bytes ( \"test\" , encoding = \"utf8\" ) >>> params = MemoParams ( ... program_id = memo_program , ... message = message , ... signer = signer ... ) >>> type ( create_memo ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The instruction to create a memo. Source code in spl/memo/instructions.py def create_memo ( params : MemoParams ) -> TransactionInstruction : \"\"\"Creates a transaction instruction that creates a memo. Message need to be encoded in bytes. Example: >>> signer, memo_program = PublicKey(1), PublicKey(2) >>> message = bytes(\"test\", encoding=\"utf8\") >>> params = MemoParams( ... program_id=memo_program, ... message=message, ... signer=signer ... ) >>> type(create_memo(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The instruction to create a memo. \"\"\" keys = [ AccountMeta ( pubkey = params . signer , is_signer = True , is_writable = True ), ] return TransactionInstruction ( keys = keys , program_id = params . program_id , data = params . message , )","title":"create_memo()"},{"location":"spl/memo/instructions/#spl.memo.instructions.decode_create_memo","text":"Decode a create_memo_instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description MemoParams The decoded instruction. Source code in spl/memo/instructions.py def decode_create_memo ( instruction : TransactionInstruction ) -> MemoParams : \"\"\"Decode a create_memo_instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" return MemoParams ( signer = instruction . keys [ 0 ] . pubkey , message = instruction . data , program_id = instruction . program_id )","title":"decode_create_memo()"},{"location":"spl/memo/intro/","text":"Intro The Memo program is a simple program that validates a string of UTF-8 encoded characters and verifies that any accounts provided are signers of the transaction. The program also logs the memo, as well as any verified signer addresses, to the transaction log, so that anyone can easily observe memos and know they were approved by zero or more addresses by inspecting the transaction log from a trusted provider. Background Solana's programming model and the definitions of the Solana terms used in this document are available at: https://docs.solana.com/apps https://docs.solana.com/terminology Source The Memo Program's source is available on github Interface The on-chain Memo Program is written in Rust and available on crates.io as spl-memo and docs.rs . The crate provides a build_memo() method to easily create a properly constructed Instruction. Operational Notes If zero accounts are provided to the signed-memo instruction, the program succeeds when the memo is valid UTF-8, and logs the memo to the transaction log. If one or more accounts are provided to the signed-memo instruction, all must be valid signers of the transaction for the instruction to succeed. Logs This section details expected log output for memo instructions. Logging begins with entry into the program: Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr invoke [1] The program will include a separate log for each verified signer: Program log: Signed by <BASE_58_ADDRESS> Then the program logs the memo length and UTF-8 text: Program log: Memo (len 4): \"\ud83d\udc06\" If UTF-8 parsing fails, the program will log the failure point: Program log: Invalid UTF-8, from byte 4 Logging ends with the status of the instruction, one of: Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr success Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr failed: missing required signature for instruction Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr failed: invalid instruction data For more information about exposing program logs on a node, head to the developer docs Compute Limits Like all programs, the Memo Program is subject to the cluster's compute budget . In Memo, compute is used for parsing UTF-8, verifying signers, and logging, limiting the memo length and number of signers that can be processed successfully in a single instruction. The longer or more complex the UTF-8 memo, the fewer signers can be supported, and vice versa. As of v1.5.1, an unsigned instruction can support single-byte UTF-8 of up to 566 bytes. An instruction with a simple memo of 32 bytes can support up to 12 signers.","title":"Intro"},{"location":"spl/memo/intro/#intro","text":"The Memo program is a simple program that validates a string of UTF-8 encoded characters and verifies that any accounts provided are signers of the transaction. The program also logs the memo, as well as any verified signer addresses, to the transaction log, so that anyone can easily observe memos and know they were approved by zero or more addresses by inspecting the transaction log from a trusted provider.","title":"Intro"},{"location":"spl/memo/intro/#background","text":"Solana's programming model and the definitions of the Solana terms used in this document are available at: https://docs.solana.com/apps https://docs.solana.com/terminology","title":"Background"},{"location":"spl/memo/intro/#source","text":"The Memo Program's source is available on github","title":"Source"},{"location":"spl/memo/intro/#interface","text":"The on-chain Memo Program is written in Rust and available on crates.io as spl-memo and docs.rs . The crate provides a build_memo() method to easily create a properly constructed Instruction.","title":"Interface"},{"location":"spl/memo/intro/#operational-notes","text":"If zero accounts are provided to the signed-memo instruction, the program succeeds when the memo is valid UTF-8, and logs the memo to the transaction log. If one or more accounts are provided to the signed-memo instruction, all must be valid signers of the transaction for the instruction to succeed.","title":"Operational Notes"},{"location":"spl/memo/intro/#logs","text":"This section details expected log output for memo instructions. Logging begins with entry into the program: Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr invoke [1] The program will include a separate log for each verified signer: Program log: Signed by <BASE_58_ADDRESS> Then the program logs the memo length and UTF-8 text: Program log: Memo (len 4): \"\ud83d\udc06\" If UTF-8 parsing fails, the program will log the failure point: Program log: Invalid UTF-8, from byte 4 Logging ends with the status of the instruction, one of: Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr success Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr failed: missing required signature for instruction Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr failed: invalid instruction data For more information about exposing program logs on a node, head to the developer docs","title":"Logs"},{"location":"spl/memo/intro/#compute-limits","text":"Like all programs, the Memo Program is subject to the cluster's compute budget . In Memo, compute is used for parsing UTF-8, verifying signers, and logging, limiting the memo length and number of signers that can be processed successfully in a single instruction. The longer or more complex the UTF-8 memo, the fewer signers can be supported, and vice versa. As of v1.5.1, an unsigned instruction can support single-byte UTF-8 of up to 566 bytes. An instruction with a simple memo of 32 bytes can support up to 12 signers.","title":"Compute Limits"},{"location":"spl/token/async_client/","text":"Async Client spl.token.async_client Async SPL Token program client. AsyncToken An ERC20-like Token. Source code in spl/token/async_client.py class AsyncToken ( _TokenCore ): # pylint: disable=too-many-public-methods \"\"\"An ERC20-like Token.\"\"\" def __init__ ( self , conn : AsyncClient , pubkey : PublicKey , program_id : PublicKey , payer : Keypair ) -> None : \"\"\"Initialize a client to a SPL-Token program.\"\"\" super () . __init__ ( pubkey , program_id , payer ) self . _conn = conn @staticmethod async def get_min_balance_rent_for_exempt_for_account ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the account to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( ACCOUNT_LAYOUT . sizeof ()) return resp [ \"result\" ] @staticmethod async def get_min_balance_rent_for_exempt_for_mint ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the mint to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( MINT_LAYOUT . sizeof ()) return resp [ \"result\" ] @staticmethod async def get_min_balance_rent_for_exempt_for_multisig ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the multisig to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( MULTISIG_LAYOUT . sizeof ()) return resp [ \"result\" ] async def get_accounts ( self , owner : PublicKey , is_delegate : bool = False , commitment : Optional [ Commitment ] = None , encoding : str = \"jsonParsed\" , ) -> RPCResponse : \"\"\"Get token accounts of the provided owner by the token's mint. Args: owner: Public Key of the token account owner. is_delegate: (optional) Flag specifying if the `owner` public key is a delegate. encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\" or jsonParsed\". commitment: (optional) Bank state to query. Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment # pylint: disable=protected-access ) return ( await self . _conn . get_token_accounts_by_delegate ( * args ) if is_delegate else await self . _conn . get_token_accounts_by_owner ( * args ) ) async def get_balance ( self , pubkey : PublicKey , commitment : Optional [ Commitment ] = None ) -> RPCResponse : \"\"\"Get the balance of the provided token account. Args: pubkey: Public Key of the token account. commitment: (optional) Bank state to query. \"\"\" return await self . _conn . get_token_account_balance ( pubkey , commitment ) @classmethod async def create_mint ( cls , conn : AsyncClient , payer : Keypair , mint_authority : PublicKey , decimals : int , program_id : PublicKey , freeze_authority : Optional [ PublicKey ] = None , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> AsyncToken : \"\"\"Create and initialize a token. Args: conn: RPC connection to a solana cluster. payer: Fee payer for transaction. mint_authority: Account or multisig that will control minting. decimals: Location of the decimal place. program_id: SPL Token program account. freeze_authority: (optional) Account or multisig that can freeze token accounts. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Token object for the newly minted token. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_mint ( conn ) # Construct transaction token , txn , payer , mint_account , opts = _TokenCore . _create_mint_args ( conn , payer , mint_authority , decimals , program_id , freeze_authority , skip_confirmation , balance_needed , cls , conn . commitment , ) # Send the two instructions await conn . send_transaction ( txn , payer , mint_account , opts = opts , recent_blockhash = recent_blockhash ) return cast ( AsyncToken , token ) async def create_account ( self , owner : PublicKey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : \"\"\"Create and initialize a new account. This account may then be used as a `transfer()` or `approve()` destination. Args: owner: User account that will own the new account. skip_confirmation: (optional) Option to skip transaction confirmation. Returns: Public key of the new empty account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_account ( self . _conn ) new_account_pk , txn , payer , new_account , opts = self . _create_account_args ( owner , skip_confirmation , balance_needed , self . _conn . commitment ) # Send the two instructions await self . _conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_pk async def create_associated_token_account ( self , owner : PublicKey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : \"\"\"Create an associated token account. Args: owner: User account that will own the associated token account. skip_confirmation: (optional) Option to skip transaction confirmation. Returns: Public key of the new associated account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Construct transaction public_key , txn , payer , opts = self . _create_associated_token_account_args ( owner , skip_confirmation , self . _conn . commitment ) await self . _conn . send_transaction ( txn , payer , opts = opts , recent_blockhash = recent_blockhash ) return public_key @staticmethod async def create_wrapped_native_account ( conn : AsyncClient , program_id : PublicKey , owner : PublicKey , payer : Keypair , amount : int , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : \"\"\"Create and initialize a new account on the special native token mint. Args: conn: RPC connection to a solana cluster. program_id: SPL Token program account. owner: The owner of the new token account. payer: The source of the lamports to initialize, and payer of the initialization fees. amount: The amount of lamports to wrap. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: The new token account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_account ( conn ) new_account_public_key , txn , payer , new_account , opts = _TokenCore . _create_wrapped_native_account_args ( program_id , owner , payer , amount , skip_confirmation , balance_needed , conn . commitment ) await conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_public_key async def create_multisig ( self , m : int , multi_signers : List [ PublicKey ], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : # pylint: disable=invalid-name \"\"\"Create and initialize a new multisig. Args: m: Number of required signatures. multi_signers: Full set of signers. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new multisig account. \"\"\" balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_multisig ( self . _conn ) txn , payer , multisig = self . _create_multisig_args ( m , multi_signers , balance_needed ) opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts await self . _conn . send_transaction ( txn , payer , multisig , opts = opts_to_use , recent_blockhash = recent_blockhash ) return multisig . public_key async def get_mint_info ( self ) -> MintInfo : \"\"\"Retrieve mint information.\"\"\" info = await self . _conn . get_account_info ( self . pubkey ) return self . _create_mint_info ( info ) async def get_account_info ( self , account : PublicKey , commitment : Optional [ Commitment ] = None ) -> AccountInfo : \"\"\"Retrieve account information.\"\"\" info = await self . _conn . get_account_info ( account , commitment ) return self . _create_account_info ( info ) async def transfer ( self , source : PublicKey , dest : PublicKey , owner : Union [ Keypair , PublicKey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Transfer tokens to another account. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_args ( source , dest , owner , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def approve ( self , source : PublicKey , delegate : PublicKey , owner : PublicKey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_args ( source , delegate , owner , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def revoke ( self , account : PublicKey , owner : PublicKey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Revoke transfer authority for a given account. Args: account: Source account for which transfer authority is being revoked. owner: Owner of the source account. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _revoke_args ( account , owner , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def set_authority ( self , account : PublicKey , current_authority : Union [ Keypair , PublicKey ], authority_type : spl_token . AuthorityType , new_authority : Optional [ PublicKey ] = None , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Assign a new authority to the account. Args: account: Public key of the token account. current_authority: Current authority of the account. authority_type: Type of authority to set. new_authority: (optional) New authority of the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _set_authority_args ( account , current_authority , authority_type , new_authority , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def mint_to ( self , dest : PublicKey , mint_authority : Union [ Keypair , PublicKey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Mint new tokens. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_args ( dest , mint_authority , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def burn ( self , account : PublicKey , owner : PublicKey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Burn tokens. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_args ( account , owner , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def close_account ( self , account : PublicKey , dest : PublicKey , authority : PublicKey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Remove approval for the transfer of any remaining tokens. Args: account: Account to close. dest: Account to receive the remaining balance of the closed account. authority: Authority which is allowed to close the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _close_account_args ( account , dest , authority , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def freeze_account ( self , account : PublicKey , authority : PublicKey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Freeze account. Args: account: Account to freeze. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _freeze_account_args ( account , authority , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def thaw_account ( self , account : PublicKey , authority : PublicKey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Thaw account. Args: account: Account to thaw. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _thaw_account_args ( account , authority , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def transfer_checked ( self , source : PublicKey , dest : PublicKey , owner : PublicKey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Transfer tokens to another account, asserting the token mint and decimals. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. decimals: Number of decimals in transfer amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_checked_args ( source , dest , owner , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def approve_checked ( self , source : PublicKey , delegate : PublicKey , owner : PublicKey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. decimals: Number of decimals in approve amount. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash (optional): A prefetched blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_checked_args ( source , delegate , owner , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def mint_to_checked ( self , dest : PublicKey , mint_authority : PublicKey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Mint new tokens, asserting the token mint and decimals. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. decimals: Number of decimals in amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash (optional): A prefetched blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_checked_args ( dest , mint_authority , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def burn_checked ( self , account : PublicKey , owner : PublicKey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Burn tokens, asserting the token mint and decimals. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. decimals: Number of decimals in amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_checked_args ( account , owner , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) approve ( self , source , delegate , owner , amount , multi_signers = None , opts = None , recent_blockhash = None ) async Grant a third-party permission to transfer up the specified number of tokens from an account. Parameters: Name Type Description Default source PublicKey Public key of the source account. required delegate PublicKey Account authorized to perform a transfer tokens from the source account. required owner PublicKey Owner of the source account. required amount int Maximum number of tokens the delegate may transfer. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def approve ( self , source : PublicKey , delegate : PublicKey , owner : PublicKey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_args ( source , delegate , owner , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) approve_checked ( self , source , delegate , owner , amount , decimals , multi_signers = None , opts = None , recent_blockhash = None ) async Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Parameters: Name Type Description Default source PublicKey Public key of the source account. required delegate PublicKey Account authorized to perform a transfer tokens from the source account. required owner PublicKey Owner of the source account. required amount int Maximum number of tokens the delegate may transfer. required decimals int Number of decimals in approve amount. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multisig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash optional A prefetched blockhash for the transaction. None Source code in spl/token/async_client.py async def approve_checked ( self , source : PublicKey , delegate : PublicKey , owner : PublicKey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. decimals: Number of decimals in approve amount. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash (optional): A prefetched blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_checked_args ( source , delegate , owner , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) burn ( self , account , owner , amount , multi_signers = None , opts = None , recent_blockhash = None ) async Burn tokens. Parameters: Name Type Description Default account PublicKey Account to burn tokens from. required owner PublicKey Owner of the account. required amount int Amount to burn. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def burn ( self , account : PublicKey , owner : PublicKey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Burn tokens. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_args ( account , owner , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) burn_checked ( self , account , owner , amount , decimals , multi_signers = None , opts = None , recent_blockhash = None ) async Burn tokens, asserting the token mint and decimals. Parameters: Name Type Description Default account PublicKey Account to burn tokens from. required owner PublicKey Owner of the account. required amount int Amount to burn. required decimals int Number of decimals in amount to burn. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multisig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def burn_checked ( self , account : PublicKey , owner : PublicKey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Burn tokens, asserting the token mint and decimals. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. decimals: Number of decimals in amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_checked_args ( account , owner , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) close_account ( self , account , dest , authority , multi_signers = None , opts = None , recent_blockhash = None ) async Remove approval for the transfer of any remaining tokens. Parameters: Name Type Description Default account PublicKey Account to close. required dest PublicKey Account to receive the remaining balance of the closed account. required authority PublicKey Authority which is allowed to close the account. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def close_account ( self , account : PublicKey , dest : PublicKey , authority : PublicKey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Remove approval for the transfer of any remaining tokens. Args: account: Account to close. dest: Account to receive the remaining balance of the closed account. authority: Authority which is allowed to close the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _close_account_args ( account , dest , authority , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) create_account ( self , owner , skip_confirmation = False , recent_blockhash = None ) async Create and initialize a new account. This account may then be used as a transfer() or approve() destination. Parameters: Name Type Description Default owner PublicKey User account that will own the new account. required skip_confirmation bool (optional) Option to skip transaction confirmation. False Returns: Type Description PublicKey Public key of the new empty account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py async def create_account ( self , owner : PublicKey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : \"\"\"Create and initialize a new account. This account may then be used as a `transfer()` or `approve()` destination. Args: owner: User account that will own the new account. skip_confirmation: (optional) Option to skip transaction confirmation. Returns: Public key of the new empty account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_account ( self . _conn ) new_account_pk , txn , payer , new_account , opts = self . _create_account_args ( owner , skip_confirmation , balance_needed , self . _conn . commitment ) # Send the two instructions await self . _conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_pk create_associated_token_account ( self , owner , skip_confirmation = False , recent_blockhash = None ) async Create an associated token account. Parameters: Name Type Description Default owner PublicKey User account that will own the associated token account. required skip_confirmation bool (optional) Option to skip transaction confirmation. False Returns: Type Description PublicKey Public key of the new associated account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py async def create_associated_token_account ( self , owner : PublicKey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : \"\"\"Create an associated token account. Args: owner: User account that will own the associated token account. skip_confirmation: (optional) Option to skip transaction confirmation. Returns: Public key of the new associated account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Construct transaction public_key , txn , payer , opts = self . _create_associated_token_account_args ( owner , skip_confirmation , self . _conn . commitment ) await self . _conn . send_transaction ( txn , payer , opts = opts , recent_blockhash = recent_blockhash ) return public_key create_mint ( conn , payer , mint_authority , decimals , program_id , freeze_authority = None , skip_confirmation = False , recent_blockhash = None ) async classmethod Create and initialize a token. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required payer Keypair Fee payer for transaction. required mint_authority PublicKey Account or multisig that will control minting. required decimals int Location of the decimal place. required program_id PublicKey SPL Token program account. required freeze_authority Optional[PublicKey] (optional) Account or multisig that can freeze token accounts. None skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description AsyncToken Token object for the newly minted token. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py @classmethod async def create_mint ( cls , conn : AsyncClient , payer : Keypair , mint_authority : PublicKey , decimals : int , program_id : PublicKey , freeze_authority : Optional [ PublicKey ] = None , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> AsyncToken : \"\"\"Create and initialize a token. Args: conn: RPC connection to a solana cluster. payer: Fee payer for transaction. mint_authority: Account or multisig that will control minting. decimals: Location of the decimal place. program_id: SPL Token program account. freeze_authority: (optional) Account or multisig that can freeze token accounts. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Token object for the newly minted token. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_mint ( conn ) # Construct transaction token , txn , payer , mint_account , opts = _TokenCore . _create_mint_args ( conn , payer , mint_authority , decimals , program_id , freeze_authority , skip_confirmation , balance_needed , cls , conn . commitment , ) # Send the two instructions await conn . send_transaction ( txn , payer , mint_account , opts = opts , recent_blockhash = recent_blockhash ) return cast ( AsyncToken , token ) create_multisig ( self , m , multi_signers , opts = None , recent_blockhash = None ) async Create and initialize a new multisig. Parameters: Name Type Description Default m int Number of required signatures. required multi_signers List[PublicKey] Full set of signers. required opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description PublicKey Public key of the new multisig account. Source code in spl/token/async_client.py async def create_multisig ( self , m : int , multi_signers : List [ PublicKey ], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : # pylint: disable=invalid-name \"\"\"Create and initialize a new multisig. Args: m: Number of required signatures. multi_signers: Full set of signers. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new multisig account. \"\"\" balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_multisig ( self . _conn ) txn , payer , multisig = self . _create_multisig_args ( m , multi_signers , balance_needed ) opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts await self . _conn . send_transaction ( txn , payer , multisig , opts = opts_to_use , recent_blockhash = recent_blockhash ) return multisig . public_key create_wrapped_native_account ( conn , program_id , owner , payer , amount , skip_confirmation = False , recent_blockhash = None ) async staticmethod Create and initialize a new account on the special native token mint. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required program_id PublicKey SPL Token program account. required owner PublicKey The owner of the new token account. required payer Keypair The source of the lamports to initialize, and payer of the initialization fees. required amount int The amount of lamports to wrap. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description PublicKey The new token account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py @staticmethod async def create_wrapped_native_account ( conn : AsyncClient , program_id : PublicKey , owner : PublicKey , payer : Keypair , amount : int , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : \"\"\"Create and initialize a new account on the special native token mint. Args: conn: RPC connection to a solana cluster. program_id: SPL Token program account. owner: The owner of the new token account. payer: The source of the lamports to initialize, and payer of the initialization fees. amount: The amount of lamports to wrap. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: The new token account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_account ( conn ) new_account_public_key , txn , payer , new_account , opts = _TokenCore . _create_wrapped_native_account_args ( program_id , owner , payer , amount , skip_confirmation , balance_needed , conn . commitment ) await conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_public_key freeze_account ( self , account , authority , multi_signers = None , opts = None , recent_blockhash = None ) async Freeze account. Parameters: Name Type Description Default account PublicKey Account to freeze. required authority PublicKey The mint freeze authority. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if authority is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def freeze_account ( self , account : PublicKey , authority : PublicKey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Freeze account. Args: account: Account to freeze. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _freeze_account_args ( account , authority , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) get_account_info ( self , account , commitment = None ) async Retrieve account information. Source code in spl/token/async_client.py async def get_account_info ( self , account : PublicKey , commitment : Optional [ Commitment ] = None ) -> AccountInfo : \"\"\"Retrieve account information.\"\"\" info = await self . _conn . get_account_info ( account , commitment ) return self . _create_account_info ( info ) get_accounts ( self , owner , is_delegate = False , commitment = None , encoding = 'jsonParsed' ) async Get token accounts of the provided owner by the token's mint. Parameters: Name Type Description Default owner PublicKey Public Key of the token account owner. required is_delegate bool (optional) Flag specifying if the owner public key is a delegate. False encoding str (optional) Encoding for Account data, either \"base58\" (slow), \"base64\" or jsonParsed\". 'jsonParsed' commitment Optional[Commitment] (optional) Bank state to query. None Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. Source code in spl/token/async_client.py async def get_accounts ( self , owner : PublicKey , is_delegate : bool = False , commitment : Optional [ Commitment ] = None , encoding : str = \"jsonParsed\" , ) -> RPCResponse : \"\"\"Get token accounts of the provided owner by the token's mint. Args: owner: Public Key of the token account owner. is_delegate: (optional) Flag specifying if the `owner` public key is a delegate. encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\" or jsonParsed\". commitment: (optional) Bank state to query. Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment # pylint: disable=protected-access ) return ( await self . _conn . get_token_accounts_by_delegate ( * args ) if is_delegate else await self . _conn . get_token_accounts_by_owner ( * args ) ) get_balance ( self , pubkey , commitment = None ) async Get the balance of the provided token account. Parameters: Name Type Description Default pubkey PublicKey Public Key of the token account. required commitment Optional[Commitment] (optional) Bank state to query. None Source code in spl/token/async_client.py async def get_balance ( self , pubkey : PublicKey , commitment : Optional [ Commitment ] = None ) -> RPCResponse : \"\"\"Get the balance of the provided token account. Args: pubkey: Public Key of the token account. commitment: (optional) Bank state to query. \"\"\" return await self . _conn . get_token_account_balance ( pubkey , commitment ) get_min_balance_rent_for_exempt_for_account ( conn ) async staticmethod Get the minimum balance for the account to be rent exempt. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/async_client.py @staticmethod async def get_min_balance_rent_for_exempt_for_account ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the account to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( ACCOUNT_LAYOUT . sizeof ()) return resp [ \"result\" ] get_min_balance_rent_for_exempt_for_mint ( conn ) async staticmethod Get the minimum balance for the mint to be rent exempt. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/async_client.py @staticmethod async def get_min_balance_rent_for_exempt_for_mint ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the mint to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( MINT_LAYOUT . sizeof ()) return resp [ \"result\" ] get_min_balance_rent_for_exempt_for_multisig ( conn ) async staticmethod Get the minimum balance for the multisig to be rent exempt. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/async_client.py @staticmethod async def get_min_balance_rent_for_exempt_for_multisig ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the multisig to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( MULTISIG_LAYOUT . sizeof ()) return resp [ \"result\" ] get_mint_info ( self ) async Retrieve mint information. Source code in spl/token/async_client.py async def get_mint_info ( self ) -> MintInfo : \"\"\"Retrieve mint information.\"\"\" info = await self . _conn . get_account_info ( self . pubkey ) return self . _create_mint_info ( info ) mint_to ( self , dest , mint_authority , amount , multi_signers = None , opts = None , recent_blockhash = None ) async Mint new tokens. Parameters: Name Type Description Default dest PublicKey Public key of the account to mint to. required mint_authority Union[Keypair, PublicKey] Public key of the minting authority. required amount int Amount to mint. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multisig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py async def mint_to ( self , dest : PublicKey , mint_authority : Union [ Keypair , PublicKey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Mint new tokens. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_args ( dest , mint_authority , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) mint_to_checked ( self , dest , mint_authority , amount , decimals , multi_signers = None , opts = None , recent_blockhash = None ) async Mint new tokens, asserting the token mint and decimals. Parameters: Name Type Description Default dest PublicKey Public key of the account to mint to. required mint_authority PublicKey Public key of the minting authority. required amount int Amount to mint. required decimals int Number of decimals in amount to mint. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash optional A prefetched blockhash for the transaction. None Source code in spl/token/async_client.py async def mint_to_checked ( self , dest : PublicKey , mint_authority : PublicKey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Mint new tokens, asserting the token mint and decimals. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. decimals: Number of decimals in amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash (optional): A prefetched blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_checked_args ( dest , mint_authority , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) revoke ( self , account , owner , multi_signers = None , opts = None , recent_blockhash = None ) async Revoke transfer authority for a given account. Parameters: Name Type Description Default account PublicKey Source account for which transfer authority is being revoked. required owner PublicKey Owner of the source account. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multisig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def revoke ( self , account : PublicKey , owner : PublicKey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Revoke transfer authority for a given account. Args: account: Source account for which transfer authority is being revoked. owner: Owner of the source account. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _revoke_args ( account , owner , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) set_authority ( self , account , current_authority , authority_type , new_authority = None , multi_signers = None , opts = None , recent_blockhash = None ) async Assign a new authority to the account. Parameters: Name Type Description Default account PublicKey Public key of the token account. required current_authority Union[Keypair, PublicKey] Current authority of the account. required authority_type spl_token.AuthorityType Type of authority to set. required new_authority Optional[PublicKey] (optional) New authority of the account. None multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def set_authority ( self , account : PublicKey , current_authority : Union [ Keypair , PublicKey ], authority_type : spl_token . AuthorityType , new_authority : Optional [ PublicKey ] = None , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Assign a new authority to the account. Args: account: Public key of the token account. current_authority: Current authority of the account. authority_type: Type of authority to set. new_authority: (optional) New authority of the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _set_authority_args ( account , current_authority , authority_type , new_authority , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) thaw_account ( self , account , authority , multi_signers = None , opts = None , recent_blockhash = None ) async Thaw account. Parameters: Name Type Description Default account PublicKey Account to thaw. required authority PublicKey The mint freeze authority. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if authority is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def thaw_account ( self , account : PublicKey , authority : PublicKey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Thaw account. Args: account: Account to thaw. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _thaw_account_args ( account , authority , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) transfer ( self , source , dest , owner , amount , multi_signers = None , opts = None , recent_blockhash = None ) async Transfer tokens to another account. Parameters: Name Type Description Default source PublicKey Public key of account to transfer tokens from. required dest PublicKey Public key of account to transfer tokens to. required owner Union[Keypair, PublicKey] Owner of the source account. required amount int Number of tokens to transfer. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def transfer ( self , source : PublicKey , dest : PublicKey , owner : Union [ Keypair , PublicKey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Transfer tokens to another account. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_args ( source , dest , owner , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) transfer_checked ( self , source , dest , owner , amount , decimals , multi_signers , opts = None , recent_blockhash = None ) async Transfer tokens to another account, asserting the token mint and decimals. Parameters: Name Type Description Default source PublicKey Public key of account to transfer tokens from. required dest PublicKey Public key of account to transfer tokens to. required owner PublicKey Owner of the source account. required amount int Number of tokens to transfer. required decimals int Number of decimals in transfer amount. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. required opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def transfer_checked ( self , source : PublicKey , dest : PublicKey , owner : PublicKey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Transfer tokens to another account, asserting the token mint and decimals. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. decimals: Number of decimals in transfer amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_checked_args ( source , dest , owner , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"Async Client"},{"location":"spl/token/async_client/#async-client","text":"","title":"Async Client"},{"location":"spl/token/async_client/#spl.token.async_client","text":"Async SPL Token program client.","title":"async_client"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken","text":"An ERC20-like Token. Source code in spl/token/async_client.py class AsyncToken ( _TokenCore ): # pylint: disable=too-many-public-methods \"\"\"An ERC20-like Token.\"\"\" def __init__ ( self , conn : AsyncClient , pubkey : PublicKey , program_id : PublicKey , payer : Keypair ) -> None : \"\"\"Initialize a client to a SPL-Token program.\"\"\" super () . __init__ ( pubkey , program_id , payer ) self . _conn = conn @staticmethod async def get_min_balance_rent_for_exempt_for_account ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the account to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( ACCOUNT_LAYOUT . sizeof ()) return resp [ \"result\" ] @staticmethod async def get_min_balance_rent_for_exempt_for_mint ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the mint to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( MINT_LAYOUT . sizeof ()) return resp [ \"result\" ] @staticmethod async def get_min_balance_rent_for_exempt_for_multisig ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the multisig to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( MULTISIG_LAYOUT . sizeof ()) return resp [ \"result\" ] async def get_accounts ( self , owner : PublicKey , is_delegate : bool = False , commitment : Optional [ Commitment ] = None , encoding : str = \"jsonParsed\" , ) -> RPCResponse : \"\"\"Get token accounts of the provided owner by the token's mint. Args: owner: Public Key of the token account owner. is_delegate: (optional) Flag specifying if the `owner` public key is a delegate. encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\" or jsonParsed\". commitment: (optional) Bank state to query. Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment # pylint: disable=protected-access ) return ( await self . _conn . get_token_accounts_by_delegate ( * args ) if is_delegate else await self . _conn . get_token_accounts_by_owner ( * args ) ) async def get_balance ( self , pubkey : PublicKey , commitment : Optional [ Commitment ] = None ) -> RPCResponse : \"\"\"Get the balance of the provided token account. Args: pubkey: Public Key of the token account. commitment: (optional) Bank state to query. \"\"\" return await self . _conn . get_token_account_balance ( pubkey , commitment ) @classmethod async def create_mint ( cls , conn : AsyncClient , payer : Keypair , mint_authority : PublicKey , decimals : int , program_id : PublicKey , freeze_authority : Optional [ PublicKey ] = None , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> AsyncToken : \"\"\"Create and initialize a token. Args: conn: RPC connection to a solana cluster. payer: Fee payer for transaction. mint_authority: Account or multisig that will control minting. decimals: Location of the decimal place. program_id: SPL Token program account. freeze_authority: (optional) Account or multisig that can freeze token accounts. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Token object for the newly minted token. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_mint ( conn ) # Construct transaction token , txn , payer , mint_account , opts = _TokenCore . _create_mint_args ( conn , payer , mint_authority , decimals , program_id , freeze_authority , skip_confirmation , balance_needed , cls , conn . commitment , ) # Send the two instructions await conn . send_transaction ( txn , payer , mint_account , opts = opts , recent_blockhash = recent_blockhash ) return cast ( AsyncToken , token ) async def create_account ( self , owner : PublicKey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : \"\"\"Create and initialize a new account. This account may then be used as a `transfer()` or `approve()` destination. Args: owner: User account that will own the new account. skip_confirmation: (optional) Option to skip transaction confirmation. Returns: Public key of the new empty account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_account ( self . _conn ) new_account_pk , txn , payer , new_account , opts = self . _create_account_args ( owner , skip_confirmation , balance_needed , self . _conn . commitment ) # Send the two instructions await self . _conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_pk async def create_associated_token_account ( self , owner : PublicKey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : \"\"\"Create an associated token account. Args: owner: User account that will own the associated token account. skip_confirmation: (optional) Option to skip transaction confirmation. Returns: Public key of the new associated account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Construct transaction public_key , txn , payer , opts = self . _create_associated_token_account_args ( owner , skip_confirmation , self . _conn . commitment ) await self . _conn . send_transaction ( txn , payer , opts = opts , recent_blockhash = recent_blockhash ) return public_key @staticmethod async def create_wrapped_native_account ( conn : AsyncClient , program_id : PublicKey , owner : PublicKey , payer : Keypair , amount : int , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : \"\"\"Create and initialize a new account on the special native token mint. Args: conn: RPC connection to a solana cluster. program_id: SPL Token program account. owner: The owner of the new token account. payer: The source of the lamports to initialize, and payer of the initialization fees. amount: The amount of lamports to wrap. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: The new token account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_account ( conn ) new_account_public_key , txn , payer , new_account , opts = _TokenCore . _create_wrapped_native_account_args ( program_id , owner , payer , amount , skip_confirmation , balance_needed , conn . commitment ) await conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_public_key async def create_multisig ( self , m : int , multi_signers : List [ PublicKey ], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : # pylint: disable=invalid-name \"\"\"Create and initialize a new multisig. Args: m: Number of required signatures. multi_signers: Full set of signers. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new multisig account. \"\"\" balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_multisig ( self . _conn ) txn , payer , multisig = self . _create_multisig_args ( m , multi_signers , balance_needed ) opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts await self . _conn . send_transaction ( txn , payer , multisig , opts = opts_to_use , recent_blockhash = recent_blockhash ) return multisig . public_key async def get_mint_info ( self ) -> MintInfo : \"\"\"Retrieve mint information.\"\"\" info = await self . _conn . get_account_info ( self . pubkey ) return self . _create_mint_info ( info ) async def get_account_info ( self , account : PublicKey , commitment : Optional [ Commitment ] = None ) -> AccountInfo : \"\"\"Retrieve account information.\"\"\" info = await self . _conn . get_account_info ( account , commitment ) return self . _create_account_info ( info ) async def transfer ( self , source : PublicKey , dest : PublicKey , owner : Union [ Keypair , PublicKey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Transfer tokens to another account. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_args ( source , dest , owner , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def approve ( self , source : PublicKey , delegate : PublicKey , owner : PublicKey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_args ( source , delegate , owner , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def revoke ( self , account : PublicKey , owner : PublicKey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Revoke transfer authority for a given account. Args: account: Source account for which transfer authority is being revoked. owner: Owner of the source account. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _revoke_args ( account , owner , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def set_authority ( self , account : PublicKey , current_authority : Union [ Keypair , PublicKey ], authority_type : spl_token . AuthorityType , new_authority : Optional [ PublicKey ] = None , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Assign a new authority to the account. Args: account: Public key of the token account. current_authority: Current authority of the account. authority_type: Type of authority to set. new_authority: (optional) New authority of the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _set_authority_args ( account , current_authority , authority_type , new_authority , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def mint_to ( self , dest : PublicKey , mint_authority : Union [ Keypair , PublicKey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Mint new tokens. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_args ( dest , mint_authority , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def burn ( self , account : PublicKey , owner : PublicKey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Burn tokens. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_args ( account , owner , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def close_account ( self , account : PublicKey , dest : PublicKey , authority : PublicKey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Remove approval for the transfer of any remaining tokens. Args: account: Account to close. dest: Account to receive the remaining balance of the closed account. authority: Authority which is allowed to close the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _close_account_args ( account , dest , authority , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def freeze_account ( self , account : PublicKey , authority : PublicKey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Freeze account. Args: account: Account to freeze. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _freeze_account_args ( account , authority , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def thaw_account ( self , account : PublicKey , authority : PublicKey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Thaw account. Args: account: Account to thaw. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _thaw_account_args ( account , authority , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def transfer_checked ( self , source : PublicKey , dest : PublicKey , owner : PublicKey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Transfer tokens to another account, asserting the token mint and decimals. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. decimals: Number of decimals in transfer amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_checked_args ( source , dest , owner , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def approve_checked ( self , source : PublicKey , delegate : PublicKey , owner : PublicKey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. decimals: Number of decimals in approve amount. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash (optional): A prefetched blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_checked_args ( source , delegate , owner , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def mint_to_checked ( self , dest : PublicKey , mint_authority : PublicKey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Mint new tokens, asserting the token mint and decimals. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. decimals: Number of decimals in amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash (optional): A prefetched blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_checked_args ( dest , mint_authority , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def burn_checked ( self , account : PublicKey , owner : PublicKey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Burn tokens, asserting the token mint and decimals. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. decimals: Number of decimals in amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_checked_args ( account , owner , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"AsyncToken"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.approve","text":"Grant a third-party permission to transfer up the specified number of tokens from an account. Parameters: Name Type Description Default source PublicKey Public key of the source account. required delegate PublicKey Account authorized to perform a transfer tokens from the source account. required owner PublicKey Owner of the source account. required amount int Maximum number of tokens the delegate may transfer. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def approve ( self , source : PublicKey , delegate : PublicKey , owner : PublicKey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_args ( source , delegate , owner , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"approve()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.approve_checked","text":"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Parameters: Name Type Description Default source PublicKey Public key of the source account. required delegate PublicKey Account authorized to perform a transfer tokens from the source account. required owner PublicKey Owner of the source account. required amount int Maximum number of tokens the delegate may transfer. required decimals int Number of decimals in approve amount. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multisig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash optional A prefetched blockhash for the transaction. None Source code in spl/token/async_client.py async def approve_checked ( self , source : PublicKey , delegate : PublicKey , owner : PublicKey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. decimals: Number of decimals in approve amount. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash (optional): A prefetched blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_checked_args ( source , delegate , owner , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"approve_checked()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.burn","text":"Burn tokens. Parameters: Name Type Description Default account PublicKey Account to burn tokens from. required owner PublicKey Owner of the account. required amount int Amount to burn. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def burn ( self , account : PublicKey , owner : PublicKey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Burn tokens. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_args ( account , owner , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"burn()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.burn_checked","text":"Burn tokens, asserting the token mint and decimals. Parameters: Name Type Description Default account PublicKey Account to burn tokens from. required owner PublicKey Owner of the account. required amount int Amount to burn. required decimals int Number of decimals in amount to burn. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multisig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def burn_checked ( self , account : PublicKey , owner : PublicKey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Burn tokens, asserting the token mint and decimals. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. decimals: Number of decimals in amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_checked_args ( account , owner , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"burn_checked()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.close_account","text":"Remove approval for the transfer of any remaining tokens. Parameters: Name Type Description Default account PublicKey Account to close. required dest PublicKey Account to receive the remaining balance of the closed account. required authority PublicKey Authority which is allowed to close the account. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def close_account ( self , account : PublicKey , dest : PublicKey , authority : PublicKey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Remove approval for the transfer of any remaining tokens. Args: account: Account to close. dest: Account to receive the remaining balance of the closed account. authority: Authority which is allowed to close the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _close_account_args ( account , dest , authority , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"close_account()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.create_account","text":"Create and initialize a new account. This account may then be used as a transfer() or approve() destination. Parameters: Name Type Description Default owner PublicKey User account that will own the new account. required skip_confirmation bool (optional) Option to skip transaction confirmation. False Returns: Type Description PublicKey Public key of the new empty account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py async def create_account ( self , owner : PublicKey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : \"\"\"Create and initialize a new account. This account may then be used as a `transfer()` or `approve()` destination. Args: owner: User account that will own the new account. skip_confirmation: (optional) Option to skip transaction confirmation. Returns: Public key of the new empty account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_account ( self . _conn ) new_account_pk , txn , payer , new_account , opts = self . _create_account_args ( owner , skip_confirmation , balance_needed , self . _conn . commitment ) # Send the two instructions await self . _conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_pk","title":"create_account()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.create_associated_token_account","text":"Create an associated token account. Parameters: Name Type Description Default owner PublicKey User account that will own the associated token account. required skip_confirmation bool (optional) Option to skip transaction confirmation. False Returns: Type Description PublicKey Public key of the new associated account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py async def create_associated_token_account ( self , owner : PublicKey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : \"\"\"Create an associated token account. Args: owner: User account that will own the associated token account. skip_confirmation: (optional) Option to skip transaction confirmation. Returns: Public key of the new associated account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Construct transaction public_key , txn , payer , opts = self . _create_associated_token_account_args ( owner , skip_confirmation , self . _conn . commitment ) await self . _conn . send_transaction ( txn , payer , opts = opts , recent_blockhash = recent_blockhash ) return public_key","title":"create_associated_token_account()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.create_mint","text":"Create and initialize a token. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required payer Keypair Fee payer for transaction. required mint_authority PublicKey Account or multisig that will control minting. required decimals int Location of the decimal place. required program_id PublicKey SPL Token program account. required freeze_authority Optional[PublicKey] (optional) Account or multisig that can freeze token accounts. None skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description AsyncToken Token object for the newly minted token. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py @classmethod async def create_mint ( cls , conn : AsyncClient , payer : Keypair , mint_authority : PublicKey , decimals : int , program_id : PublicKey , freeze_authority : Optional [ PublicKey ] = None , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> AsyncToken : \"\"\"Create and initialize a token. Args: conn: RPC connection to a solana cluster. payer: Fee payer for transaction. mint_authority: Account or multisig that will control minting. decimals: Location of the decimal place. program_id: SPL Token program account. freeze_authority: (optional) Account or multisig that can freeze token accounts. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Token object for the newly minted token. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_mint ( conn ) # Construct transaction token , txn , payer , mint_account , opts = _TokenCore . _create_mint_args ( conn , payer , mint_authority , decimals , program_id , freeze_authority , skip_confirmation , balance_needed , cls , conn . commitment , ) # Send the two instructions await conn . send_transaction ( txn , payer , mint_account , opts = opts , recent_blockhash = recent_blockhash ) return cast ( AsyncToken , token )","title":"create_mint()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.create_multisig","text":"Create and initialize a new multisig. Parameters: Name Type Description Default m int Number of required signatures. required multi_signers List[PublicKey] Full set of signers. required opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description PublicKey Public key of the new multisig account. Source code in spl/token/async_client.py async def create_multisig ( self , m : int , multi_signers : List [ PublicKey ], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : # pylint: disable=invalid-name \"\"\"Create and initialize a new multisig. Args: m: Number of required signatures. multi_signers: Full set of signers. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new multisig account. \"\"\" balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_multisig ( self . _conn ) txn , payer , multisig = self . _create_multisig_args ( m , multi_signers , balance_needed ) opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts await self . _conn . send_transaction ( txn , payer , multisig , opts = opts_to_use , recent_blockhash = recent_blockhash ) return multisig . public_key","title":"create_multisig()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.create_wrapped_native_account","text":"Create and initialize a new account on the special native token mint. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required program_id PublicKey SPL Token program account. required owner PublicKey The owner of the new token account. required payer Keypair The source of the lamports to initialize, and payer of the initialization fees. required amount int The amount of lamports to wrap. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description PublicKey The new token account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py @staticmethod async def create_wrapped_native_account ( conn : AsyncClient , program_id : PublicKey , owner : PublicKey , payer : Keypair , amount : int , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : \"\"\"Create and initialize a new account on the special native token mint. Args: conn: RPC connection to a solana cluster. program_id: SPL Token program account. owner: The owner of the new token account. payer: The source of the lamports to initialize, and payer of the initialization fees. amount: The amount of lamports to wrap. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: The new token account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_account ( conn ) new_account_public_key , txn , payer , new_account , opts = _TokenCore . _create_wrapped_native_account_args ( program_id , owner , payer , amount , skip_confirmation , balance_needed , conn . commitment ) await conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_public_key","title":"create_wrapped_native_account()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.freeze_account","text":"Freeze account. Parameters: Name Type Description Default account PublicKey Account to freeze. required authority PublicKey The mint freeze authority. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if authority is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def freeze_account ( self , account : PublicKey , authority : PublicKey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Freeze account. Args: account: Account to freeze. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _freeze_account_args ( account , authority , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"freeze_account()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.get_account_info","text":"Retrieve account information. Source code in spl/token/async_client.py async def get_account_info ( self , account : PublicKey , commitment : Optional [ Commitment ] = None ) -> AccountInfo : \"\"\"Retrieve account information.\"\"\" info = await self . _conn . get_account_info ( account , commitment ) return self . _create_account_info ( info )","title":"get_account_info()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.get_accounts","text":"Get token accounts of the provided owner by the token's mint. Parameters: Name Type Description Default owner PublicKey Public Key of the token account owner. required is_delegate bool (optional) Flag specifying if the owner public key is a delegate. False encoding str (optional) Encoding for Account data, either \"base58\" (slow), \"base64\" or jsonParsed\". 'jsonParsed' commitment Optional[Commitment] (optional) Bank state to query. None Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. Source code in spl/token/async_client.py async def get_accounts ( self , owner : PublicKey , is_delegate : bool = False , commitment : Optional [ Commitment ] = None , encoding : str = \"jsonParsed\" , ) -> RPCResponse : \"\"\"Get token accounts of the provided owner by the token's mint. Args: owner: Public Key of the token account owner. is_delegate: (optional) Flag specifying if the `owner` public key is a delegate. encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\" or jsonParsed\". commitment: (optional) Bank state to query. Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment # pylint: disable=protected-access ) return ( await self . _conn . get_token_accounts_by_delegate ( * args ) if is_delegate else await self . _conn . get_token_accounts_by_owner ( * args ) )","title":"get_accounts()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.get_balance","text":"Get the balance of the provided token account. Parameters: Name Type Description Default pubkey PublicKey Public Key of the token account. required commitment Optional[Commitment] (optional) Bank state to query. None Source code in spl/token/async_client.py async def get_balance ( self , pubkey : PublicKey , commitment : Optional [ Commitment ] = None ) -> RPCResponse : \"\"\"Get the balance of the provided token account. Args: pubkey: Public Key of the token account. commitment: (optional) Bank state to query. \"\"\" return await self . _conn . get_token_account_balance ( pubkey , commitment )","title":"get_balance()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.get_min_balance_rent_for_exempt_for_account","text":"Get the minimum balance for the account to be rent exempt. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/async_client.py @staticmethod async def get_min_balance_rent_for_exempt_for_account ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the account to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( ACCOUNT_LAYOUT . sizeof ()) return resp [ \"result\" ]","title":"get_min_balance_rent_for_exempt_for_account()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.get_min_balance_rent_for_exempt_for_mint","text":"Get the minimum balance for the mint to be rent exempt. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/async_client.py @staticmethod async def get_min_balance_rent_for_exempt_for_mint ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the mint to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( MINT_LAYOUT . sizeof ()) return resp [ \"result\" ]","title":"get_min_balance_rent_for_exempt_for_mint()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.get_min_balance_rent_for_exempt_for_multisig","text":"Get the minimum balance for the multisig to be rent exempt. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/async_client.py @staticmethod async def get_min_balance_rent_for_exempt_for_multisig ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the multisig to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( MULTISIG_LAYOUT . sizeof ()) return resp [ \"result\" ]","title":"get_min_balance_rent_for_exempt_for_multisig()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.get_mint_info","text":"Retrieve mint information. Source code in spl/token/async_client.py async def get_mint_info ( self ) -> MintInfo : \"\"\"Retrieve mint information.\"\"\" info = await self . _conn . get_account_info ( self . pubkey ) return self . _create_mint_info ( info )","title":"get_mint_info()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.mint_to","text":"Mint new tokens. Parameters: Name Type Description Default dest PublicKey Public key of the account to mint to. required mint_authority Union[Keypair, PublicKey] Public key of the minting authority. required amount int Amount to mint. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multisig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py async def mint_to ( self , dest : PublicKey , mint_authority : Union [ Keypair , PublicKey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Mint new tokens. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_args ( dest , mint_authority , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"mint_to()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.mint_to_checked","text":"Mint new tokens, asserting the token mint and decimals. Parameters: Name Type Description Default dest PublicKey Public key of the account to mint to. required mint_authority PublicKey Public key of the minting authority. required amount int Amount to mint. required decimals int Number of decimals in amount to mint. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash optional A prefetched blockhash for the transaction. None Source code in spl/token/async_client.py async def mint_to_checked ( self , dest : PublicKey , mint_authority : PublicKey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Mint new tokens, asserting the token mint and decimals. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. decimals: Number of decimals in amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash (optional): A prefetched blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_checked_args ( dest , mint_authority , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"mint_to_checked()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.revoke","text":"Revoke transfer authority for a given account. Parameters: Name Type Description Default account PublicKey Source account for which transfer authority is being revoked. required owner PublicKey Owner of the source account. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multisig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def revoke ( self , account : PublicKey , owner : PublicKey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Revoke transfer authority for a given account. Args: account: Source account for which transfer authority is being revoked. owner: Owner of the source account. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _revoke_args ( account , owner , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"revoke()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.set_authority","text":"Assign a new authority to the account. Parameters: Name Type Description Default account PublicKey Public key of the token account. required current_authority Union[Keypair, PublicKey] Current authority of the account. required authority_type spl_token.AuthorityType Type of authority to set. required new_authority Optional[PublicKey] (optional) New authority of the account. None multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def set_authority ( self , account : PublicKey , current_authority : Union [ Keypair , PublicKey ], authority_type : spl_token . AuthorityType , new_authority : Optional [ PublicKey ] = None , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Assign a new authority to the account. Args: account: Public key of the token account. current_authority: Current authority of the account. authority_type: Type of authority to set. new_authority: (optional) New authority of the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _set_authority_args ( account , current_authority , authority_type , new_authority , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"set_authority()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.thaw_account","text":"Thaw account. Parameters: Name Type Description Default account PublicKey Account to thaw. required authority PublicKey The mint freeze authority. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if authority is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def thaw_account ( self , account : PublicKey , authority : PublicKey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Thaw account. Args: account: Account to thaw. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _thaw_account_args ( account , authority , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"thaw_account()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.transfer","text":"Transfer tokens to another account. Parameters: Name Type Description Default source PublicKey Public key of account to transfer tokens from. required dest PublicKey Public key of account to transfer tokens to. required owner Union[Keypair, PublicKey] Owner of the source account. required amount int Number of tokens to transfer. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def transfer ( self , source : PublicKey , dest : PublicKey , owner : Union [ Keypair , PublicKey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Transfer tokens to another account. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_args ( source , dest , owner , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"transfer()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.transfer_checked","text":"Transfer tokens to another account, asserting the token mint and decimals. Parameters: Name Type Description Default source PublicKey Public key of account to transfer tokens from. required dest PublicKey Public key of account to transfer tokens to. required owner PublicKey Owner of the source account. required amount int Number of tokens to transfer. required decimals int Number of decimals in transfer amount. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. required opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def transfer_checked ( self , source : PublicKey , dest : PublicKey , owner : PublicKey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Transfer tokens to another account, asserting the token mint and decimals. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. decimals: Number of decimals in transfer amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_checked_args ( source , dest , owner , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"transfer_checked()"},{"location":"spl/token/client/","text":"Client spl.token.client SPL Token program client. Token An ERC20-like Token. Source code in spl/token/client.py class Token ( _TokenCore ): # pylint: disable=too-many-public-methods \"\"\"An ERC20-like Token.\"\"\" def __init__ ( self , conn : Client , pubkey : PublicKey , program_id : PublicKey , payer : Keypair ) -> None : \"\"\"Initialize a client to a SPL-Token program.\"\"\" super () . __init__ ( pubkey , program_id , payer ) self . _conn = conn @staticmethod def get_min_balance_rent_for_exempt_for_account ( conn : Client ) -> int : \"\"\"Get the minimum balance for the account to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( ACCOUNT_LAYOUT . sizeof ()) return resp [ \"result\" ] @staticmethod def get_min_balance_rent_for_exempt_for_mint ( conn : Client ) -> int : \"\"\"Get the minimum balance for the mint to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( MINT_LAYOUT . sizeof ()) return resp [ \"result\" ] @staticmethod def get_min_balance_rent_for_exempt_for_multisig ( conn : Client ) -> int : \"\"\"Get the minimum balance for the multisig to be rent exempt. Args: conn: RPC connection to a solana cluster. Return: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( MULTISIG_LAYOUT . sizeof ()) return resp [ \"result\" ] def get_accounts ( self , owner : PublicKey , is_delegate : bool = False , commitment : Optional [ Commitment ] = None , encoding : str = \"jsonParsed\" , ) -> RPCResponse : \"\"\"Get token accounts of the provided owner by the token's mint. Args: owner: Public Key of the token account owner. is_delegate: (optional) Flag specifying if the `owner` public key is a delegate. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\" or jsonParsed\". Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment # pylint: disable=protected-access ) return ( self . _conn . get_token_accounts_by_delegate ( * args ) if is_delegate else self . _conn . get_token_accounts_by_owner ( * args ) ) def get_balance ( self , pubkey : PublicKey , commitment : Optional [ Commitment ] = None ) -> RPCResponse : \"\"\"Get the balance of the provided token account. Args: pubkey: Public Key of the token account. commitment: (optional) Bank state to query. \"\"\" return self . _conn . get_token_account_balance ( pubkey , commitment ) @classmethod def create_mint ( cls , conn : Client , payer : Keypair , mint_authority : PublicKey , decimals : int , program_id : PublicKey , freeze_authority : Optional [ PublicKey ] = None , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Token : \"\"\"Create and initialize a token. Args: conn: RPC connection to a solana cluster. payer: Fee payer for transaction. mint_authority: Account or multisig that will control minting. decimals: Location of the decimal place. program_id: SPL Token program account. freeze_authority: (optional) Account or multisig that can freeze token accounts. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Token object for the newly minted token. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = Token . get_min_balance_rent_for_exempt_for_mint ( conn ) # Construct transaction token , txn , payer , mint_account , opts = _TokenCore . _create_mint_args ( conn , payer , mint_authority , decimals , program_id , freeze_authority , skip_confirmation , balance_needed , cls , conn . commitment , ) # Send the two instructions conn . send_transaction ( txn , payer , mint_account , opts = opts , recent_blockhash = recent_blockhash ) return cast ( Token , token ) def create_account ( self , owner : PublicKey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : \"\"\"Create and initialize a new account. This account may then be used as a `transfer()` or `approve()` destination. Args: owner: User account that will own the new account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new empty account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" balance_needed = Token . get_min_balance_rent_for_exempt_for_account ( self . _conn ) new_account_pk , txn , payer , new_account , opts = self . _create_account_args ( owner , skip_confirmation , balance_needed , self . _conn . commitment ) # Send the two instructions self . _conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_pk def create_associated_token_account ( self , owner : PublicKey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : \"\"\"Create an associated token account. Args: owner: User account that will own the associated token account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new associated account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Construct transaction public_key , txn , payer , opts = self . _create_associated_token_account_args ( owner , skip_confirmation , self . _conn . commitment ) self . _conn . send_transaction ( txn , payer , opts = opts , recent_blockhash = recent_blockhash ) return public_key @staticmethod def create_wrapped_native_account ( conn : Client , program_id : PublicKey , owner : PublicKey , payer : Keypair , amount : int , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : \"\"\"Create and initialize a new account on the special native token mint. Args: conn: RPC connection to a solana cluster. program_id: SPL Token program account. owner: The owner of the new token account. payer: The source of the lamports to initialize, and payer of the initialization fees. amount: The amount of lamports to wrap. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: The new token account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = Token . get_min_balance_rent_for_exempt_for_account ( conn ) new_account_public_key , txn , payer , new_account , opts = _TokenCore . _create_wrapped_native_account_args ( program_id , owner , payer , amount , skip_confirmation , balance_needed , conn . commitment ) conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_public_key def create_multisig ( self , m : int , multi_signers : List [ PublicKey ], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : # pylint: disable=invalid-name \"\"\"Create and initialize a new multisig. Args: m: Number of required signatures. multi_signers: Full set of signers. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new multisig account. \"\"\" balance_needed = Token . get_min_balance_rent_for_exempt_for_multisig ( self . _conn ) txn , payer , multisig = self . _create_multisig_args ( m , multi_signers , balance_needed ) opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts self . _conn . send_transaction ( txn , payer , multisig , opts = opts_to_use , recent_blockhash = recent_blockhash ) return multisig . public_key def get_mint_info ( self ) -> MintInfo : \"\"\"Retrieve mint information.\"\"\" info = self . _conn . get_account_info ( self . pubkey ) return self . _create_mint_info ( info ) def get_account_info ( self , account : PublicKey , commitment : Optional [ Commitment ] = None ) -> AccountInfo : \"\"\"Retrieve account information.\"\"\" info = self . _conn . get_account_info ( account , commitment ) return self . _create_account_info ( info ) def transfer ( self , source : PublicKey , dest : PublicKey , owner : Union [ Keypair , PublicKey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Transfer tokens to another account. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_args ( source , dest , owner , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def approve ( self , source : PublicKey , delegate : PublicKey , owner : PublicKey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_args ( source , delegate , owner , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) def revoke ( self , account : PublicKey , owner : PublicKey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Revoke transfer authority for a given account. Args: account: Source account for which transfer authority is being revoked. owner: Owner of the source account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _revoke_args ( account , owner , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) def set_authority ( self , account : PublicKey , current_authority : Union [ Keypair , PublicKey ], authority_type : spl_token . AuthorityType , new_authority : Optional [ PublicKey ] = None , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Assign a new authority to the account. Args: account: Public key of the token account. current_authority: Current authority of the account. authority_type: Type of authority to set. new_authority: (optional) New authority of the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _set_authority_args ( account , current_authority , authority_type , new_authority , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) def mint_to ( self , dest : PublicKey , mint_authority : Union [ Keypair , PublicKey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Mint new tokens. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_args ( dest , mint_authority , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def burn ( self , account : PublicKey , owner : PublicKey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Burn tokens. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_args ( account , owner , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def close_account ( self , account : PublicKey , dest : PublicKey , authority : Union [ Keypair , PublicKey ], multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Remove approval for the transfer of any remaining tokens. Args: account: Account to close. dest: Account to receive the remaining balance of the closed account. authority: Authority which is allowed to close the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _close_account_args ( account , dest , authority , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def freeze_account ( self , account : PublicKey , authority : Union [ PublicKey , Keypair ], multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Freeze account. Args: account: Account to freeze. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _freeze_account_args ( account , authority , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def thaw_account ( self , account : PublicKey , authority : PublicKey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Thaw account. Args: account: Account to thaw. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _thaw_account_args ( account , authority , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def transfer_checked ( self , source : PublicKey , dest : PublicKey , owner : Union [ Keypair , PublicKey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Transfer tokens to another account, asserting the token mint and decimals. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. decimals: Number of decimals in transfer amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_checked_args ( source , dest , owner , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def approve_checked ( self , source : PublicKey , delegate : PublicKey , owner : PublicKey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. decimals: Number of decimals in approve amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_checked_args ( source , delegate , owner , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) def mint_to_checked ( self , dest : PublicKey , mint_authority : Union [ Keypair , PublicKey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Mint new tokens, asserting the token mint and decimals. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. decimals: Number of decimals in amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_checked_args ( dest , mint_authority , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def burn_checked ( self , account : PublicKey , owner : Union [ Keypair , PublicKey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Burn tokens, asserting the token mint and decimals. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. decimals: Number of decimals in amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_checked_args ( account , owner , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) approve ( self , source , delegate , owner , amount , multi_signers = None , opts = None , recent_blockhash = None ) Grant a third-party permission to transfer up the specified number of tokens from an account. Parameters: Name Type Description Default source PublicKey Public key of the source account. required delegate PublicKey Account authorized to perform a transfer tokens from the source account. required owner PublicKey Owner of the source account. required amount int Maximum number of tokens the delegate may transfer. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def approve ( self , source : PublicKey , delegate : PublicKey , owner : PublicKey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_args ( source , delegate , owner , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) approve_checked ( self , source , delegate , owner , amount , decimals , multi_signers = None , opts = None , recent_blockhash = None ) Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Parameters: Name Type Description Default source PublicKey Public key of the source account. required delegate PublicKey Account authorized to perform a transfer tokens from the source account. required owner PublicKey Owner of the source account. required amount int Maximum number of tokens the delegate may transfer. required decimals int Number of decimals in approve amount. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def approve_checked ( self , source : PublicKey , delegate : PublicKey , owner : PublicKey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. decimals: Number of decimals in approve amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_checked_args ( source , delegate , owner , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) burn ( self , account , owner , amount , multi_signers = None , opts = None , recent_blockhash = None ) Burn tokens. Parameters: Name Type Description Default account PublicKey Account to burn tokens from. required owner PublicKey Owner of the account. required amount int Amount to burn. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def burn ( self , account : PublicKey , owner : PublicKey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Burn tokens. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_args ( account , owner , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) burn_checked ( self , account , owner , amount , decimals , multi_signers = None , opts = None , recent_blockhash = None ) Burn tokens, asserting the token mint and decimals. Parameters: Name Type Description Default account PublicKey Account to burn tokens from. required owner Union[Keypair, PublicKey] Owner of the account. required amount int Amount to burn. required decimals int Number of decimals in amount to burn. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def burn_checked ( self , account : PublicKey , owner : Union [ Keypair , PublicKey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Burn tokens, asserting the token mint and decimals. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. decimals: Number of decimals in amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_checked_args ( account , owner , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) close_account ( self , account , dest , authority , multi_signers = None , opts = None , recent_blockhash = None ) Remove approval for the transfer of any remaining tokens. Parameters: Name Type Description Default account PublicKey Account to close. required dest PublicKey Account to receive the remaining balance of the closed account. required authority Union[Keypair, PublicKey] Authority which is allowed to close the account. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def close_account ( self , account : PublicKey , dest : PublicKey , authority : Union [ Keypair , PublicKey ], multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Remove approval for the transfer of any remaining tokens. Args: account: Account to close. dest: Account to receive the remaining balance of the closed account. authority: Authority which is allowed to close the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _close_account_args ( account , dest , authority , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) create_account ( self , owner , skip_confirmation = False , recent_blockhash = None ) Create and initialize a new account. This account may then be used as a transfer() or approve() destination. Parameters: Name Type Description Default owner PublicKey User account that will own the new account. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description PublicKey Public key of the new empty account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py def create_account ( self , owner : PublicKey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : \"\"\"Create and initialize a new account. This account may then be used as a `transfer()` or `approve()` destination. Args: owner: User account that will own the new account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new empty account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" balance_needed = Token . get_min_balance_rent_for_exempt_for_account ( self . _conn ) new_account_pk , txn , payer , new_account , opts = self . _create_account_args ( owner , skip_confirmation , balance_needed , self . _conn . commitment ) # Send the two instructions self . _conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_pk create_associated_token_account ( self , owner , skip_confirmation = False , recent_blockhash = None ) Create an associated token account. Parameters: Name Type Description Default owner PublicKey User account that will own the associated token account. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description PublicKey Public key of the new associated account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py def create_associated_token_account ( self , owner : PublicKey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : \"\"\"Create an associated token account. Args: owner: User account that will own the associated token account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new associated account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Construct transaction public_key , txn , payer , opts = self . _create_associated_token_account_args ( owner , skip_confirmation , self . _conn . commitment ) self . _conn . send_transaction ( txn , payer , opts = opts , recent_blockhash = recent_blockhash ) return public_key create_mint ( conn , payer , mint_authority , decimals , program_id , freeze_authority = None , skip_confirmation = False , recent_blockhash = None ) classmethod Create and initialize a token. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required payer Keypair Fee payer for transaction. required mint_authority PublicKey Account or multisig that will control minting. required decimals int Location of the decimal place. required program_id PublicKey SPL Token program account. required freeze_authority Optional[PublicKey] (optional) Account or multisig that can freeze token accounts. None skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Token Token object for the newly minted token. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py @classmethod def create_mint ( cls , conn : Client , payer : Keypair , mint_authority : PublicKey , decimals : int , program_id : PublicKey , freeze_authority : Optional [ PublicKey ] = None , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Token : \"\"\"Create and initialize a token. Args: conn: RPC connection to a solana cluster. payer: Fee payer for transaction. mint_authority: Account or multisig that will control minting. decimals: Location of the decimal place. program_id: SPL Token program account. freeze_authority: (optional) Account or multisig that can freeze token accounts. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Token object for the newly minted token. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = Token . get_min_balance_rent_for_exempt_for_mint ( conn ) # Construct transaction token , txn , payer , mint_account , opts = _TokenCore . _create_mint_args ( conn , payer , mint_authority , decimals , program_id , freeze_authority , skip_confirmation , balance_needed , cls , conn . commitment , ) # Send the two instructions conn . send_transaction ( txn , payer , mint_account , opts = opts , recent_blockhash = recent_blockhash ) return cast ( Token , token ) create_multisig ( self , m , multi_signers , opts = None , recent_blockhash = None ) Create and initialize a new multisig. Parameters: Name Type Description Default m int Number of required signatures. required multi_signers List[PublicKey] Full set of signers. required recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description PublicKey Public key of the new multisig account. Source code in spl/token/client.py def create_multisig ( self , m : int , multi_signers : List [ PublicKey ], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : # pylint: disable=invalid-name \"\"\"Create and initialize a new multisig. Args: m: Number of required signatures. multi_signers: Full set of signers. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new multisig account. \"\"\" balance_needed = Token . get_min_balance_rent_for_exempt_for_multisig ( self . _conn ) txn , payer , multisig = self . _create_multisig_args ( m , multi_signers , balance_needed ) opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts self . _conn . send_transaction ( txn , payer , multisig , opts = opts_to_use , recent_blockhash = recent_blockhash ) return multisig . public_key create_wrapped_native_account ( conn , program_id , owner , payer , amount , skip_confirmation = False , recent_blockhash = None ) staticmethod Create and initialize a new account on the special native token mint. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required program_id PublicKey SPL Token program account. required owner PublicKey The owner of the new token account. required payer Keypair The source of the lamports to initialize, and payer of the initialization fees. required amount int The amount of lamports to wrap. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description PublicKey The new token account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py @staticmethod def create_wrapped_native_account ( conn : Client , program_id : PublicKey , owner : PublicKey , payer : Keypair , amount : int , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : \"\"\"Create and initialize a new account on the special native token mint. Args: conn: RPC connection to a solana cluster. program_id: SPL Token program account. owner: The owner of the new token account. payer: The source of the lamports to initialize, and payer of the initialization fees. amount: The amount of lamports to wrap. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: The new token account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = Token . get_min_balance_rent_for_exempt_for_account ( conn ) new_account_public_key , txn , payer , new_account , opts = _TokenCore . _create_wrapped_native_account_args ( program_id , owner , payer , amount , skip_confirmation , balance_needed , conn . commitment ) conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_public_key freeze_account ( self , account , authority , multi_signers = None , opts = None , recent_blockhash = None ) Freeze account. Parameters: Name Type Description Default account PublicKey Account to freeze. required authority Union[PublicKey, Keypair] The mint freeze authority. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if authority is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def freeze_account ( self , account : PublicKey , authority : Union [ PublicKey , Keypair ], multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Freeze account. Args: account: Account to freeze. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _freeze_account_args ( account , authority , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) get_account_info ( self , account , commitment = None ) Retrieve account information. Source code in spl/token/client.py def get_account_info ( self , account : PublicKey , commitment : Optional [ Commitment ] = None ) -> AccountInfo : \"\"\"Retrieve account information.\"\"\" info = self . _conn . get_account_info ( account , commitment ) return self . _create_account_info ( info ) get_accounts ( self , owner , is_delegate = False , commitment = None , encoding = 'jsonParsed' ) Get token accounts of the provided owner by the token's mint. Parameters: Name Type Description Default owner PublicKey Public Key of the token account owner. required is_delegate bool (optional) Flag specifying if the owner public key is a delegate. False commitment Optional[Commitment] (optional) Bank state to query. None encoding str (optional) Encoding for Account data, either \"base58\" (slow), \"base64\" or jsonParsed\". 'jsonParsed' Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. Source code in spl/token/client.py def get_accounts ( self , owner : PublicKey , is_delegate : bool = False , commitment : Optional [ Commitment ] = None , encoding : str = \"jsonParsed\" , ) -> RPCResponse : \"\"\"Get token accounts of the provided owner by the token's mint. Args: owner: Public Key of the token account owner. is_delegate: (optional) Flag specifying if the `owner` public key is a delegate. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\" or jsonParsed\". Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment # pylint: disable=protected-access ) return ( self . _conn . get_token_accounts_by_delegate ( * args ) if is_delegate else self . _conn . get_token_accounts_by_owner ( * args ) ) get_balance ( self , pubkey , commitment = None ) Get the balance of the provided token account. Parameters: Name Type Description Default pubkey PublicKey Public Key of the token account. required commitment Optional[Commitment] (optional) Bank state to query. None Source code in spl/token/client.py def get_balance ( self , pubkey : PublicKey , commitment : Optional [ Commitment ] = None ) -> RPCResponse : \"\"\"Get the balance of the provided token account. Args: pubkey: Public Key of the token account. commitment: (optional) Bank state to query. \"\"\" return self . _conn . get_token_account_balance ( pubkey , commitment ) get_min_balance_rent_for_exempt_for_account ( conn ) staticmethod Get the minimum balance for the account to be rent exempt. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/client.py @staticmethod def get_min_balance_rent_for_exempt_for_account ( conn : Client ) -> int : \"\"\"Get the minimum balance for the account to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( ACCOUNT_LAYOUT . sizeof ()) return resp [ \"result\" ] get_min_balance_rent_for_exempt_for_mint ( conn ) staticmethod Get the minimum balance for the mint to be rent exempt. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/client.py @staticmethod def get_min_balance_rent_for_exempt_for_mint ( conn : Client ) -> int : \"\"\"Get the minimum balance for the mint to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( MINT_LAYOUT . sizeof ()) return resp [ \"result\" ] get_min_balance_rent_for_exempt_for_multisig ( conn ) staticmethod Get the minimum balance for the multisig to be rent exempt. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required Source code in spl/token/client.py @staticmethod def get_min_balance_rent_for_exempt_for_multisig ( conn : Client ) -> int : \"\"\"Get the minimum balance for the multisig to be rent exempt. Args: conn: RPC connection to a solana cluster. Return: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( MULTISIG_LAYOUT . sizeof ()) return resp [ \"result\" ] get_mint_info ( self ) Retrieve mint information. Source code in spl/token/client.py def get_mint_info ( self ) -> MintInfo : \"\"\"Retrieve mint information.\"\"\" info = self . _conn . get_account_info ( self . pubkey ) return self . _create_mint_info ( info ) mint_to ( self , dest , mint_authority , amount , multi_signers = None , opts = None , recent_blockhash = None ) Mint new tokens. Parameters: Name Type Description Default dest PublicKey Public key of the account to mint to. required mint_authority Union[Keypair, PublicKey] Public key of the minting authority. required amount int Amount to mint. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py def mint_to ( self , dest : PublicKey , mint_authority : Union [ Keypair , PublicKey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Mint new tokens. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_args ( dest , mint_authority , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) mint_to_checked ( self , dest , mint_authority , amount , decimals , multi_signers = None , opts = None , recent_blockhash = None ) Mint new tokens, asserting the token mint and decimals. Parameters: Name Type Description Default dest PublicKey Public key of the account to mint to. required mint_authority Union[Keypair, PublicKey] Public key of the minting authority. required amount int Amount to mint. required decimals int Number of decimals in amount to mint. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def mint_to_checked ( self , dest : PublicKey , mint_authority : Union [ Keypair , PublicKey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Mint new tokens, asserting the token mint and decimals. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. decimals: Number of decimals in amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_checked_args ( dest , mint_authority , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) revoke ( self , account , owner , multi_signers = None , opts = None , recent_blockhash = None ) Revoke transfer authority for a given account. Parameters: Name Type Description Default account PublicKey Source account for which transfer authority is being revoked. required owner PublicKey Owner of the source account. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def revoke ( self , account : PublicKey , owner : PublicKey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Revoke transfer authority for a given account. Args: account: Source account for which transfer authority is being revoked. owner: Owner of the source account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _revoke_args ( account , owner , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) set_authority ( self , account , current_authority , authority_type , new_authority = None , multi_signers = None , opts = None , recent_blockhash = None ) Assign a new authority to the account. Parameters: Name Type Description Default account PublicKey Public key of the token account. required current_authority Union[Keypair, PublicKey] Current authority of the account. required authority_type spl_token.AuthorityType Type of authority to set. required new_authority Optional[PublicKey] (optional) New authority of the account. None multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def set_authority ( self , account : PublicKey , current_authority : Union [ Keypair , PublicKey ], authority_type : spl_token . AuthorityType , new_authority : Optional [ PublicKey ] = None , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Assign a new authority to the account. Args: account: Public key of the token account. current_authority: Current authority of the account. authority_type: Type of authority to set. new_authority: (optional) New authority of the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _set_authority_args ( account , current_authority , authority_type , new_authority , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) thaw_account ( self , account , authority , multi_signers = None , opts = None , recent_blockhash = None ) Thaw account. Parameters: Name Type Description Default account PublicKey Account to thaw. required authority PublicKey The mint freeze authority. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if authority is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def thaw_account ( self , account : PublicKey , authority : PublicKey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Thaw account. Args: account: Account to thaw. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _thaw_account_args ( account , authority , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) transfer ( self , source , dest , owner , amount , multi_signers = None , opts = None , recent_blockhash = None ) Transfer tokens to another account. Parameters: Name Type Description Default source PublicKey Public key of account to transfer tokens from. required dest PublicKey Public key of account to transfer tokens to. required owner Union[Keypair, PublicKey] Owner of the source account. required amount int Number of tokens to transfer. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def transfer ( self , source : PublicKey , dest : PublicKey , owner : Union [ Keypair , PublicKey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Transfer tokens to another account. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_args ( source , dest , owner , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) transfer_checked ( self , source , dest , owner , amount , decimals , multi_signers = None , opts = None , recent_blockhash = None ) Transfer tokens to another account, asserting the token mint and decimals. Parameters: Name Type Description Default source PublicKey Public key of account to transfer tokens from. required dest PublicKey Public key of account to transfer tokens to. required owner Union[Keypair, PublicKey] Owner of the source account. required amount int Number of tokens to transfer. required decimals int Number of decimals in transfer amount. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def transfer_checked ( self , source : PublicKey , dest : PublicKey , owner : Union [ Keypair , PublicKey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Transfer tokens to another account, asserting the token mint and decimals. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. decimals: Number of decimals in transfer amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_checked_args ( source , dest , owner , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"Client"},{"location":"spl/token/client/#client","text":"","title":"Client"},{"location":"spl/token/client/#spl.token.client","text":"SPL Token program client.","title":"client"},{"location":"spl/token/client/#spl.token.client.Token","text":"An ERC20-like Token. Source code in spl/token/client.py class Token ( _TokenCore ): # pylint: disable=too-many-public-methods \"\"\"An ERC20-like Token.\"\"\" def __init__ ( self , conn : Client , pubkey : PublicKey , program_id : PublicKey , payer : Keypair ) -> None : \"\"\"Initialize a client to a SPL-Token program.\"\"\" super () . __init__ ( pubkey , program_id , payer ) self . _conn = conn @staticmethod def get_min_balance_rent_for_exempt_for_account ( conn : Client ) -> int : \"\"\"Get the minimum balance for the account to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( ACCOUNT_LAYOUT . sizeof ()) return resp [ \"result\" ] @staticmethod def get_min_balance_rent_for_exempt_for_mint ( conn : Client ) -> int : \"\"\"Get the minimum balance for the mint to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( MINT_LAYOUT . sizeof ()) return resp [ \"result\" ] @staticmethod def get_min_balance_rent_for_exempt_for_multisig ( conn : Client ) -> int : \"\"\"Get the minimum balance for the multisig to be rent exempt. Args: conn: RPC connection to a solana cluster. Return: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( MULTISIG_LAYOUT . sizeof ()) return resp [ \"result\" ] def get_accounts ( self , owner : PublicKey , is_delegate : bool = False , commitment : Optional [ Commitment ] = None , encoding : str = \"jsonParsed\" , ) -> RPCResponse : \"\"\"Get token accounts of the provided owner by the token's mint. Args: owner: Public Key of the token account owner. is_delegate: (optional) Flag specifying if the `owner` public key is a delegate. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\" or jsonParsed\". Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment # pylint: disable=protected-access ) return ( self . _conn . get_token_accounts_by_delegate ( * args ) if is_delegate else self . _conn . get_token_accounts_by_owner ( * args ) ) def get_balance ( self , pubkey : PublicKey , commitment : Optional [ Commitment ] = None ) -> RPCResponse : \"\"\"Get the balance of the provided token account. Args: pubkey: Public Key of the token account. commitment: (optional) Bank state to query. \"\"\" return self . _conn . get_token_account_balance ( pubkey , commitment ) @classmethod def create_mint ( cls , conn : Client , payer : Keypair , mint_authority : PublicKey , decimals : int , program_id : PublicKey , freeze_authority : Optional [ PublicKey ] = None , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Token : \"\"\"Create and initialize a token. Args: conn: RPC connection to a solana cluster. payer: Fee payer for transaction. mint_authority: Account or multisig that will control minting. decimals: Location of the decimal place. program_id: SPL Token program account. freeze_authority: (optional) Account or multisig that can freeze token accounts. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Token object for the newly minted token. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = Token . get_min_balance_rent_for_exempt_for_mint ( conn ) # Construct transaction token , txn , payer , mint_account , opts = _TokenCore . _create_mint_args ( conn , payer , mint_authority , decimals , program_id , freeze_authority , skip_confirmation , balance_needed , cls , conn . commitment , ) # Send the two instructions conn . send_transaction ( txn , payer , mint_account , opts = opts , recent_blockhash = recent_blockhash ) return cast ( Token , token ) def create_account ( self , owner : PublicKey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : \"\"\"Create and initialize a new account. This account may then be used as a `transfer()` or `approve()` destination. Args: owner: User account that will own the new account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new empty account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" balance_needed = Token . get_min_balance_rent_for_exempt_for_account ( self . _conn ) new_account_pk , txn , payer , new_account , opts = self . _create_account_args ( owner , skip_confirmation , balance_needed , self . _conn . commitment ) # Send the two instructions self . _conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_pk def create_associated_token_account ( self , owner : PublicKey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : \"\"\"Create an associated token account. Args: owner: User account that will own the associated token account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new associated account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Construct transaction public_key , txn , payer , opts = self . _create_associated_token_account_args ( owner , skip_confirmation , self . _conn . commitment ) self . _conn . send_transaction ( txn , payer , opts = opts , recent_blockhash = recent_blockhash ) return public_key @staticmethod def create_wrapped_native_account ( conn : Client , program_id : PublicKey , owner : PublicKey , payer : Keypair , amount : int , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : \"\"\"Create and initialize a new account on the special native token mint. Args: conn: RPC connection to a solana cluster. program_id: SPL Token program account. owner: The owner of the new token account. payer: The source of the lamports to initialize, and payer of the initialization fees. amount: The amount of lamports to wrap. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: The new token account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = Token . get_min_balance_rent_for_exempt_for_account ( conn ) new_account_public_key , txn , payer , new_account , opts = _TokenCore . _create_wrapped_native_account_args ( program_id , owner , payer , amount , skip_confirmation , balance_needed , conn . commitment ) conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_public_key def create_multisig ( self , m : int , multi_signers : List [ PublicKey ], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : # pylint: disable=invalid-name \"\"\"Create and initialize a new multisig. Args: m: Number of required signatures. multi_signers: Full set of signers. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new multisig account. \"\"\" balance_needed = Token . get_min_balance_rent_for_exempt_for_multisig ( self . _conn ) txn , payer , multisig = self . _create_multisig_args ( m , multi_signers , balance_needed ) opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts self . _conn . send_transaction ( txn , payer , multisig , opts = opts_to_use , recent_blockhash = recent_blockhash ) return multisig . public_key def get_mint_info ( self ) -> MintInfo : \"\"\"Retrieve mint information.\"\"\" info = self . _conn . get_account_info ( self . pubkey ) return self . _create_mint_info ( info ) def get_account_info ( self , account : PublicKey , commitment : Optional [ Commitment ] = None ) -> AccountInfo : \"\"\"Retrieve account information.\"\"\" info = self . _conn . get_account_info ( account , commitment ) return self . _create_account_info ( info ) def transfer ( self , source : PublicKey , dest : PublicKey , owner : Union [ Keypair , PublicKey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Transfer tokens to another account. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_args ( source , dest , owner , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def approve ( self , source : PublicKey , delegate : PublicKey , owner : PublicKey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_args ( source , delegate , owner , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) def revoke ( self , account : PublicKey , owner : PublicKey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Revoke transfer authority for a given account. Args: account: Source account for which transfer authority is being revoked. owner: Owner of the source account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _revoke_args ( account , owner , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) def set_authority ( self , account : PublicKey , current_authority : Union [ Keypair , PublicKey ], authority_type : spl_token . AuthorityType , new_authority : Optional [ PublicKey ] = None , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Assign a new authority to the account. Args: account: Public key of the token account. current_authority: Current authority of the account. authority_type: Type of authority to set. new_authority: (optional) New authority of the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _set_authority_args ( account , current_authority , authority_type , new_authority , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) def mint_to ( self , dest : PublicKey , mint_authority : Union [ Keypair , PublicKey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Mint new tokens. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_args ( dest , mint_authority , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def burn ( self , account : PublicKey , owner : PublicKey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Burn tokens. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_args ( account , owner , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def close_account ( self , account : PublicKey , dest : PublicKey , authority : Union [ Keypair , PublicKey ], multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Remove approval for the transfer of any remaining tokens. Args: account: Account to close. dest: Account to receive the remaining balance of the closed account. authority: Authority which is allowed to close the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _close_account_args ( account , dest , authority , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def freeze_account ( self , account : PublicKey , authority : Union [ PublicKey , Keypair ], multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Freeze account. Args: account: Account to freeze. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _freeze_account_args ( account , authority , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def thaw_account ( self , account : PublicKey , authority : PublicKey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Thaw account. Args: account: Account to thaw. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _thaw_account_args ( account , authority , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def transfer_checked ( self , source : PublicKey , dest : PublicKey , owner : Union [ Keypair , PublicKey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Transfer tokens to another account, asserting the token mint and decimals. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. decimals: Number of decimals in transfer amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_checked_args ( source , dest , owner , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def approve_checked ( self , source : PublicKey , delegate : PublicKey , owner : PublicKey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. decimals: Number of decimals in approve amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_checked_args ( source , delegate , owner , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) def mint_to_checked ( self , dest : PublicKey , mint_authority : Union [ Keypair , PublicKey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Mint new tokens, asserting the token mint and decimals. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. decimals: Number of decimals in amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_checked_args ( dest , mint_authority , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def burn_checked ( self , account : PublicKey , owner : Union [ Keypair , PublicKey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Burn tokens, asserting the token mint and decimals. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. decimals: Number of decimals in amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_checked_args ( account , owner , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"Token"},{"location":"spl/token/client/#spl.token.client.Token.approve","text":"Grant a third-party permission to transfer up the specified number of tokens from an account. Parameters: Name Type Description Default source PublicKey Public key of the source account. required delegate PublicKey Account authorized to perform a transfer tokens from the source account. required owner PublicKey Owner of the source account. required amount int Maximum number of tokens the delegate may transfer. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def approve ( self , source : PublicKey , delegate : PublicKey , owner : PublicKey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_args ( source , delegate , owner , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"approve()"},{"location":"spl/token/client/#spl.token.client.Token.approve_checked","text":"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Parameters: Name Type Description Default source PublicKey Public key of the source account. required delegate PublicKey Account authorized to perform a transfer tokens from the source account. required owner PublicKey Owner of the source account. required amount int Maximum number of tokens the delegate may transfer. required decimals int Number of decimals in approve amount. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def approve_checked ( self , source : PublicKey , delegate : PublicKey , owner : PublicKey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. decimals: Number of decimals in approve amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_checked_args ( source , delegate , owner , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"approve_checked()"},{"location":"spl/token/client/#spl.token.client.Token.burn","text":"Burn tokens. Parameters: Name Type Description Default account PublicKey Account to burn tokens from. required owner PublicKey Owner of the account. required amount int Amount to burn. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def burn ( self , account : PublicKey , owner : PublicKey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Burn tokens. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_args ( account , owner , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"burn()"},{"location":"spl/token/client/#spl.token.client.Token.burn_checked","text":"Burn tokens, asserting the token mint and decimals. Parameters: Name Type Description Default account PublicKey Account to burn tokens from. required owner Union[Keypair, PublicKey] Owner of the account. required amount int Amount to burn. required decimals int Number of decimals in amount to burn. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def burn_checked ( self , account : PublicKey , owner : Union [ Keypair , PublicKey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Burn tokens, asserting the token mint and decimals. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. decimals: Number of decimals in amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_checked_args ( account , owner , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"burn_checked()"},{"location":"spl/token/client/#spl.token.client.Token.close_account","text":"Remove approval for the transfer of any remaining tokens. Parameters: Name Type Description Default account PublicKey Account to close. required dest PublicKey Account to receive the remaining balance of the closed account. required authority Union[Keypair, PublicKey] Authority which is allowed to close the account. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def close_account ( self , account : PublicKey , dest : PublicKey , authority : Union [ Keypair , PublicKey ], multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Remove approval for the transfer of any remaining tokens. Args: account: Account to close. dest: Account to receive the remaining balance of the closed account. authority: Authority which is allowed to close the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _close_account_args ( account , dest , authority , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"close_account()"},{"location":"spl/token/client/#spl.token.client.Token.create_account","text":"Create and initialize a new account. This account may then be used as a transfer() or approve() destination. Parameters: Name Type Description Default owner PublicKey User account that will own the new account. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description PublicKey Public key of the new empty account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py def create_account ( self , owner : PublicKey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : \"\"\"Create and initialize a new account. This account may then be used as a `transfer()` or `approve()` destination. Args: owner: User account that will own the new account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new empty account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" balance_needed = Token . get_min_balance_rent_for_exempt_for_account ( self . _conn ) new_account_pk , txn , payer , new_account , opts = self . _create_account_args ( owner , skip_confirmation , balance_needed , self . _conn . commitment ) # Send the two instructions self . _conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_pk","title":"create_account()"},{"location":"spl/token/client/#spl.token.client.Token.create_associated_token_account","text":"Create an associated token account. Parameters: Name Type Description Default owner PublicKey User account that will own the associated token account. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description PublicKey Public key of the new associated account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py def create_associated_token_account ( self , owner : PublicKey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : \"\"\"Create an associated token account. Args: owner: User account that will own the associated token account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new associated account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Construct transaction public_key , txn , payer , opts = self . _create_associated_token_account_args ( owner , skip_confirmation , self . _conn . commitment ) self . _conn . send_transaction ( txn , payer , opts = opts , recent_blockhash = recent_blockhash ) return public_key","title":"create_associated_token_account()"},{"location":"spl/token/client/#spl.token.client.Token.create_mint","text":"Create and initialize a token. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required payer Keypair Fee payer for transaction. required mint_authority PublicKey Account or multisig that will control minting. required decimals int Location of the decimal place. required program_id PublicKey SPL Token program account. required freeze_authority Optional[PublicKey] (optional) Account or multisig that can freeze token accounts. None skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Token Token object for the newly minted token. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py @classmethod def create_mint ( cls , conn : Client , payer : Keypair , mint_authority : PublicKey , decimals : int , program_id : PublicKey , freeze_authority : Optional [ PublicKey ] = None , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Token : \"\"\"Create and initialize a token. Args: conn: RPC connection to a solana cluster. payer: Fee payer for transaction. mint_authority: Account or multisig that will control minting. decimals: Location of the decimal place. program_id: SPL Token program account. freeze_authority: (optional) Account or multisig that can freeze token accounts. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Token object for the newly minted token. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = Token . get_min_balance_rent_for_exempt_for_mint ( conn ) # Construct transaction token , txn , payer , mint_account , opts = _TokenCore . _create_mint_args ( conn , payer , mint_authority , decimals , program_id , freeze_authority , skip_confirmation , balance_needed , cls , conn . commitment , ) # Send the two instructions conn . send_transaction ( txn , payer , mint_account , opts = opts , recent_blockhash = recent_blockhash ) return cast ( Token , token )","title":"create_mint()"},{"location":"spl/token/client/#spl.token.client.Token.create_multisig","text":"Create and initialize a new multisig. Parameters: Name Type Description Default m int Number of required signatures. required multi_signers List[PublicKey] Full set of signers. required recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description PublicKey Public key of the new multisig account. Source code in spl/token/client.py def create_multisig ( self , m : int , multi_signers : List [ PublicKey ], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : # pylint: disable=invalid-name \"\"\"Create and initialize a new multisig. Args: m: Number of required signatures. multi_signers: Full set of signers. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new multisig account. \"\"\" balance_needed = Token . get_min_balance_rent_for_exempt_for_multisig ( self . _conn ) txn , payer , multisig = self . _create_multisig_args ( m , multi_signers , balance_needed ) opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts self . _conn . send_transaction ( txn , payer , multisig , opts = opts_to_use , recent_blockhash = recent_blockhash ) return multisig . public_key","title":"create_multisig()"},{"location":"spl/token/client/#spl.token.client.Token.create_wrapped_native_account","text":"Create and initialize a new account on the special native token mint. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required program_id PublicKey SPL Token program account. required owner PublicKey The owner of the new token account. required payer Keypair The source of the lamports to initialize, and payer of the initialization fees. required amount int The amount of lamports to wrap. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description PublicKey The new token account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py @staticmethod def create_wrapped_native_account ( conn : Client , program_id : PublicKey , owner : PublicKey , payer : Keypair , amount : int , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> PublicKey : \"\"\"Create and initialize a new account on the special native token mint. Args: conn: RPC connection to a solana cluster. program_id: SPL Token program account. owner: The owner of the new token account. payer: The source of the lamports to initialize, and payer of the initialization fees. amount: The amount of lamports to wrap. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: The new token account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = Token . get_min_balance_rent_for_exempt_for_account ( conn ) new_account_public_key , txn , payer , new_account , opts = _TokenCore . _create_wrapped_native_account_args ( program_id , owner , payer , amount , skip_confirmation , balance_needed , conn . commitment ) conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_public_key","title":"create_wrapped_native_account()"},{"location":"spl/token/client/#spl.token.client.Token.freeze_account","text":"Freeze account. Parameters: Name Type Description Default account PublicKey Account to freeze. required authority Union[PublicKey, Keypair] The mint freeze authority. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if authority is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def freeze_account ( self , account : PublicKey , authority : Union [ PublicKey , Keypair ], multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Freeze account. Args: account: Account to freeze. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _freeze_account_args ( account , authority , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"freeze_account()"},{"location":"spl/token/client/#spl.token.client.Token.get_account_info","text":"Retrieve account information. Source code in spl/token/client.py def get_account_info ( self , account : PublicKey , commitment : Optional [ Commitment ] = None ) -> AccountInfo : \"\"\"Retrieve account information.\"\"\" info = self . _conn . get_account_info ( account , commitment ) return self . _create_account_info ( info )","title":"get_account_info()"},{"location":"spl/token/client/#spl.token.client.Token.get_accounts","text":"Get token accounts of the provided owner by the token's mint. Parameters: Name Type Description Default owner PublicKey Public Key of the token account owner. required is_delegate bool (optional) Flag specifying if the owner public key is a delegate. False commitment Optional[Commitment] (optional) Bank state to query. None encoding str (optional) Encoding for Account data, either \"base58\" (slow), \"base64\" or jsonParsed\". 'jsonParsed' Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. Source code in spl/token/client.py def get_accounts ( self , owner : PublicKey , is_delegate : bool = False , commitment : Optional [ Commitment ] = None , encoding : str = \"jsonParsed\" , ) -> RPCResponse : \"\"\"Get token accounts of the provided owner by the token's mint. Args: owner: Public Key of the token account owner. is_delegate: (optional) Flag specifying if the `owner` public key is a delegate. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\" or jsonParsed\". Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment # pylint: disable=protected-access ) return ( self . _conn . get_token_accounts_by_delegate ( * args ) if is_delegate else self . _conn . get_token_accounts_by_owner ( * args ) )","title":"get_accounts()"},{"location":"spl/token/client/#spl.token.client.Token.get_balance","text":"Get the balance of the provided token account. Parameters: Name Type Description Default pubkey PublicKey Public Key of the token account. required commitment Optional[Commitment] (optional) Bank state to query. None Source code in spl/token/client.py def get_balance ( self , pubkey : PublicKey , commitment : Optional [ Commitment ] = None ) -> RPCResponse : \"\"\"Get the balance of the provided token account. Args: pubkey: Public Key of the token account. commitment: (optional) Bank state to query. \"\"\" return self . _conn . get_token_account_balance ( pubkey , commitment )","title":"get_balance()"},{"location":"spl/token/client/#spl.token.client.Token.get_min_balance_rent_for_exempt_for_account","text":"Get the minimum balance for the account to be rent exempt. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/client.py @staticmethod def get_min_balance_rent_for_exempt_for_account ( conn : Client ) -> int : \"\"\"Get the minimum balance for the account to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( ACCOUNT_LAYOUT . sizeof ()) return resp [ \"result\" ]","title":"get_min_balance_rent_for_exempt_for_account()"},{"location":"spl/token/client/#spl.token.client.Token.get_min_balance_rent_for_exempt_for_mint","text":"Get the minimum balance for the mint to be rent exempt. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/client.py @staticmethod def get_min_balance_rent_for_exempt_for_mint ( conn : Client ) -> int : \"\"\"Get the minimum balance for the mint to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( MINT_LAYOUT . sizeof ()) return resp [ \"result\" ]","title":"get_min_balance_rent_for_exempt_for_mint()"},{"location":"spl/token/client/#spl.token.client.Token.get_min_balance_rent_for_exempt_for_multisig","text":"Get the minimum balance for the multisig to be rent exempt. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required Source code in spl/token/client.py @staticmethod def get_min_balance_rent_for_exempt_for_multisig ( conn : Client ) -> int : \"\"\"Get the minimum balance for the multisig to be rent exempt. Args: conn: RPC connection to a solana cluster. Return: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( MULTISIG_LAYOUT . sizeof ()) return resp [ \"result\" ]","title":"get_min_balance_rent_for_exempt_for_multisig()"},{"location":"spl/token/client/#spl.token.client.Token.get_mint_info","text":"Retrieve mint information. Source code in spl/token/client.py def get_mint_info ( self ) -> MintInfo : \"\"\"Retrieve mint information.\"\"\" info = self . _conn . get_account_info ( self . pubkey ) return self . _create_mint_info ( info )","title":"get_mint_info()"},{"location":"spl/token/client/#spl.token.client.Token.mint_to","text":"Mint new tokens. Parameters: Name Type Description Default dest PublicKey Public key of the account to mint to. required mint_authority Union[Keypair, PublicKey] Public key of the minting authority. required amount int Amount to mint. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py def mint_to ( self , dest : PublicKey , mint_authority : Union [ Keypair , PublicKey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Mint new tokens. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_args ( dest , mint_authority , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"mint_to()"},{"location":"spl/token/client/#spl.token.client.Token.mint_to_checked","text":"Mint new tokens, asserting the token mint and decimals. Parameters: Name Type Description Default dest PublicKey Public key of the account to mint to. required mint_authority Union[Keypair, PublicKey] Public key of the minting authority. required amount int Amount to mint. required decimals int Number of decimals in amount to mint. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def mint_to_checked ( self , dest : PublicKey , mint_authority : Union [ Keypair , PublicKey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Mint new tokens, asserting the token mint and decimals. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. decimals: Number of decimals in amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_checked_args ( dest , mint_authority , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"mint_to_checked()"},{"location":"spl/token/client/#spl.token.client.Token.revoke","text":"Revoke transfer authority for a given account. Parameters: Name Type Description Default account PublicKey Source account for which transfer authority is being revoked. required owner PublicKey Owner of the source account. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def revoke ( self , account : PublicKey , owner : PublicKey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Revoke transfer authority for a given account. Args: account: Source account for which transfer authority is being revoked. owner: Owner of the source account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _revoke_args ( account , owner , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"revoke()"},{"location":"spl/token/client/#spl.token.client.Token.set_authority","text":"Assign a new authority to the account. Parameters: Name Type Description Default account PublicKey Public key of the token account. required current_authority Union[Keypair, PublicKey] Current authority of the account. required authority_type spl_token.AuthorityType Type of authority to set. required new_authority Optional[PublicKey] (optional) New authority of the account. None multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def set_authority ( self , account : PublicKey , current_authority : Union [ Keypair , PublicKey ], authority_type : spl_token . AuthorityType , new_authority : Optional [ PublicKey ] = None , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Assign a new authority to the account. Args: account: Public key of the token account. current_authority: Current authority of the account. authority_type: Type of authority to set. new_authority: (optional) New authority of the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _set_authority_args ( account , current_authority , authority_type , new_authority , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"set_authority()"},{"location":"spl/token/client/#spl.token.client.Token.thaw_account","text":"Thaw account. Parameters: Name Type Description Default account PublicKey Account to thaw. required authority PublicKey The mint freeze authority. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if authority is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def thaw_account ( self , account : PublicKey , authority : PublicKey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Thaw account. Args: account: Account to thaw. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _thaw_account_args ( account , authority , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"thaw_account()"},{"location":"spl/token/client/#spl.token.client.Token.transfer","text":"Transfer tokens to another account. Parameters: Name Type Description Default source PublicKey Public key of account to transfer tokens from. required dest PublicKey Public key of account to transfer tokens to. required owner Union[Keypair, PublicKey] Owner of the source account. required amount int Number of tokens to transfer. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def transfer ( self , source : PublicKey , dest : PublicKey , owner : Union [ Keypair , PublicKey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Transfer tokens to another account. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_args ( source , dest , owner , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"transfer()"},{"location":"spl/token/client/#spl.token.client.Token.transfer_checked","text":"Transfer tokens to another account, asserting the token mint and decimals. Parameters: Name Type Description Default source PublicKey Public key of account to transfer tokens from. required dest PublicKey Public key of account to transfer tokens to. required owner Union[Keypair, PublicKey] Owner of the source account. required amount int Number of tokens to transfer. required decimals int Number of decimals in transfer amount. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def transfer_checked ( self , source : PublicKey , dest : PublicKey , owner : Union [ Keypair , PublicKey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> RPCResponse : \"\"\"Transfer tokens to another account, asserting the token mint and decimals. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. decimals: Number of decimals in transfer amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_checked_args ( source , dest , owner , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"transfer_checked()"},{"location":"spl/token/constants/","text":"Constants spl.token.constants SPL token constants. ACCOUNT_LEN : int Data length of a token account. ASSOCIATED_TOKEN_PROGRAM_ID Program ID for the associated token account program. MINT_LEN : int Data length of a token mint account. MULTISIG_LEN : int Data length of a multisig token account. TOKEN_PROGRAM_ID : PublicKey Public key that identifies the SPL token program. WRAPPED_SOL_MINT : PublicKey Public key of the \"Native Mint\" for wrapping SOL to SPL token. The Token Program can be used to wrap native SOL. Doing so allows native SOL to be treated like any other Token program token type and can be useful when being called from other programs that interact with the Token Program's interface.","title":"Constants"},{"location":"spl/token/constants/#constants","text":"","title":"Constants"},{"location":"spl/token/constants/#spl.token.constants","text":"SPL token constants.","title":"constants"},{"location":"spl/token/constants/#spl.token.constants.ACCOUNT_LEN","text":"Data length of a token account.","title":"ACCOUNT_LEN"},{"location":"spl/token/constants/#spl.token.constants.ASSOCIATED_TOKEN_PROGRAM_ID","text":"Program ID for the associated token account program.","title":"ASSOCIATED_TOKEN_PROGRAM_ID"},{"location":"spl/token/constants/#spl.token.constants.MINT_LEN","text":"Data length of a token mint account.","title":"MINT_LEN"},{"location":"spl/token/constants/#spl.token.constants.MULTISIG_LEN","text":"Data length of a multisig token account.","title":"MULTISIG_LEN"},{"location":"spl/token/constants/#spl.token.constants.TOKEN_PROGRAM_ID","text":"Public key that identifies the SPL token program.","title":"TOKEN_PROGRAM_ID"},{"location":"spl/token/constants/#spl.token.constants.WRAPPED_SOL_MINT","text":"Public key of the \"Native Mint\" for wrapping SOL to SPL token. The Token Program can be used to wrap native SOL. Doing so allows native SOL to be treated like any other Token program token type and can be useful when being called from other programs that interact with the Token Program's interface.","title":"WRAPPED_SOL_MINT"},{"location":"spl/token/core/","text":"Core spl.token.core Helper code for client.py and async_client.py. AccountInfo Information about an account. Source code in spl/token/core.py class AccountInfo ( NamedTuple ): \"\"\"Information about an account.\"\"\" mint : PublicKey \"\"\"The mint associated with this account.\"\"\" owner : PublicKey \"\"\"Owner of this account.\"\"\" amount : int \"\"\"Amount of tokens this account holds.\"\"\" delegate : Optional [ PublicKey ] \"\"\"The delegate for this account.\"\"\" delegated_amount : int \"\"\"The amount of tokens the delegate authorized to the delegate.\"\"\" is_initialized : bool \"\"\" Is this account initialized.\"\"\" is_frozen : bool \"\"\"Is this account frozen.\"\"\" is_native : bool \"\"\"Is this a native token account.\"\"\" rent_exempt_reserve : Optional [ int ] \"\"\"If this account is a native token, it must be rent-exempt. This value logs the rent-exempt reserve which must remain in the balance until the account is closed. \"\"\" close_authority : Optional [ PublicKey ] \"\"\"Optional authority to close the account.\"\"\" amount : int Amount of tokens this account holds. close_authority : Optional [ solana . publickey . PublicKey ] Optional authority to close the account. delegate : Optional [ solana . publickey . PublicKey ] The delegate for this account. delegated_amount : int The amount of tokens the delegate authorized to the delegate. is_frozen : bool Is this account frozen. is_initialized : bool Is this account initialized. is_native : bool Is this a native token account. mint : PublicKey The mint associated with this account. owner : PublicKey Owner of this account. rent_exempt_reserve : Optional [ int ] If this account is a native token, it must be rent-exempt. This value logs the rent-exempt reserve which must remain in the balance until the account is closed. MintInfo Information about the mint. Source code in spl/token/core.py class MintInfo ( NamedTuple ): \"\"\"Information about the mint.\"\"\" mint_authority : Optional [ PublicKey ] \"\"\"\"Optional authority used to mint new tokens. The mint authority may only be provided during mint creation. If no mint authority is present then the mint has a fixed supply and no further tokens may be minted. \"\"\" supply : int \"\"\"Total supply of tokens.\"\"\" decimals : int \"\"\"Number of base 10 digits to the right of the decimal place.\"\"\" is_initialized : bool \"\"\"Is this mint initialized.\"\"\" freeze_authority : Optional [ PublicKey ] \"\"\" Optional authority to freeze token accounts.\"\"\" decimals : int Number of base 10 digits to the right of the decimal place. freeze_authority : Optional [ solana . publickey . PublicKey ] Optional authority to freeze token accounts. is_initialized : bool Is this mint initialized. mint_authority : Optional [ solana . publickey . PublicKey ] \"Optional authority used to mint new tokens. The mint authority may only be provided during mint creation. If no mint authority is present then the mint has a fixed supply and no further tokens may be minted. supply : int Total supply of tokens.","title":"Core"},{"location":"spl/token/core/#core","text":"","title":"Core"},{"location":"spl/token/core/#spl.token.core","text":"Helper code for client.py and async_client.py.","title":"core"},{"location":"spl/token/core/#spl.token.core.AccountInfo","text":"Information about an account. Source code in spl/token/core.py class AccountInfo ( NamedTuple ): \"\"\"Information about an account.\"\"\" mint : PublicKey \"\"\"The mint associated with this account.\"\"\" owner : PublicKey \"\"\"Owner of this account.\"\"\" amount : int \"\"\"Amount of tokens this account holds.\"\"\" delegate : Optional [ PublicKey ] \"\"\"The delegate for this account.\"\"\" delegated_amount : int \"\"\"The amount of tokens the delegate authorized to the delegate.\"\"\" is_initialized : bool \"\"\" Is this account initialized.\"\"\" is_frozen : bool \"\"\"Is this account frozen.\"\"\" is_native : bool \"\"\"Is this a native token account.\"\"\" rent_exempt_reserve : Optional [ int ] \"\"\"If this account is a native token, it must be rent-exempt. This value logs the rent-exempt reserve which must remain in the balance until the account is closed. \"\"\" close_authority : Optional [ PublicKey ] \"\"\"Optional authority to close the account.\"\"\"","title":"AccountInfo"},{"location":"spl/token/core/#spl.token.core.AccountInfo.amount","text":"Amount of tokens this account holds.","title":"amount"},{"location":"spl/token/core/#spl.token.core.AccountInfo.close_authority","text":"Optional authority to close the account.","title":"close_authority"},{"location":"spl/token/core/#spl.token.core.AccountInfo.delegate","text":"The delegate for this account.","title":"delegate"},{"location":"spl/token/core/#spl.token.core.AccountInfo.delegated_amount","text":"The amount of tokens the delegate authorized to the delegate.","title":"delegated_amount"},{"location":"spl/token/core/#spl.token.core.AccountInfo.is_frozen","text":"Is this account frozen.","title":"is_frozen"},{"location":"spl/token/core/#spl.token.core.AccountInfo.is_initialized","text":"Is this account initialized.","title":"is_initialized"},{"location":"spl/token/core/#spl.token.core.AccountInfo.is_native","text":"Is this a native token account.","title":"is_native"},{"location":"spl/token/core/#spl.token.core.AccountInfo.mint","text":"The mint associated with this account.","title":"mint"},{"location":"spl/token/core/#spl.token.core.AccountInfo.owner","text":"Owner of this account.","title":"owner"},{"location":"spl/token/core/#spl.token.core.AccountInfo.rent_exempt_reserve","text":"If this account is a native token, it must be rent-exempt. This value logs the rent-exempt reserve which must remain in the balance until the account is closed.","title":"rent_exempt_reserve"},{"location":"spl/token/core/#spl.token.core.MintInfo","text":"Information about the mint. Source code in spl/token/core.py class MintInfo ( NamedTuple ): \"\"\"Information about the mint.\"\"\" mint_authority : Optional [ PublicKey ] \"\"\"\"Optional authority used to mint new tokens. The mint authority may only be provided during mint creation. If no mint authority is present then the mint has a fixed supply and no further tokens may be minted. \"\"\" supply : int \"\"\"Total supply of tokens.\"\"\" decimals : int \"\"\"Number of base 10 digits to the right of the decimal place.\"\"\" is_initialized : bool \"\"\"Is this mint initialized.\"\"\" freeze_authority : Optional [ PublicKey ] \"\"\" Optional authority to freeze token accounts.\"\"\"","title":"MintInfo"},{"location":"spl/token/core/#spl.token.core.MintInfo.decimals","text":"Number of base 10 digits to the right of the decimal place.","title":"decimals"},{"location":"spl/token/core/#spl.token.core.MintInfo.freeze_authority","text":"Optional authority to freeze token accounts.","title":"freeze_authority"},{"location":"spl/token/core/#spl.token.core.MintInfo.is_initialized","text":"Is this mint initialized.","title":"is_initialized"},{"location":"spl/token/core/#spl.token.core.MintInfo.mint_authority","text":"\"Optional authority used to mint new tokens. The mint authority may only be provided during mint creation. If no mint authority is present then the mint has a fixed supply and no further tokens may be minted.","title":"mint_authority"},{"location":"spl/token/core/#spl.token.core.MintInfo.supply","text":"Total supply of tokens.","title":"supply"},{"location":"spl/token/instructions/","text":"Instructions spl.token.instructions SPL token instructions. ApproveCheckedParams ApproveChecked token transaction params. Source code in spl/token/instructions.py class ApproveCheckedParams ( NamedTuple ): \"\"\"ApproveChecked token transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" source : PublicKey \"\"\"Source account.\"\"\" mint : PublicKey \"\"\"Public key of the minter account.\"\"\" delegate : PublicKey \"\"\"Delegate account authorized to perform a transfer of tokens from the source account.\"\"\" owner : PublicKey \"\"\"Owner of the source account.\"\"\" amount : int \"\"\"Maximum number of tokens the delegate may transfer.\"\"\" decimals : int \"\"\"Amount decimals.\"\"\" signers : List [ PublicKey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\" amount : int Maximum number of tokens the delegate may transfer. decimals : int Amount decimals. delegate : PublicKey Delegate account authorized to perform a transfer of tokens from the source account. mint : PublicKey Public key of the minter account. owner : PublicKey Owner of the source account. program_id : PublicKey SPL Token program account. signers : List [ solana . publickey . PublicKey ] Signing accounts if owner is a multiSig. source : PublicKey Source account. ApproveParams Approve token transaction params. Source code in spl/token/instructions.py class ApproveParams ( NamedTuple ): \"\"\"Approve token transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" source : PublicKey \"\"\"Source account.\"\"\" delegate : PublicKey \"\"\"Delegate account authorized to perform a transfer of tokens from the source account.\"\"\" owner : PublicKey \"\"\"Owner of the source account.\"\"\" amount : int \"\"\"Maximum number of tokens the delegate may transfer.\"\"\" signers : List [ PublicKey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\" amount : int Maximum number of tokens the delegate may transfer. delegate : PublicKey Delegate account authorized to perform a transfer of tokens from the source account. owner : PublicKey Owner of the source account. program_id : PublicKey SPL Token program account. signers : List [ solana . publickey . PublicKey ] Signing accounts if owner is a multiSig. source : PublicKey Source account. AuthorityType Specifies the authority type for SetAuthority instructions. Source code in spl/token/instructions.py class AuthorityType ( IntEnum ): \"\"\"Specifies the authority type for SetAuthority instructions.\"\"\" MINT_TOKENS = 0 \"\"\"\"Authority to mint new tokens.\"\"\" FREEZE_ACCOUNT = 1 \"\"\"Authority to freeze any account associated with the Mint.\"\"\" ACCOUNT_OWNER = 2 \"\"\"Owner of a given token account.\"\"\" CLOSE_ACCOUNT = 3 \"\"\"Authority to close a token account.\"\"\" ACCOUNT_OWNER Owner of a given token account. CLOSE_ACCOUNT Authority to close a token account. FREEZE_ACCOUNT Authority to freeze any account associated with the Mint. MINT_TOKENS \"Authority to mint new tokens. BurnCheckedParams BurnChecked token transaction params. Source code in spl/token/instructions.py class BurnCheckedParams ( NamedTuple ): \"\"\"BurnChecked token transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" mint : PublicKey \"\"\"Public key of the minter account.\"\"\" account : PublicKey \"\"\"Account to burn tokens from.\"\"\" owner : PublicKey \"\"\"Owner of the account.\"\"\" amount : int \"\"\"Amount to burn.\"\"\" decimals : int \"\"\"Amount decimals.\"\"\" signers : List [ PublicKey ] = [] \"\"\"Signing accounts if `owner` is a multiSig\"\"\" account : PublicKey Account to burn tokens from. amount : int Amount to burn. decimals : int Amount decimals. mint : PublicKey Public key of the minter account. owner : PublicKey Owner of the account. program_id : PublicKey SPL Token program account. signers : List [ solana . publickey . PublicKey ] Signing accounts if owner is a multiSig BurnParams Burn token transaction params. Source code in spl/token/instructions.py class BurnParams ( NamedTuple ): \"\"\"Burn token transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" account : PublicKey \"\"\"Account to burn tokens from.\"\"\" mint : PublicKey \"\"\"Public key of the minter account.\"\"\" owner : PublicKey \"\"\"Owner of the account.\"\"\" amount : int \"\"\"Amount to burn.\"\"\" signers : List [ PublicKey ] = [] \"\"\"Signing accounts if `owner` is a multiSig\"\"\" account : PublicKey Account to burn tokens from. amount : int Amount to burn. mint : PublicKey Public key of the minter account. owner : PublicKey Owner of the account. program_id : PublicKey SPL Token program account. signers : List [ solana . publickey . PublicKey ] Signing accounts if owner is a multiSig CloseAccountParams Close token account transaction params. Source code in spl/token/instructions.py class CloseAccountParams ( NamedTuple ): \"\"\"Close token account transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" account : PublicKey \"\"\"Address of account to close.\"\"\" dest : PublicKey \"\"\"Address of account to receive the remaining balance of the closed account.\"\"\" owner : PublicKey \"\"\"Owner of the account.\"\"\" signers : List [ PublicKey ] = [] \"\"\"Signing accounts if `owner` is a multiSig\"\"\" account : PublicKey Address of account to close. dest : PublicKey Address of account to receive the remaining balance of the closed account. owner : PublicKey Owner of the account. program_id : PublicKey SPL Token program account. signers : List [ solana . publickey . PublicKey ] Signing accounts if owner is a multiSig FreezeAccountParams Freeze token account transaction params. Source code in spl/token/instructions.py class FreezeAccountParams ( NamedTuple ): \"\"\"Freeze token account transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" account : PublicKey \"\"\"Account to freeze.\"\"\" mint : PublicKey \"\"\"Public key of the minter account.\"\"\" authority : PublicKey \"\"\"Mint freeze authority\"\"\" multi_signers : List [ PublicKey ] = [] \"\"\"Signing accounts if `authority` is a multiSig\"\"\" account : PublicKey Account to freeze. authority : PublicKey Mint freeze authority mint : PublicKey Public key of the minter account. multi_signers : List [ solana . publickey . PublicKey ] Signing accounts if authority is a multiSig program_id : PublicKey SPL Token program account. InitializeAccountParams Initialize token account transaction params. Source code in spl/token/instructions.py class InitializeAccountParams ( NamedTuple ): \"\"\"Initialize token account transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" account : PublicKey \"\"\"Public key of the new account.\"\"\" mint : PublicKey \"\"\"Public key of the minter account.\"\"\" owner : PublicKey \"\"\"Owner of the new account.\"\"\" account : PublicKey Public key of the new account. mint : PublicKey Public key of the minter account. owner : PublicKey Owner of the new account. program_id : PublicKey SPL Token program account. InitializeMintParams Initialize token mint transaction params. Source code in spl/token/instructions.py class InitializeMintParams ( NamedTuple ): \"\"\"Initialize token mint transaction params.\"\"\" decimals : int \"\"\"Number of base 10 digits to the right of the decimal place.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" mint : PublicKey \"\"\"Public key of the minter account.\"\"\" mint_authority : PublicKey \"\"\"The authority/multisignature to mint tokens.\"\"\" freeze_authority : Optional [ PublicKey ] = None \"\"\"The freeze authority/multisignature of the mint.\"\"\" decimals : int Number of base 10 digits to the right of the decimal place. freeze_authority : Optional [ solana . publickey . PublicKey ] The freeze authority/multisignature of the mint. mint : PublicKey Public key of the minter account. mint_authority : PublicKey The authority/multisignature to mint tokens. program_id : PublicKey SPL Token program account. InitializeMultisigParams Initialize multisig token account transaction params. Source code in spl/token/instructions.py class InitializeMultisigParams ( NamedTuple ): \"\"\"Initialize multisig token account transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" multisig : PublicKey \"\"\"New multisig account address.\"\"\" m : int \"\"\"The number of signers (M) required to validate this multisignature account.\"\"\" signers : List [ PublicKey ] = [] \"\"\"Addresses of multisig signers.\"\"\" m : int The number of signers (M) required to validate this multisignature account. multisig : PublicKey New multisig account address. program_id : PublicKey SPL Token program account. signers : List [ solana . publickey . PublicKey ] Addresses of multisig signers. MintToCheckedParams MintToChecked token transaction params. Source code in spl/token/instructions.py class MintToCheckedParams ( NamedTuple ): \"\"\"MintToChecked token transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" mint : PublicKey \"\"\"Public key of the minter account.\"\"\" dest : PublicKey \"\"\"Public key of the account to mint to.\"\"\" mint_authority : PublicKey \"\"\"The mint authority.\"\"\" amount : int \"\"\"Amount to mint.\"\"\" decimals : int \"\"\"Amount decimals.\"\"\" signers : List [ PublicKey ] = [] \"\"\"Signing accounts if `mint_authority` is a multiSig.\"\"\" amount : int Amount to mint. decimals : int Amount decimals. dest : PublicKey Public key of the account to mint to. mint : PublicKey Public key of the minter account. mint_authority : PublicKey The mint authority. program_id : PublicKey SPL Token program account. signers : List [ solana . publickey . PublicKey ] Signing accounts if mint_authority is a multiSig. MintToParams Mint token transaction params. Source code in spl/token/instructions.py class MintToParams ( NamedTuple ): \"\"\"Mint token transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" mint : PublicKey \"\"\"Public key of the minter account.\"\"\" dest : PublicKey \"\"\"Public key of the account to mint to.\"\"\" mint_authority : PublicKey \"\"\"The mint authority.\"\"\" amount : int \"\"\"Amount to mint.\"\"\" signers : List [ PublicKey ] = [] \"\"\"Signing accounts if `mint_authority` is a multiSig.\"\"\" amount : int Amount to mint. dest : PublicKey Public key of the account to mint to. mint : PublicKey Public key of the minter account. mint_authority : PublicKey The mint authority. program_id : PublicKey SPL Token program account. signers : List [ solana . publickey . PublicKey ] Signing accounts if mint_authority is a multiSig. RevokeParams Revoke token transaction params. Source code in spl/token/instructions.py class RevokeParams ( NamedTuple ): \"\"\"Revoke token transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" account : PublicKey \"\"\"Source account for which transfer authority is being revoked.\"\"\" owner : PublicKey \"\"\"Owner of the source account.\"\"\" signers : List [ PublicKey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\" account : PublicKey Source account for which transfer authority is being revoked. owner : PublicKey Owner of the source account. program_id : PublicKey SPL Token program account. signers : List [ solana . publickey . PublicKey ] Signing accounts if owner is a multiSig. SetAuthorityParams Set token authority transaction params. Source code in spl/token/instructions.py class SetAuthorityParams ( NamedTuple ): \"\"\"Set token authority transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" account : PublicKey \"\"\"Public key of the token account.\"\"\" authority : AuthorityType \"\"\"The type of authority to update.\"\"\" current_authority : PublicKey \"\"\"Current authority of the specified type.\"\"\" signers : List [ PublicKey ] = [] \"\"\"Signing accounts if `current_authority` is a multiSig.\"\"\" new_authority : Optional [ PublicKey ] = None \"\"\"New authority of the account.\"\"\" account : PublicKey Public key of the token account. authority : AuthorityType The type of authority to update. current_authority : PublicKey Current authority of the specified type. new_authority : Optional [ solana . publickey . PublicKey ] New authority of the account. program_id : PublicKey SPL Token program account. signers : List [ solana . publickey . PublicKey ] Signing accounts if current_authority is a multiSig. ThawAccountParams Thaw token account transaction params. Source code in spl/token/instructions.py class ThawAccountParams ( NamedTuple ): \"\"\"Thaw token account transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" account : PublicKey \"\"\"Account to thaw.\"\"\" mint : PublicKey \"\"\"Public key of the minter account.\"\"\" authority : PublicKey \"\"\"Mint freeze authority\"\"\" multi_signers : List [ PublicKey ] = [] \"\"\"Signing accounts if `authority` is a multiSig\"\"\" account : PublicKey Account to thaw. authority : PublicKey Mint freeze authority mint : PublicKey Public key of the minter account. multi_signers : List [ solana . publickey . PublicKey ] Signing accounts if authority is a multiSig program_id : PublicKey SPL Token program account. TransferCheckedParams TransferChecked token transaction params. Source code in spl/token/instructions.py class TransferCheckedParams ( NamedTuple ): \"\"\"TransferChecked token transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" source : PublicKey \"\"\"Source account.\"\"\" mint : PublicKey \"\"\"Public key of the minter account.\"\"\" dest : PublicKey \"\"\"Destination account.\"\"\" owner : PublicKey \"\"\"Owner of the source account.\"\"\" amount : int \"\"\"Number of tokens to transfer.\"\"\" decimals : int \"\"\"Amount decimals.\"\"\" signers : List [ PublicKey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\" amount : int Number of tokens to transfer. decimals : int Amount decimals. dest : PublicKey Destination account. mint : PublicKey Public key of the minter account. owner : PublicKey Owner of the source account. program_id : PublicKey SPL Token program account. signers : List [ solana . publickey . PublicKey ] Signing accounts if owner is a multiSig. source : PublicKey Source account. TransferParams Transfer token transaction params. Source code in spl/token/instructions.py class TransferParams ( NamedTuple ): \"\"\"Transfer token transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" source : PublicKey \"\"\"Source account.\"\"\" dest : PublicKey \"\"\"Destination account.\"\"\" owner : PublicKey \"\"\"Owner of the source account.\"\"\" amount : int \"\"\"Number of tokens to transfer.\"\"\" signers : List [ PublicKey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\" amount : int Number of tokens to transfer. dest : PublicKey Destination account. owner : PublicKey Owner of the source account. program_id : PublicKey SPL Token program account. signers : List [ solana . publickey . PublicKey ] Signing accounts if owner is a multiSig. source : PublicKey Source account. approve ( params ) Creates a transaction instruction to approve a delegate. Examples: >>> delegate , owner , source , token = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ), PublicKey ( 4 ) >>> params = ApproveParams ( ... amount = 123 , ... delegate = delegate , ... owner = owner , ... program_id = token , ... source = source ... ) >>> type ( approve ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The approve instruction. Source code in spl/token/instructions.py def approve ( params : ApproveParams ) -> TransactionInstruction : \"\"\"Creates a transaction instruction to approve a delegate. Example: >>> delegate, owner, source, token = PublicKey(1), PublicKey(2), PublicKey(3), PublicKey(4) >>> params = ApproveParams( ... amount=123, ... delegate=delegate, ... owner=owner, ... program_id=token, ... source=source ... ) >>> type(approve(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The approve instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . APPROVE , args = dict ( amount = params . amount ))) keys = [ AccountMeta ( pubkey = params . source , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . delegate , is_signer = False , is_writable = False ), ] __add_signers ( keys , params . owner , params . signers ) return TransactionInstruction ( keys = keys , program_id = params . program_id , data = data ) approve_checked ( params ) This instruction differs from approve in that the token mint and decimals value is asserted by the caller. Examples: >>> delegate , mint , owner , source , token = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ), PublicKey ( 4 ), PublicKey ( 5 ) >>> params = ApproveCheckedParams ( ... amount = 1000 , ... decimals = 6 , ... delegate = delegate , ... mint = mint , ... owner = owner , ... program_id = token , ... source = source , ... ) >>> type ( approve_checked ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The approve-checked instruction. Source code in spl/token/instructions.py def approve_checked ( params : ApproveCheckedParams ) -> TransactionInstruction : \"\"\"This instruction differs from `approve` in that the token mint and decimals value is asserted by the caller. Example: >>> delegate, mint, owner, source, token = PublicKey(1), PublicKey(2), PublicKey(3), PublicKey(4), PublicKey(5) >>> params = ApproveCheckedParams( ... amount=1000, ... decimals=6, ... delegate=delegate, ... mint=mint, ... owner=owner, ... program_id=token, ... source=source, ... ) >>> type(approve_checked(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The approve-checked instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . APPROVE2 , args = dict ( amount = params . amount , decimals = params . decimals )) ) keys = [ AccountMeta ( pubkey = params . source , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . mint , is_signer = False , is_writable = False ), AccountMeta ( pubkey = params . delegate , is_signer = False , is_writable = False ), ] __add_signers ( keys , params . owner , params . signers ) return TransactionInstruction ( keys = keys , program_id = params . program_id , data = data ) burn ( params ) Creates a transaction instruction to burns tokens by removing them from an account. Examples: >>> account , mint , owner , token = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ), PublicKey ( 4 ) >>> params = BurnParams ( ... amount = 123 , account = account , mint = mint , owner = owner , program_id = token , ... ) >>> type ( burn ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The burn instruction. Source code in spl/token/instructions.py def burn ( params : BurnParams ) -> TransactionInstruction : \"\"\"Creates a transaction instruction to burns tokens by removing them from an account. Example: >>> account, mint, owner, token = PublicKey(1), PublicKey(2), PublicKey(3), PublicKey(4) >>> params = BurnParams( ... amount=123, account=account, mint=mint, owner=owner, program_id=token, ... ) >>> type(burn(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The burn instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . BURN , args = dict ( amount = params . amount ))) return __burn_instruction ( params , data ) burn_checked ( params ) This instruction differs from burn in that the decimals value is asserted by the caller. Examples: >>> account , mint , owner , token = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ), PublicKey ( 4 ) >>> params = BurnCheckedParams ( ... amount = 123 , account = account , decimals = 6 , mint = mint , owner = owner , program_id = token , ... ) >>> type ( burn_checked ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The burn-checked instruction. Source code in spl/token/instructions.py def burn_checked ( params : BurnCheckedParams ) -> TransactionInstruction : \"\"\"This instruction differs from `burn` in that the decimals value is asserted by the caller. Example: >>> account, mint, owner, token = PublicKey(1), PublicKey(2), PublicKey(3), PublicKey(4) >>> params = BurnCheckedParams( ... amount=123, account=account, decimals=6, mint=mint, owner=owner, program_id=token, ... ) >>> type(burn_checked(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The burn-checked instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . BURN2 , args = dict ( amount = params . amount , decimals = params . decimals )) ) return __burn_instruction ( params , data ) close_account ( params ) Creates a transaction instruction to close an account by transferring all its SOL to the destination account. Non-native accounts may only be closed if its token amount is zero. Examples: >>> account , dest , owner , token = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ), PublicKey ( 4 ) >>> params = CloseAccountParams ( ... account = account , dest = dest , owner = owner , program_id = token ) >>> type ( close_account ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The close-account instruction. Source code in spl/token/instructions.py def close_account ( params : CloseAccountParams ) -> TransactionInstruction : \"\"\"Creates a transaction instruction to close an account by transferring all its SOL to the destination account. Non-native accounts may only be closed if its token amount is zero. Example: >>> account, dest, owner, token = PublicKey(1), PublicKey(2), PublicKey(3), PublicKey(4) >>> params = CloseAccountParams( ... account=account, dest=dest, owner=owner, program_id=token) >>> type(close_account(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The close-account instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . CLOSE_ACCOUNT , args = None )) keys = [ AccountMeta ( pubkey = params . account , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . dest , is_signer = False , is_writable = True ), ] __add_signers ( keys , params . owner , params . signers ) return TransactionInstruction ( keys = keys , program_id = params . program_id , data = data ) create_associated_token_account ( payer , owner , mint ) Creates a transaction instruction to create an associated token account. Returns: Type Description TransactionInstruction The instruction to create the associated token account. Source code in spl/token/instructions.py def create_associated_token_account ( payer : PublicKey , owner : PublicKey , mint : PublicKey ) -> TransactionInstruction : \"\"\"Creates a transaction instruction to create an associated token account. Returns: The instruction to create the associated token account. \"\"\" associated_token_address = get_associated_token_address ( owner , mint ) return TransactionInstruction ( keys = [ AccountMeta ( pubkey = payer , is_signer = True , is_writable = True ), AccountMeta ( pubkey = associated_token_address , is_signer = False , is_writable = True ), AccountMeta ( pubkey = owner , is_signer = False , is_writable = False ), AccountMeta ( pubkey = mint , is_signer = False , is_writable = False ), AccountMeta ( pubkey = SYS_PROGRAM_ID , is_signer = False , is_writable = False ), AccountMeta ( pubkey = TOKEN_PROGRAM_ID , is_signer = False , is_writable = False ), AccountMeta ( pubkey = SYSVAR_RENT_PUBKEY , is_signer = False , is_writable = False ), ], program_id = ASSOCIATED_TOKEN_PROGRAM_ID , ) decode_approve ( instruction ) Decode a approve token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description ApproveParams The decoded instruction. Source code in spl/token/instructions.py def decode_approve ( instruction : TransactionInstruction ) -> ApproveParams : \"\"\"Decode a approve token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . APPROVE ) return ApproveParams ( program_id = instruction . program_id , source = instruction . keys [ 0 ] . pubkey , delegate = instruction . keys [ 1 ] . pubkey , owner = instruction . keys [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . keys [ 3 :]], amount = parsed_data . args . amount , ) decode_approve_checked ( instruction ) Decode a approve_checked token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description ApproveCheckedParams The decoded instruction. Source code in spl/token/instructions.py def decode_approve_checked ( instruction : TransactionInstruction ) -> ApproveCheckedParams : \"\"\"Decode a approve_checked token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 4 , InstructionType . APPROVE2 ) return ApproveCheckedParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , decimals = parsed_data . args . decimals , source = instruction . keys [ 0 ] . pubkey , mint = instruction . keys [ 1 ] . pubkey , delegate = instruction . keys [ 2 ] . pubkey , owner = instruction . keys [ 3 ] . pubkey , signers = [ signer . pubkey for signer in instruction . keys [ 4 :]], ) decode_burn ( instruction ) Decode a burn token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description BurnParams The decoded instruction. Source code in spl/token/instructions.py def decode_burn ( instruction : TransactionInstruction ) -> BurnParams : \"\"\"Decode a burn token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . BURN ) return BurnParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , account = instruction . keys [ 0 ] . pubkey , mint = instruction . keys [ 1 ] . pubkey , owner = instruction . keys [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . keys [ 3 :]], ) decode_burn_checked ( instruction ) Decode a burn_checked token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description BurnCheckedParams The decoded instruction. Source code in spl/token/instructions.py def decode_burn_checked ( instruction : TransactionInstruction ) -> BurnCheckedParams : \"\"\"Decode a burn_checked token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . BURN2 ) return BurnCheckedParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , decimals = parsed_data . args . decimals , account = instruction . keys [ 0 ] . pubkey , mint = instruction . keys [ 1 ] . pubkey , owner = instruction . keys [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . keys [ 3 :]], ) decode_close_account ( instruction ) Decode a close account token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description CloseAccountParams The decoded instruction. Source code in spl/token/instructions.py def decode_close_account ( instruction : TransactionInstruction ) -> CloseAccountParams : \"\"\"Decode a close account token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 3 , InstructionType . CLOSE_ACCOUNT ) return CloseAccountParams ( program_id = instruction . program_id , account = instruction . keys [ 0 ] . pubkey , dest = instruction . keys [ 1 ] . pubkey , owner = instruction . keys [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . keys [ 3 :]], ) decode_freeze_account ( instruction ) Decode a freeze account token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description FreezeAccountParams The decoded instruction. Source code in spl/token/instructions.py def decode_freeze_account ( instruction : TransactionInstruction ) -> FreezeAccountParams : \"\"\"Decode a freeze account token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 3 , InstructionType . FREEZE_ACCOUNT ) return FreezeAccountParams ( program_id = instruction . program_id , account = instruction . keys [ 0 ] . pubkey , mint = instruction . keys [ 1 ] . pubkey , authority = instruction . keys [ 2 ] . pubkey , multi_signers = [ signer . pubkey for signer in instruction . keys [ 3 :]], ) decode_initialize_account ( instruction ) Decode an initialize account token instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description InitializeAccountParams The decoded instruction. Source code in spl/token/instructions.py def decode_initialize_account ( instruction : TransactionInstruction ) -> InitializeAccountParams : \"\"\"Decode an initialize account token instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 4 , InstructionType . INITIALIZE_ACCOUNT ) return InitializeAccountParams ( program_id = instruction . program_id , account = instruction . keys [ 0 ] . pubkey , mint = instruction . keys [ 1 ] . pubkey , owner = instruction . keys [ 2 ] . pubkey , ) decode_initialize_mint ( instruction ) Decode an initialize mint token instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description InitializeMintParams The decoded instruction. Source code in spl/token/instructions.py def decode_initialize_mint ( instruction : TransactionInstruction ) -> InitializeMintParams : \"\"\"Decode an initialize mint token instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 2 , InstructionType . INITIALIZE_MINT ) return InitializeMintParams ( decimals = parsed_data . args . decimals , program_id = instruction . program_id , mint = instruction . keys [ 0 ] . pubkey , mint_authority = PublicKey ( parsed_data . args . mint_authority ), freeze_authority = PublicKey ( parsed_data . args . freeze_authority ) if parsed_data . args . freeze_authority_option else None , ) decode_initialize_multisig ( instruction ) Decode an initialize multisig account token instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description InitializeMultisigParams The decoded instruction. Source code in spl/token/instructions.py def decode_initialize_multisig ( instruction : TransactionInstruction ) -> InitializeMultisigParams : \"\"\"Decode an initialize multisig account token instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 2 , InstructionType . INITIALIZE_MULTISIG ) num_signers = parsed_data . args . m validate_instruction_keys ( instruction , 2 + num_signers ) return InitializeMultisigParams ( program_id = instruction . program_id , multisig = instruction . keys [ 0 ] . pubkey , signers = [ signer . pubkey for signer in instruction . keys [ - num_signers :]], m = num_signers , ) decode_mint_to ( instruction ) Decode a mint to token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description MintToParams The decoded instruction. Source code in spl/token/instructions.py def decode_mint_to ( instruction : TransactionInstruction ) -> MintToParams : \"\"\"Decode a mint to token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . MINT_TO ) return MintToParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , mint = instruction . keys [ 0 ] . pubkey , dest = instruction . keys [ 1 ] . pubkey , mint_authority = instruction . keys [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . keys [ 3 :]], ) decode_mint_to_checked ( instruction ) Decode a mintTo2 token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description MintToCheckedParams The decoded instruction. Source code in spl/token/instructions.py def decode_mint_to_checked ( instruction : TransactionInstruction ) -> MintToCheckedParams : \"\"\"Decode a mintTo2 token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . MINT_TO2 ) return MintToCheckedParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , decimals = parsed_data . args . decimals , mint = instruction . keys [ 0 ] . pubkey , dest = instruction . keys [ 1 ] . pubkey , mint_authority = instruction . keys [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . keys [ 3 :]], ) decode_revoke ( instruction ) Decode a revoke token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description RevokeParams The decoded instruction. Source code in spl/token/instructions.py def decode_revoke ( instruction : TransactionInstruction ) -> RevokeParams : \"\"\"Decode a revoke token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 2 , InstructionType . REVOKE ) return RevokeParams ( program_id = instruction . program_id , account = instruction . keys [ 0 ] . pubkey , owner = instruction . keys [ 1 ] . pubkey , signers = [ signer . pubkey for signer in instruction . keys [ 2 :]], ) decode_set_authority ( instruction ) Decode a set authority token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description SetAuthorityParams The decoded instruction. Source code in spl/token/instructions.py def decode_set_authority ( instruction : TransactionInstruction ) -> SetAuthorityParams : \"\"\"Decode a set authority token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 2 , InstructionType . SET_AUTHORITY ) return SetAuthorityParams ( program_id = instruction . program_id , account = instruction . keys [ 0 ] . pubkey , authority = AuthorityType ( parsed_data . args . authority_type ), new_authority = PublicKey ( parsed_data . args . new_authority ) if parsed_data . args . new_authority_option else None , current_authority = instruction . keys [ 1 ] . pubkey , signers = [ signer . pubkey for signer in instruction . keys [ 2 :]], ) decode_thaw_account ( instruction ) Decode a thaw account token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description ThawAccountParams The decoded instruction. Source code in spl/token/instructions.py def decode_thaw_account ( instruction : TransactionInstruction ) -> ThawAccountParams : \"\"\"Decode a thaw account token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 3 , InstructionType . THAW_ACCOUNT ) return ThawAccountParams ( program_id = instruction . program_id , account = instruction . keys [ 0 ] . pubkey , mint = instruction . keys [ 1 ] . pubkey , authority = instruction . keys [ 2 ] . pubkey , multi_signers = [ signer . pubkey for signer in instruction . keys [ 3 :]], ) decode_transfer ( instruction ) Decode a transfer token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description TransferParams The decoded instruction. Source code in spl/token/instructions.py def decode_transfer ( instruction : TransactionInstruction ) -> TransferParams : \"\"\"Decode a transfer token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . TRANSFER ) return TransferParams ( program_id = instruction . program_id , source = instruction . keys [ 0 ] . pubkey , dest = instruction . keys [ 1 ] . pubkey , owner = instruction . keys [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . keys [ 3 :]], amount = parsed_data . args . amount , ) decode_transfer_checked ( instruction ) Decode a transfer_checked token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description TransferCheckedParams The decoded instruction. Source code in spl/token/instructions.py def decode_transfer_checked ( instruction : TransactionInstruction ) -> TransferCheckedParams : \"\"\"Decode a transfer_checked token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 4 , InstructionType . TRANSFER2 ) return TransferCheckedParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , decimals = parsed_data . args . decimals , source = instruction . keys [ 0 ] . pubkey , mint = instruction . keys [ 1 ] . pubkey , dest = instruction . keys [ 2 ] . pubkey , owner = instruction . keys [ 3 ] . pubkey , signers = [ signer . pubkey for signer in instruction . keys [ 4 :]], ) freeze_account ( params ) Creates a transaction instruction to freeze an initialized account using the mint's freeze_authority (if set). Examples: >>> account , mint , authority , token = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ), PublicKey ( 4 ) >>> params = FreezeAccountParams ( ... account = account , mint = mint , authority = authority , program_id = token ) >>> type ( freeze_account ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The freeze-account instruction. Source code in spl/token/instructions.py def freeze_account ( params : FreezeAccountParams ) -> TransactionInstruction : \"\"\"Creates a transaction instruction to freeze an initialized account using the mint's freeze_authority (if set). Example: >>> account, mint, authority, token = PublicKey(1), PublicKey(2), PublicKey(3), PublicKey(4) >>> params = FreezeAccountParams( ... account=account, mint=mint, authority=authority, program_id=token) >>> type(freeze_account(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The freeze-account instruction. \"\"\" return __freeze_or_thaw_instruction ( params , InstructionType . FREEZE_ACCOUNT ) get_associated_token_address ( owner , mint ) Derives the associated token address for the given wallet address and token mint. Returns: Type Description PublicKey The public key of the derived associated token address. Source code in spl/token/instructions.py def get_associated_token_address ( owner : PublicKey , mint : PublicKey ) -> PublicKey : \"\"\"Derives the associated token address for the given wallet address and token mint. Returns: The public key of the derived associated token address. \"\"\" key , _ = PublicKey . find_program_address ( seeds = [ bytes ( owner ), bytes ( TOKEN_PROGRAM_ID ), bytes ( mint )], program_id = ASSOCIATED_TOKEN_PROGRAM_ID ) return key initialize_account ( params ) Creates a transaction instruction to initialize a new account to hold tokens. This instruction requires no signers and MUST be included within the same Transaction as the system program's CreateInstruction that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Examples: >>> account , mint , owner , token = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ), PublicKey ( 4 ) >>> params = InitializeAccountParams ( ... account = account , ... mint = mint , ... owner = owner , ... program_id = token , ... ) >>> type ( initialize_account ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The instruction to initialize the account. Source code in spl/token/instructions.py def initialize_account ( params : InitializeAccountParams ) -> TransactionInstruction : \"\"\"Creates a transaction instruction to initialize a new account to hold tokens. This instruction requires no signers and MUST be included within the same Transaction as the system program's `CreateInstruction` that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Example: >>> account, mint, owner, token = PublicKey(1), PublicKey(2), PublicKey(3), PublicKey(4) >>> params = InitializeAccountParams( ... account=account, ... mint=mint, ... owner=owner, ... program_id=token, ... ) >>> type(initialize_account(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The instruction to initialize the account. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . INITIALIZE_ACCOUNT , args = None )) return TransactionInstruction ( keys = [ AccountMeta ( pubkey = params . account , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . mint , is_signer = False , is_writable = False ), AccountMeta ( pubkey = params . owner , is_signer = False , is_writable = False ), AccountMeta ( pubkey = SYSVAR_RENT_PUBKEY , is_signer = False , is_writable = False ), ], program_id = params . program_id , data = data , ) initialize_mint ( params ) Creates a transaction instruction to initialize a new mint newly. This instruction requires no signers and MUST be included within the same Transaction as the system program's CreateInstruction that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Examples: >>> from spl.token.constants import TOKEN_PROGRAM_ID >>> mint_account , mint_authority , freeze_authority , owner = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ), PublicKey ( 4 ) >>> params = InitializeMintParams ( ... decimals = 6 , ... freeze_authority = freeze_authority , ... mint = mint_account , ... mint_authority = mint_authority , ... program_id = TOKEN_PROGRAM_ID , ... ) >>> type ( initialize_mint ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The instruction to initialize the mint. Source code in spl/token/instructions.py def initialize_mint ( params : InitializeMintParams ) -> TransactionInstruction : \"\"\"Creates a transaction instruction to initialize a new mint newly. This instruction requires no signers and MUST be included within the same Transaction as the system program's `CreateInstruction` that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Example: >>> from spl.token.constants import TOKEN_PROGRAM_ID >>> mint_account, mint_authority, freeze_authority, owner = PublicKey(1), PublicKey(2), PublicKey(3), PublicKey(4) >>> params = InitializeMintParams( ... decimals=6, ... freeze_authority=freeze_authority, ... mint=mint_account, ... mint_authority=mint_authority, ... program_id=TOKEN_PROGRAM_ID, ... ) >>> type(initialize_mint(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The instruction to initialize the mint. \"\"\" # noqa: E501 # pylint: disable=line-too-long freeze_authority , opt = ( params . freeze_authority , 1 ) if params . freeze_authority else ( PublicKey ( 0 ), 0 ) data = INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . INITIALIZE_MINT , args = dict ( decimals = params . decimals , mint_authority = bytes ( params . mint_authority ), freeze_authority_option = opt , freeze_authority = bytes ( freeze_authority ), ), ) ) return TransactionInstruction ( keys = [ AccountMeta ( pubkey = params . mint , is_signer = False , is_writable = True ), AccountMeta ( pubkey = SYSVAR_RENT_PUBKEY , is_signer = False , is_writable = False ), ], program_id = params . program_id , data = data , ) initialize_multisig ( params ) Creates a transaction instruction to initialize a multisignature account with N provided signers. This instruction requires no signers and MUST be included within the same Transaction as the system program's CreateInstruction that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Examples: >>> m = 2 # Two signers >>> signers = [ PublicKey ( i ) for i in range ( m )] >>> multisig_account , token = PublicKey ( 1 ), PublicKey ( 2 ) >>> params = InitializeMultisigParams ( ... m = m , ... multisig = multisig_account , ... signers = signers , ... program_id = token , ... ) >>> type ( initialize_multisig ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The instruction to initialize the multisig. Source code in spl/token/instructions.py def initialize_multisig ( params : InitializeMultisigParams ) -> TransactionInstruction : \"\"\"Creates a transaction instruction to initialize a multisignature account with N provided signers. This instruction requires no signers and MUST be included within the same Transaction as the system program's `CreateInstruction` that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Example: >>> m = 2 # Two signers >>> signers = [PublicKey(i) for i in range(m)] >>> multisig_account, token = PublicKey(1), PublicKey(2) >>> params = InitializeMultisigParams( ... m=m, ... multisig=multisig_account, ... signers=signers, ... program_id=token, ... ) >>> type(initialize_multisig(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The instruction to initialize the multisig. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . INITIALIZE_MULTISIG , args = dict ( m = params . m ))) keys = [ AccountMeta ( pubkey = params . multisig , is_signer = False , is_writable = True ), AccountMeta ( pubkey = SYSVAR_RENT_PUBKEY , is_signer = False , is_writable = False ), ] for signer in params . signers : keys . append ( AccountMeta ( pubkey = signer , is_signer = False , is_writable = False )) return TransactionInstruction ( keys = keys , program_id = params . program_id , data = data ) mint_to ( params ) Creates a transaction instruction to mint new tokens to an account. The native mint does not support minting. Examples: >>> dest , mint , mint_authority , token = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ), PublicKey ( 4 ) >>> params = MintToParams ( ... amount = 123 , ... dest = dest , ... mint = mint , ... mint_authority = mint_authority , ... program_id = token , ... ) >>> type ( mint_to ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The mint-to instruction. Source code in spl/token/instructions.py def mint_to ( params : MintToParams ) -> TransactionInstruction : \"\"\"Creates a transaction instruction to mint new tokens to an account. The native mint does not support minting. Example: >>> dest, mint, mint_authority, token = PublicKey(1), PublicKey(2), PublicKey(3), PublicKey(4) >>> params = MintToParams( ... amount=123, ... dest=dest, ... mint=mint, ... mint_authority=mint_authority, ... program_id=token, ... ) >>> type(mint_to(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The mint-to instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . MINT_TO , args = dict ( amount = params . amount ))) return __mint_to_instruction ( params , data ) mint_to_checked ( params ) This instruction differs from mint_to in that the decimals value is asserted by the caller. Examples: >>> dest , mint , mint_authority , token = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ), PublicKey ( 4 ) >>> params = MintToCheckedParams ( ... amount = 123 , ... decimals = 6 , ... dest = dest , ... mint = mint , ... mint_authority = mint_authority , ... program_id = token , ... ) >>> type ( mint_to_checked ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The mint-to-checked instruction. Source code in spl/token/instructions.py def mint_to_checked ( params : MintToCheckedParams ) -> TransactionInstruction : \"\"\"This instruction differs from `mint_to` in that the decimals value is asserted by the caller. Example: >>> dest, mint, mint_authority, token = PublicKey(1), PublicKey(2), PublicKey(3), PublicKey(4) >>> params = MintToCheckedParams( ... amount=123, ... decimals=6, ... dest=dest, ... mint=mint, ... mint_authority=mint_authority, ... program_id=token, ... ) >>> type(mint_to_checked(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The mint-to-checked instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . MINT_TO2 , args = dict ( amount = params . amount , decimals = params . decimals )) ) return __mint_to_instruction ( params , data ) revoke ( params ) Creates a transaction instruction that revokes delegate authority for a given account. Examples: >>> account , owner , token = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ) >>> params = RevokeParams ( ... account = account , owner = owner , program_id = token ... ) >>> type ( revoke ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The revoke instruction. Source code in spl/token/instructions.py def revoke ( params : RevokeParams ) -> TransactionInstruction : \"\"\"Creates a transaction instruction that revokes delegate authority for a given account. Example: >>> account, owner, token = PublicKey(1), PublicKey(2), PublicKey(3) >>> params = RevokeParams( ... account=account, owner=owner, program_id=token ... ) >>> type(revoke(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The revoke instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . REVOKE , args = None )) keys = [ AccountMeta ( pubkey = params . account , is_signer = False , is_writable = True )] __add_signers ( keys , params . owner , params . signers ) return TransactionInstruction ( keys = keys , program_id = params . program_id , data = data ) set_authority ( params ) Creates a transaction instruction to sets a new authority of a mint or account. Examples: >>> account , current_authority , new_authority , token = ( ... PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ), PublicKey ( 4 ) ... ) >>> params = SetAuthorityParams ( ... account = account , ... authority = AuthorityType . ACCOUNT_OWNER , ... current_authority = current_authority , ... new_authority = new_authority , ... program_id = token , ... ) >>> type ( set_authority ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The set authority instruction. Source code in spl/token/instructions.py def set_authority ( params : SetAuthorityParams ) -> TransactionInstruction : \"\"\"Creates a transaction instruction to sets a new authority of a mint or account. Example: >>> account, current_authority, new_authority, token = ( ... PublicKey(1), PublicKey(2), PublicKey(3), PublicKey(4) ... ) >>> params = SetAuthorityParams( ... account=account, ... authority=AuthorityType.ACCOUNT_OWNER, ... current_authority=current_authority, ... new_authority=new_authority, ... program_id=token, ... ) >>> type(set_authority(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The set authority instruction. \"\"\" new_authority , opt = ( params . new_authority , 1 ) if params . new_authority else ( PublicKey ( 0 ), 0 ) data = INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . SET_AUTHORITY , args = dict ( authority_type = params . authority , new_authority_option = opt , new_authority = bytes ( new_authority )), ) ) keys = [ AccountMeta ( pubkey = params . account , is_signer = False , is_writable = True )] __add_signers ( keys , params . current_authority , params . signers ) return TransactionInstruction ( keys = keys , program_id = params . program_id , data = data ) thaw_account ( params ) Creates a transaction instruction to thaw a frozen account using the Mint's freeze_authority (if set). Examples: >>> account , mint , authority , token = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ), PublicKey ( 4 ) >>> params = ThawAccountParams ( ... account = account , mint = mint , authority = authority , program_id = token ) >>> type ( thaw_account ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The thaw-account instruction. Source code in spl/token/instructions.py def thaw_account ( params : ThawAccountParams ) -> TransactionInstruction : \"\"\"Creates a transaction instruction to thaw a frozen account using the Mint's freeze_authority (if set). Example: >>> account, mint, authority, token = PublicKey(1), PublicKey(2), PublicKey(3), PublicKey(4) >>> params = ThawAccountParams( ... account=account, mint=mint, authority=authority, program_id=token) >>> type(thaw_account(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The thaw-account instruction. \"\"\" return __freeze_or_thaw_instruction ( params , InstructionType . THAW_ACCOUNT ) transfer ( params ) Creates a transaction instruction to transfers tokens from one account to another. Either directly or via a delegate. Examples: >>> dest , owner , source , token = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ), PublicKey ( 4 ) >>> params = TransferParams ( ... amount = 1000 , ... dest = dest , ... owner = owner , ... program_id = token , ... source = source , ... ) >>> type ( transfer ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The transfer instruction. Source code in spl/token/instructions.py def transfer ( params : TransferParams ) -> TransactionInstruction : \"\"\"Creates a transaction instruction to transfers tokens from one account to another. Either directly or via a delegate. Example: >>> dest, owner, source, token = PublicKey(1), PublicKey(2), PublicKey(3), PublicKey(4) >>> params = TransferParams( ... amount=1000, ... dest=dest, ... owner=owner, ... program_id=token, ... source=source, ... ) >>> type(transfer(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The transfer instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . TRANSFER , args = dict ( amount = params . amount ))) keys = [ AccountMeta ( pubkey = params . source , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . dest , is_signer = False , is_writable = True ), ] __add_signers ( keys , params . owner , params . signers ) return TransactionInstruction ( keys = keys , program_id = params . program_id , data = data ) transfer_checked ( params ) This instruction differs from transfer in that the token mint and decimals value is asserted by the caller. Examples: >>> dest , mint , owner , source , token = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ), PublicKey ( 4 ), PublicKey ( 5 ) >>> params = TransferCheckedParams ( ... amount = 1000 , ... decimals = 6 , ... dest = dest , ... mint = mint , ... owner = owner , ... program_id = token , ... source = source , ... ) >>> type ( transfer_checked ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The transfer-checked instruction. Source code in spl/token/instructions.py def transfer_checked ( params : TransferCheckedParams ) -> TransactionInstruction : \"\"\"This instruction differs from `transfer` in that the token mint and decimals value is asserted by the caller. Example: >>> dest, mint, owner, source, token = PublicKey(1), PublicKey(2), PublicKey(3), PublicKey(4), PublicKey(5) >>> params = TransferCheckedParams( ... amount=1000, ... decimals=6, ... dest=dest, ... mint=mint, ... owner=owner, ... program_id=token, ... source=source, ... ) >>> type(transfer_checked(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The transfer-checked instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . TRANSFER2 , args = dict ( amount = params . amount , decimals = params . decimals )) ) keys = [ AccountMeta ( pubkey = params . source , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . mint , is_signer = False , is_writable = False ), AccountMeta ( pubkey = params . dest , is_signer = False , is_writable = True ), ] __add_signers ( keys , params . owner , params . signers ) return TransactionInstruction ( keys = keys , program_id = params . program_id , data = data )","title":"Instructions"},{"location":"spl/token/instructions/#instructions","text":"","title":"Instructions"},{"location":"spl/token/instructions/#spl.token.instructions","text":"SPL token instructions.","title":"instructions"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams","text":"ApproveChecked token transaction params. Source code in spl/token/instructions.py class ApproveCheckedParams ( NamedTuple ): \"\"\"ApproveChecked token transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" source : PublicKey \"\"\"Source account.\"\"\" mint : PublicKey \"\"\"Public key of the minter account.\"\"\" delegate : PublicKey \"\"\"Delegate account authorized to perform a transfer of tokens from the source account.\"\"\" owner : PublicKey \"\"\"Owner of the source account.\"\"\" amount : int \"\"\"Maximum number of tokens the delegate may transfer.\"\"\" decimals : int \"\"\"Amount decimals.\"\"\" signers : List [ PublicKey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\"","title":"ApproveCheckedParams"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams.amount","text":"Maximum number of tokens the delegate may transfer.","title":"amount"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams.decimals","text":"Amount decimals.","title":"decimals"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams.delegate","text":"Delegate account authorized to perform a transfer of tokens from the source account.","title":"delegate"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams.owner","text":"Owner of the source account.","title":"owner"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams.signers","text":"Signing accounts if owner is a multiSig.","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams.source","text":"Source account.","title":"source"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveParams","text":"Approve token transaction params. Source code in spl/token/instructions.py class ApproveParams ( NamedTuple ): \"\"\"Approve token transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" source : PublicKey \"\"\"Source account.\"\"\" delegate : PublicKey \"\"\"Delegate account authorized to perform a transfer of tokens from the source account.\"\"\" owner : PublicKey \"\"\"Owner of the source account.\"\"\" amount : int \"\"\"Maximum number of tokens the delegate may transfer.\"\"\" signers : List [ PublicKey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\"","title":"ApproveParams"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveParams.amount","text":"Maximum number of tokens the delegate may transfer.","title":"amount"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveParams.delegate","text":"Delegate account authorized to perform a transfer of tokens from the source account.","title":"delegate"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveParams.owner","text":"Owner of the source account.","title":"owner"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveParams.signers","text":"Signing accounts if owner is a multiSig.","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveParams.source","text":"Source account.","title":"source"},{"location":"spl/token/instructions/#spl.token.instructions.AuthorityType","text":"Specifies the authority type for SetAuthority instructions. Source code in spl/token/instructions.py class AuthorityType ( IntEnum ): \"\"\"Specifies the authority type for SetAuthority instructions.\"\"\" MINT_TOKENS = 0 \"\"\"\"Authority to mint new tokens.\"\"\" FREEZE_ACCOUNT = 1 \"\"\"Authority to freeze any account associated with the Mint.\"\"\" ACCOUNT_OWNER = 2 \"\"\"Owner of a given token account.\"\"\" CLOSE_ACCOUNT = 3 \"\"\"Authority to close a token account.\"\"\"","title":"AuthorityType"},{"location":"spl/token/instructions/#spl.token.instructions.AuthorityType.ACCOUNT_OWNER","text":"Owner of a given token account.","title":"ACCOUNT_OWNER"},{"location":"spl/token/instructions/#spl.token.instructions.AuthorityType.CLOSE_ACCOUNT","text":"Authority to close a token account.","title":"CLOSE_ACCOUNT"},{"location":"spl/token/instructions/#spl.token.instructions.AuthorityType.FREEZE_ACCOUNT","text":"Authority to freeze any account associated with the Mint.","title":"FREEZE_ACCOUNT"},{"location":"spl/token/instructions/#spl.token.instructions.AuthorityType.MINT_TOKENS","text":"\"Authority to mint new tokens.","title":"MINT_TOKENS"},{"location":"spl/token/instructions/#spl.token.instructions.BurnCheckedParams","text":"BurnChecked token transaction params. Source code in spl/token/instructions.py class BurnCheckedParams ( NamedTuple ): \"\"\"BurnChecked token transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" mint : PublicKey \"\"\"Public key of the minter account.\"\"\" account : PublicKey \"\"\"Account to burn tokens from.\"\"\" owner : PublicKey \"\"\"Owner of the account.\"\"\" amount : int \"\"\"Amount to burn.\"\"\" decimals : int \"\"\"Amount decimals.\"\"\" signers : List [ PublicKey ] = [] \"\"\"Signing accounts if `owner` is a multiSig\"\"\"","title":"BurnCheckedParams"},{"location":"spl/token/instructions/#spl.token.instructions.BurnCheckedParams.account","text":"Account to burn tokens from.","title":"account"},{"location":"spl/token/instructions/#spl.token.instructions.BurnCheckedParams.amount","text":"Amount to burn.","title":"amount"},{"location":"spl/token/instructions/#spl.token.instructions.BurnCheckedParams.decimals","text":"Amount decimals.","title":"decimals"},{"location":"spl/token/instructions/#spl.token.instructions.BurnCheckedParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.BurnCheckedParams.owner","text":"Owner of the account.","title":"owner"},{"location":"spl/token/instructions/#spl.token.instructions.BurnCheckedParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.BurnCheckedParams.signers","text":"Signing accounts if owner is a multiSig","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.BurnParams","text":"Burn token transaction params. Source code in spl/token/instructions.py class BurnParams ( NamedTuple ): \"\"\"Burn token transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" account : PublicKey \"\"\"Account to burn tokens from.\"\"\" mint : PublicKey \"\"\"Public key of the minter account.\"\"\" owner : PublicKey \"\"\"Owner of the account.\"\"\" amount : int \"\"\"Amount to burn.\"\"\" signers : List [ PublicKey ] = [] \"\"\"Signing accounts if `owner` is a multiSig\"\"\"","title":"BurnParams"},{"location":"spl/token/instructions/#spl.token.instructions.BurnParams.account","text":"Account to burn tokens from.","title":"account"},{"location":"spl/token/instructions/#spl.token.instructions.BurnParams.amount","text":"Amount to burn.","title":"amount"},{"location":"spl/token/instructions/#spl.token.instructions.BurnParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.BurnParams.owner","text":"Owner of the account.","title":"owner"},{"location":"spl/token/instructions/#spl.token.instructions.BurnParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.BurnParams.signers","text":"Signing accounts if owner is a multiSig","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.CloseAccountParams","text":"Close token account transaction params. Source code in spl/token/instructions.py class CloseAccountParams ( NamedTuple ): \"\"\"Close token account transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" account : PublicKey \"\"\"Address of account to close.\"\"\" dest : PublicKey \"\"\"Address of account to receive the remaining balance of the closed account.\"\"\" owner : PublicKey \"\"\"Owner of the account.\"\"\" signers : List [ PublicKey ] = [] \"\"\"Signing accounts if `owner` is a multiSig\"\"\"","title":"CloseAccountParams"},{"location":"spl/token/instructions/#spl.token.instructions.CloseAccountParams.account","text":"Address of account to close.","title":"account"},{"location":"spl/token/instructions/#spl.token.instructions.CloseAccountParams.dest","text":"Address of account to receive the remaining balance of the closed account.","title":"dest"},{"location":"spl/token/instructions/#spl.token.instructions.CloseAccountParams.owner","text":"Owner of the account.","title":"owner"},{"location":"spl/token/instructions/#spl.token.instructions.CloseAccountParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.CloseAccountParams.signers","text":"Signing accounts if owner is a multiSig","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.FreezeAccountParams","text":"Freeze token account transaction params. Source code in spl/token/instructions.py class FreezeAccountParams ( NamedTuple ): \"\"\"Freeze token account transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" account : PublicKey \"\"\"Account to freeze.\"\"\" mint : PublicKey \"\"\"Public key of the minter account.\"\"\" authority : PublicKey \"\"\"Mint freeze authority\"\"\" multi_signers : List [ PublicKey ] = [] \"\"\"Signing accounts if `authority` is a multiSig\"\"\"","title":"FreezeAccountParams"},{"location":"spl/token/instructions/#spl.token.instructions.FreezeAccountParams.account","text":"Account to freeze.","title":"account"},{"location":"spl/token/instructions/#spl.token.instructions.FreezeAccountParams.authority","text":"Mint freeze authority","title":"authority"},{"location":"spl/token/instructions/#spl.token.instructions.FreezeAccountParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.FreezeAccountParams.multi_signers","text":"Signing accounts if authority is a multiSig","title":"multi_signers"},{"location":"spl/token/instructions/#spl.token.instructions.FreezeAccountParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeAccountParams","text":"Initialize token account transaction params. Source code in spl/token/instructions.py class InitializeAccountParams ( NamedTuple ): \"\"\"Initialize token account transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" account : PublicKey \"\"\"Public key of the new account.\"\"\" mint : PublicKey \"\"\"Public key of the minter account.\"\"\" owner : PublicKey \"\"\"Owner of the new account.\"\"\"","title":"InitializeAccountParams"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeAccountParams.account","text":"Public key of the new account.","title":"account"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeAccountParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeAccountParams.owner","text":"Owner of the new account.","title":"owner"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeAccountParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMintParams","text":"Initialize token mint transaction params. Source code in spl/token/instructions.py class InitializeMintParams ( NamedTuple ): \"\"\"Initialize token mint transaction params.\"\"\" decimals : int \"\"\"Number of base 10 digits to the right of the decimal place.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" mint : PublicKey \"\"\"Public key of the minter account.\"\"\" mint_authority : PublicKey \"\"\"The authority/multisignature to mint tokens.\"\"\" freeze_authority : Optional [ PublicKey ] = None \"\"\"The freeze authority/multisignature of the mint.\"\"\"","title":"InitializeMintParams"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMintParams.decimals","text":"Number of base 10 digits to the right of the decimal place.","title":"decimals"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMintParams.freeze_authority","text":"The freeze authority/multisignature of the mint.","title":"freeze_authority"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMintParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMintParams.mint_authority","text":"The authority/multisignature to mint tokens.","title":"mint_authority"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMintParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMultisigParams","text":"Initialize multisig token account transaction params. Source code in spl/token/instructions.py class InitializeMultisigParams ( NamedTuple ): \"\"\"Initialize multisig token account transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" multisig : PublicKey \"\"\"New multisig account address.\"\"\" m : int \"\"\"The number of signers (M) required to validate this multisignature account.\"\"\" signers : List [ PublicKey ] = [] \"\"\"Addresses of multisig signers.\"\"\"","title":"InitializeMultisigParams"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMultisigParams.m","text":"The number of signers (M) required to validate this multisignature account.","title":"m"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMultisigParams.multisig","text":"New multisig account address.","title":"multisig"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMultisigParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMultisigParams.signers","text":"Addresses of multisig signers.","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.MintToCheckedParams","text":"MintToChecked token transaction params. Source code in spl/token/instructions.py class MintToCheckedParams ( NamedTuple ): \"\"\"MintToChecked token transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" mint : PublicKey \"\"\"Public key of the minter account.\"\"\" dest : PublicKey \"\"\"Public key of the account to mint to.\"\"\" mint_authority : PublicKey \"\"\"The mint authority.\"\"\" amount : int \"\"\"Amount to mint.\"\"\" decimals : int \"\"\"Amount decimals.\"\"\" signers : List [ PublicKey ] = [] \"\"\"Signing accounts if `mint_authority` is a multiSig.\"\"\"","title":"MintToCheckedParams"},{"location":"spl/token/instructions/#spl.token.instructions.MintToCheckedParams.amount","text":"Amount to mint.","title":"amount"},{"location":"spl/token/instructions/#spl.token.instructions.MintToCheckedParams.decimals","text":"Amount decimals.","title":"decimals"},{"location":"spl/token/instructions/#spl.token.instructions.MintToCheckedParams.dest","text":"Public key of the account to mint to.","title":"dest"},{"location":"spl/token/instructions/#spl.token.instructions.MintToCheckedParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.MintToCheckedParams.mint_authority","text":"The mint authority.","title":"mint_authority"},{"location":"spl/token/instructions/#spl.token.instructions.MintToCheckedParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.MintToCheckedParams.signers","text":"Signing accounts if mint_authority is a multiSig.","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.MintToParams","text":"Mint token transaction params. Source code in spl/token/instructions.py class MintToParams ( NamedTuple ): \"\"\"Mint token transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" mint : PublicKey \"\"\"Public key of the minter account.\"\"\" dest : PublicKey \"\"\"Public key of the account to mint to.\"\"\" mint_authority : PublicKey \"\"\"The mint authority.\"\"\" amount : int \"\"\"Amount to mint.\"\"\" signers : List [ PublicKey ] = [] \"\"\"Signing accounts if `mint_authority` is a multiSig.\"\"\"","title":"MintToParams"},{"location":"spl/token/instructions/#spl.token.instructions.MintToParams.amount","text":"Amount to mint.","title":"amount"},{"location":"spl/token/instructions/#spl.token.instructions.MintToParams.dest","text":"Public key of the account to mint to.","title":"dest"},{"location":"spl/token/instructions/#spl.token.instructions.MintToParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.MintToParams.mint_authority","text":"The mint authority.","title":"mint_authority"},{"location":"spl/token/instructions/#spl.token.instructions.MintToParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.MintToParams.signers","text":"Signing accounts if mint_authority is a multiSig.","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.RevokeParams","text":"Revoke token transaction params. Source code in spl/token/instructions.py class RevokeParams ( NamedTuple ): \"\"\"Revoke token transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" account : PublicKey \"\"\"Source account for which transfer authority is being revoked.\"\"\" owner : PublicKey \"\"\"Owner of the source account.\"\"\" signers : List [ PublicKey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\"","title":"RevokeParams"},{"location":"spl/token/instructions/#spl.token.instructions.RevokeParams.account","text":"Source account for which transfer authority is being revoked.","title":"account"},{"location":"spl/token/instructions/#spl.token.instructions.RevokeParams.owner","text":"Owner of the source account.","title":"owner"},{"location":"spl/token/instructions/#spl.token.instructions.RevokeParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.RevokeParams.signers","text":"Signing accounts if owner is a multiSig.","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.SetAuthorityParams","text":"Set token authority transaction params. Source code in spl/token/instructions.py class SetAuthorityParams ( NamedTuple ): \"\"\"Set token authority transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" account : PublicKey \"\"\"Public key of the token account.\"\"\" authority : AuthorityType \"\"\"The type of authority to update.\"\"\" current_authority : PublicKey \"\"\"Current authority of the specified type.\"\"\" signers : List [ PublicKey ] = [] \"\"\"Signing accounts if `current_authority` is a multiSig.\"\"\" new_authority : Optional [ PublicKey ] = None \"\"\"New authority of the account.\"\"\"","title":"SetAuthorityParams"},{"location":"spl/token/instructions/#spl.token.instructions.SetAuthorityParams.account","text":"Public key of the token account.","title":"account"},{"location":"spl/token/instructions/#spl.token.instructions.SetAuthorityParams.authority","text":"The type of authority to update.","title":"authority"},{"location":"spl/token/instructions/#spl.token.instructions.SetAuthorityParams.current_authority","text":"Current authority of the specified type.","title":"current_authority"},{"location":"spl/token/instructions/#spl.token.instructions.SetAuthorityParams.new_authority","text":"New authority of the account.","title":"new_authority"},{"location":"spl/token/instructions/#spl.token.instructions.SetAuthorityParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.SetAuthorityParams.signers","text":"Signing accounts if current_authority is a multiSig.","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.ThawAccountParams","text":"Thaw token account transaction params. Source code in spl/token/instructions.py class ThawAccountParams ( NamedTuple ): \"\"\"Thaw token account transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" account : PublicKey \"\"\"Account to thaw.\"\"\" mint : PublicKey \"\"\"Public key of the minter account.\"\"\" authority : PublicKey \"\"\"Mint freeze authority\"\"\" multi_signers : List [ PublicKey ] = [] \"\"\"Signing accounts if `authority` is a multiSig\"\"\"","title":"ThawAccountParams"},{"location":"spl/token/instructions/#spl.token.instructions.ThawAccountParams.account","text":"Account to thaw.","title":"account"},{"location":"spl/token/instructions/#spl.token.instructions.ThawAccountParams.authority","text":"Mint freeze authority","title":"authority"},{"location":"spl/token/instructions/#spl.token.instructions.ThawAccountParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.ThawAccountParams.multi_signers","text":"Signing accounts if authority is a multiSig","title":"multi_signers"},{"location":"spl/token/instructions/#spl.token.instructions.ThawAccountParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams","text":"TransferChecked token transaction params. Source code in spl/token/instructions.py class TransferCheckedParams ( NamedTuple ): \"\"\"TransferChecked token transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" source : PublicKey \"\"\"Source account.\"\"\" mint : PublicKey \"\"\"Public key of the minter account.\"\"\" dest : PublicKey \"\"\"Destination account.\"\"\" owner : PublicKey \"\"\"Owner of the source account.\"\"\" amount : int \"\"\"Number of tokens to transfer.\"\"\" decimals : int \"\"\"Amount decimals.\"\"\" signers : List [ PublicKey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\"","title":"TransferCheckedParams"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams.amount","text":"Number of tokens to transfer.","title":"amount"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams.decimals","text":"Amount decimals.","title":"decimals"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams.dest","text":"Destination account.","title":"dest"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams.owner","text":"Owner of the source account.","title":"owner"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams.signers","text":"Signing accounts if owner is a multiSig.","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams.source","text":"Source account.","title":"source"},{"location":"spl/token/instructions/#spl.token.instructions.TransferParams","text":"Transfer token transaction params. Source code in spl/token/instructions.py class TransferParams ( NamedTuple ): \"\"\"Transfer token transaction params.\"\"\" program_id : PublicKey \"\"\"SPL Token program account.\"\"\" source : PublicKey \"\"\"Source account.\"\"\" dest : PublicKey \"\"\"Destination account.\"\"\" owner : PublicKey \"\"\"Owner of the source account.\"\"\" amount : int \"\"\"Number of tokens to transfer.\"\"\" signers : List [ PublicKey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\"","title":"TransferParams"},{"location":"spl/token/instructions/#spl.token.instructions.TransferParams.amount","text":"Number of tokens to transfer.","title":"amount"},{"location":"spl/token/instructions/#spl.token.instructions.TransferParams.dest","text":"Destination account.","title":"dest"},{"location":"spl/token/instructions/#spl.token.instructions.TransferParams.owner","text":"Owner of the source account.","title":"owner"},{"location":"spl/token/instructions/#spl.token.instructions.TransferParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.TransferParams.signers","text":"Signing accounts if owner is a multiSig.","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.TransferParams.source","text":"Source account.","title":"source"},{"location":"spl/token/instructions/#spl.token.instructions.approve","text":"Creates a transaction instruction to approve a delegate. Examples: >>> delegate , owner , source , token = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ), PublicKey ( 4 ) >>> params = ApproveParams ( ... amount = 123 , ... delegate = delegate , ... owner = owner , ... program_id = token , ... source = source ... ) >>> type ( approve ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The approve instruction. Source code in spl/token/instructions.py def approve ( params : ApproveParams ) -> TransactionInstruction : \"\"\"Creates a transaction instruction to approve a delegate. Example: >>> delegate, owner, source, token = PublicKey(1), PublicKey(2), PublicKey(3), PublicKey(4) >>> params = ApproveParams( ... amount=123, ... delegate=delegate, ... owner=owner, ... program_id=token, ... source=source ... ) >>> type(approve(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The approve instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . APPROVE , args = dict ( amount = params . amount ))) keys = [ AccountMeta ( pubkey = params . source , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . delegate , is_signer = False , is_writable = False ), ] __add_signers ( keys , params . owner , params . signers ) return TransactionInstruction ( keys = keys , program_id = params . program_id , data = data )","title":"approve()"},{"location":"spl/token/instructions/#spl.token.instructions.approve_checked","text":"This instruction differs from approve in that the token mint and decimals value is asserted by the caller. Examples: >>> delegate , mint , owner , source , token = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ), PublicKey ( 4 ), PublicKey ( 5 ) >>> params = ApproveCheckedParams ( ... amount = 1000 , ... decimals = 6 , ... delegate = delegate , ... mint = mint , ... owner = owner , ... program_id = token , ... source = source , ... ) >>> type ( approve_checked ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The approve-checked instruction. Source code in spl/token/instructions.py def approve_checked ( params : ApproveCheckedParams ) -> TransactionInstruction : \"\"\"This instruction differs from `approve` in that the token mint and decimals value is asserted by the caller. Example: >>> delegate, mint, owner, source, token = PublicKey(1), PublicKey(2), PublicKey(3), PublicKey(4), PublicKey(5) >>> params = ApproveCheckedParams( ... amount=1000, ... decimals=6, ... delegate=delegate, ... mint=mint, ... owner=owner, ... program_id=token, ... source=source, ... ) >>> type(approve_checked(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The approve-checked instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . APPROVE2 , args = dict ( amount = params . amount , decimals = params . decimals )) ) keys = [ AccountMeta ( pubkey = params . source , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . mint , is_signer = False , is_writable = False ), AccountMeta ( pubkey = params . delegate , is_signer = False , is_writable = False ), ] __add_signers ( keys , params . owner , params . signers ) return TransactionInstruction ( keys = keys , program_id = params . program_id , data = data )","title":"approve_checked()"},{"location":"spl/token/instructions/#spl.token.instructions.burn","text":"Creates a transaction instruction to burns tokens by removing them from an account. Examples: >>> account , mint , owner , token = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ), PublicKey ( 4 ) >>> params = BurnParams ( ... amount = 123 , account = account , mint = mint , owner = owner , program_id = token , ... ) >>> type ( burn ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The burn instruction. Source code in spl/token/instructions.py def burn ( params : BurnParams ) -> TransactionInstruction : \"\"\"Creates a transaction instruction to burns tokens by removing them from an account. Example: >>> account, mint, owner, token = PublicKey(1), PublicKey(2), PublicKey(3), PublicKey(4) >>> params = BurnParams( ... amount=123, account=account, mint=mint, owner=owner, program_id=token, ... ) >>> type(burn(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The burn instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . BURN , args = dict ( amount = params . amount ))) return __burn_instruction ( params , data )","title":"burn()"},{"location":"spl/token/instructions/#spl.token.instructions.burn_checked","text":"This instruction differs from burn in that the decimals value is asserted by the caller. Examples: >>> account , mint , owner , token = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ), PublicKey ( 4 ) >>> params = BurnCheckedParams ( ... amount = 123 , account = account , decimals = 6 , mint = mint , owner = owner , program_id = token , ... ) >>> type ( burn_checked ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The burn-checked instruction. Source code in spl/token/instructions.py def burn_checked ( params : BurnCheckedParams ) -> TransactionInstruction : \"\"\"This instruction differs from `burn` in that the decimals value is asserted by the caller. Example: >>> account, mint, owner, token = PublicKey(1), PublicKey(2), PublicKey(3), PublicKey(4) >>> params = BurnCheckedParams( ... amount=123, account=account, decimals=6, mint=mint, owner=owner, program_id=token, ... ) >>> type(burn_checked(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The burn-checked instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . BURN2 , args = dict ( amount = params . amount , decimals = params . decimals )) ) return __burn_instruction ( params , data )","title":"burn_checked()"},{"location":"spl/token/instructions/#spl.token.instructions.close_account","text":"Creates a transaction instruction to close an account by transferring all its SOL to the destination account. Non-native accounts may only be closed if its token amount is zero. Examples: >>> account , dest , owner , token = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ), PublicKey ( 4 ) >>> params = CloseAccountParams ( ... account = account , dest = dest , owner = owner , program_id = token ) >>> type ( close_account ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The close-account instruction. Source code in spl/token/instructions.py def close_account ( params : CloseAccountParams ) -> TransactionInstruction : \"\"\"Creates a transaction instruction to close an account by transferring all its SOL to the destination account. Non-native accounts may only be closed if its token amount is zero. Example: >>> account, dest, owner, token = PublicKey(1), PublicKey(2), PublicKey(3), PublicKey(4) >>> params = CloseAccountParams( ... account=account, dest=dest, owner=owner, program_id=token) >>> type(close_account(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The close-account instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . CLOSE_ACCOUNT , args = None )) keys = [ AccountMeta ( pubkey = params . account , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . dest , is_signer = False , is_writable = True ), ] __add_signers ( keys , params . owner , params . signers ) return TransactionInstruction ( keys = keys , program_id = params . program_id , data = data )","title":"close_account()"},{"location":"spl/token/instructions/#spl.token.instructions.create_associated_token_account","text":"Creates a transaction instruction to create an associated token account. Returns: Type Description TransactionInstruction The instruction to create the associated token account. Source code in spl/token/instructions.py def create_associated_token_account ( payer : PublicKey , owner : PublicKey , mint : PublicKey ) -> TransactionInstruction : \"\"\"Creates a transaction instruction to create an associated token account. Returns: The instruction to create the associated token account. \"\"\" associated_token_address = get_associated_token_address ( owner , mint ) return TransactionInstruction ( keys = [ AccountMeta ( pubkey = payer , is_signer = True , is_writable = True ), AccountMeta ( pubkey = associated_token_address , is_signer = False , is_writable = True ), AccountMeta ( pubkey = owner , is_signer = False , is_writable = False ), AccountMeta ( pubkey = mint , is_signer = False , is_writable = False ), AccountMeta ( pubkey = SYS_PROGRAM_ID , is_signer = False , is_writable = False ), AccountMeta ( pubkey = TOKEN_PROGRAM_ID , is_signer = False , is_writable = False ), AccountMeta ( pubkey = SYSVAR_RENT_PUBKEY , is_signer = False , is_writable = False ), ], program_id = ASSOCIATED_TOKEN_PROGRAM_ID , )","title":"create_associated_token_account()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_approve","text":"Decode a approve token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description ApproveParams The decoded instruction. Source code in spl/token/instructions.py def decode_approve ( instruction : TransactionInstruction ) -> ApproveParams : \"\"\"Decode a approve token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . APPROVE ) return ApproveParams ( program_id = instruction . program_id , source = instruction . keys [ 0 ] . pubkey , delegate = instruction . keys [ 1 ] . pubkey , owner = instruction . keys [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . keys [ 3 :]], amount = parsed_data . args . amount , )","title":"decode_approve()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_approve_checked","text":"Decode a approve_checked token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description ApproveCheckedParams The decoded instruction. Source code in spl/token/instructions.py def decode_approve_checked ( instruction : TransactionInstruction ) -> ApproveCheckedParams : \"\"\"Decode a approve_checked token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 4 , InstructionType . APPROVE2 ) return ApproveCheckedParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , decimals = parsed_data . args . decimals , source = instruction . keys [ 0 ] . pubkey , mint = instruction . keys [ 1 ] . pubkey , delegate = instruction . keys [ 2 ] . pubkey , owner = instruction . keys [ 3 ] . pubkey , signers = [ signer . pubkey for signer in instruction . keys [ 4 :]], )","title":"decode_approve_checked()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_burn","text":"Decode a burn token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description BurnParams The decoded instruction. Source code in spl/token/instructions.py def decode_burn ( instruction : TransactionInstruction ) -> BurnParams : \"\"\"Decode a burn token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . BURN ) return BurnParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , account = instruction . keys [ 0 ] . pubkey , mint = instruction . keys [ 1 ] . pubkey , owner = instruction . keys [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . keys [ 3 :]], )","title":"decode_burn()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_burn_checked","text":"Decode a burn_checked token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description BurnCheckedParams The decoded instruction. Source code in spl/token/instructions.py def decode_burn_checked ( instruction : TransactionInstruction ) -> BurnCheckedParams : \"\"\"Decode a burn_checked token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . BURN2 ) return BurnCheckedParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , decimals = parsed_data . args . decimals , account = instruction . keys [ 0 ] . pubkey , mint = instruction . keys [ 1 ] . pubkey , owner = instruction . keys [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . keys [ 3 :]], )","title":"decode_burn_checked()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_close_account","text":"Decode a close account token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description CloseAccountParams The decoded instruction. Source code in spl/token/instructions.py def decode_close_account ( instruction : TransactionInstruction ) -> CloseAccountParams : \"\"\"Decode a close account token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 3 , InstructionType . CLOSE_ACCOUNT ) return CloseAccountParams ( program_id = instruction . program_id , account = instruction . keys [ 0 ] . pubkey , dest = instruction . keys [ 1 ] . pubkey , owner = instruction . keys [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . keys [ 3 :]], )","title":"decode_close_account()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_freeze_account","text":"Decode a freeze account token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description FreezeAccountParams The decoded instruction. Source code in spl/token/instructions.py def decode_freeze_account ( instruction : TransactionInstruction ) -> FreezeAccountParams : \"\"\"Decode a freeze account token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 3 , InstructionType . FREEZE_ACCOUNT ) return FreezeAccountParams ( program_id = instruction . program_id , account = instruction . keys [ 0 ] . pubkey , mint = instruction . keys [ 1 ] . pubkey , authority = instruction . keys [ 2 ] . pubkey , multi_signers = [ signer . pubkey for signer in instruction . keys [ 3 :]], )","title":"decode_freeze_account()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_initialize_account","text":"Decode an initialize account token instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description InitializeAccountParams The decoded instruction. Source code in spl/token/instructions.py def decode_initialize_account ( instruction : TransactionInstruction ) -> InitializeAccountParams : \"\"\"Decode an initialize account token instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 4 , InstructionType . INITIALIZE_ACCOUNT ) return InitializeAccountParams ( program_id = instruction . program_id , account = instruction . keys [ 0 ] . pubkey , mint = instruction . keys [ 1 ] . pubkey , owner = instruction . keys [ 2 ] . pubkey , )","title":"decode_initialize_account()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_initialize_mint","text":"Decode an initialize mint token instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description InitializeMintParams The decoded instruction. Source code in spl/token/instructions.py def decode_initialize_mint ( instruction : TransactionInstruction ) -> InitializeMintParams : \"\"\"Decode an initialize mint token instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 2 , InstructionType . INITIALIZE_MINT ) return InitializeMintParams ( decimals = parsed_data . args . decimals , program_id = instruction . program_id , mint = instruction . keys [ 0 ] . pubkey , mint_authority = PublicKey ( parsed_data . args . mint_authority ), freeze_authority = PublicKey ( parsed_data . args . freeze_authority ) if parsed_data . args . freeze_authority_option else None , )","title":"decode_initialize_mint()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_initialize_multisig","text":"Decode an initialize multisig account token instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description InitializeMultisigParams The decoded instruction. Source code in spl/token/instructions.py def decode_initialize_multisig ( instruction : TransactionInstruction ) -> InitializeMultisigParams : \"\"\"Decode an initialize multisig account token instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 2 , InstructionType . INITIALIZE_MULTISIG ) num_signers = parsed_data . args . m validate_instruction_keys ( instruction , 2 + num_signers ) return InitializeMultisigParams ( program_id = instruction . program_id , multisig = instruction . keys [ 0 ] . pubkey , signers = [ signer . pubkey for signer in instruction . keys [ - num_signers :]], m = num_signers , )","title":"decode_initialize_multisig()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_mint_to","text":"Decode a mint to token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description MintToParams The decoded instruction. Source code in spl/token/instructions.py def decode_mint_to ( instruction : TransactionInstruction ) -> MintToParams : \"\"\"Decode a mint to token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . MINT_TO ) return MintToParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , mint = instruction . keys [ 0 ] . pubkey , dest = instruction . keys [ 1 ] . pubkey , mint_authority = instruction . keys [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . keys [ 3 :]], )","title":"decode_mint_to()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_mint_to_checked","text":"Decode a mintTo2 token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description MintToCheckedParams The decoded instruction. Source code in spl/token/instructions.py def decode_mint_to_checked ( instruction : TransactionInstruction ) -> MintToCheckedParams : \"\"\"Decode a mintTo2 token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . MINT_TO2 ) return MintToCheckedParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , decimals = parsed_data . args . decimals , mint = instruction . keys [ 0 ] . pubkey , dest = instruction . keys [ 1 ] . pubkey , mint_authority = instruction . keys [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . keys [ 3 :]], )","title":"decode_mint_to_checked()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_revoke","text":"Decode a revoke token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description RevokeParams The decoded instruction. Source code in spl/token/instructions.py def decode_revoke ( instruction : TransactionInstruction ) -> RevokeParams : \"\"\"Decode a revoke token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 2 , InstructionType . REVOKE ) return RevokeParams ( program_id = instruction . program_id , account = instruction . keys [ 0 ] . pubkey , owner = instruction . keys [ 1 ] . pubkey , signers = [ signer . pubkey for signer in instruction . keys [ 2 :]], )","title":"decode_revoke()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_set_authority","text":"Decode a set authority token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description SetAuthorityParams The decoded instruction. Source code in spl/token/instructions.py def decode_set_authority ( instruction : TransactionInstruction ) -> SetAuthorityParams : \"\"\"Decode a set authority token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 2 , InstructionType . SET_AUTHORITY ) return SetAuthorityParams ( program_id = instruction . program_id , account = instruction . keys [ 0 ] . pubkey , authority = AuthorityType ( parsed_data . args . authority_type ), new_authority = PublicKey ( parsed_data . args . new_authority ) if parsed_data . args . new_authority_option else None , current_authority = instruction . keys [ 1 ] . pubkey , signers = [ signer . pubkey for signer in instruction . keys [ 2 :]], )","title":"decode_set_authority()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_thaw_account","text":"Decode a thaw account token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description ThawAccountParams The decoded instruction. Source code in spl/token/instructions.py def decode_thaw_account ( instruction : TransactionInstruction ) -> ThawAccountParams : \"\"\"Decode a thaw account token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 3 , InstructionType . THAW_ACCOUNT ) return ThawAccountParams ( program_id = instruction . program_id , account = instruction . keys [ 0 ] . pubkey , mint = instruction . keys [ 1 ] . pubkey , authority = instruction . keys [ 2 ] . pubkey , multi_signers = [ signer . pubkey for signer in instruction . keys [ 3 :]], )","title":"decode_thaw_account()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_transfer","text":"Decode a transfer token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description TransferParams The decoded instruction. Source code in spl/token/instructions.py def decode_transfer ( instruction : TransactionInstruction ) -> TransferParams : \"\"\"Decode a transfer token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . TRANSFER ) return TransferParams ( program_id = instruction . program_id , source = instruction . keys [ 0 ] . pubkey , dest = instruction . keys [ 1 ] . pubkey , owner = instruction . keys [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . keys [ 3 :]], amount = parsed_data . args . amount , )","title":"decode_transfer()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_transfer_checked","text":"Decode a transfer_checked token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction TransactionInstruction The instruction to decode. required Returns: Type Description TransferCheckedParams The decoded instruction. Source code in spl/token/instructions.py def decode_transfer_checked ( instruction : TransactionInstruction ) -> TransferCheckedParams : \"\"\"Decode a transfer_checked token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 4 , InstructionType . TRANSFER2 ) return TransferCheckedParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , decimals = parsed_data . args . decimals , source = instruction . keys [ 0 ] . pubkey , mint = instruction . keys [ 1 ] . pubkey , dest = instruction . keys [ 2 ] . pubkey , owner = instruction . keys [ 3 ] . pubkey , signers = [ signer . pubkey for signer in instruction . keys [ 4 :]], )","title":"decode_transfer_checked()"},{"location":"spl/token/instructions/#spl.token.instructions.freeze_account","text":"Creates a transaction instruction to freeze an initialized account using the mint's freeze_authority (if set). Examples: >>> account , mint , authority , token = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ), PublicKey ( 4 ) >>> params = FreezeAccountParams ( ... account = account , mint = mint , authority = authority , program_id = token ) >>> type ( freeze_account ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The freeze-account instruction. Source code in spl/token/instructions.py def freeze_account ( params : FreezeAccountParams ) -> TransactionInstruction : \"\"\"Creates a transaction instruction to freeze an initialized account using the mint's freeze_authority (if set). Example: >>> account, mint, authority, token = PublicKey(1), PublicKey(2), PublicKey(3), PublicKey(4) >>> params = FreezeAccountParams( ... account=account, mint=mint, authority=authority, program_id=token) >>> type(freeze_account(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The freeze-account instruction. \"\"\" return __freeze_or_thaw_instruction ( params , InstructionType . FREEZE_ACCOUNT )","title":"freeze_account()"},{"location":"spl/token/instructions/#spl.token.instructions.get_associated_token_address","text":"Derives the associated token address for the given wallet address and token mint. Returns: Type Description PublicKey The public key of the derived associated token address. Source code in spl/token/instructions.py def get_associated_token_address ( owner : PublicKey , mint : PublicKey ) -> PublicKey : \"\"\"Derives the associated token address for the given wallet address and token mint. Returns: The public key of the derived associated token address. \"\"\" key , _ = PublicKey . find_program_address ( seeds = [ bytes ( owner ), bytes ( TOKEN_PROGRAM_ID ), bytes ( mint )], program_id = ASSOCIATED_TOKEN_PROGRAM_ID ) return key","title":"get_associated_token_address()"},{"location":"spl/token/instructions/#spl.token.instructions.initialize_account","text":"Creates a transaction instruction to initialize a new account to hold tokens. This instruction requires no signers and MUST be included within the same Transaction as the system program's CreateInstruction that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Examples: >>> account , mint , owner , token = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ), PublicKey ( 4 ) >>> params = InitializeAccountParams ( ... account = account , ... mint = mint , ... owner = owner , ... program_id = token , ... ) >>> type ( initialize_account ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The instruction to initialize the account. Source code in spl/token/instructions.py def initialize_account ( params : InitializeAccountParams ) -> TransactionInstruction : \"\"\"Creates a transaction instruction to initialize a new account to hold tokens. This instruction requires no signers and MUST be included within the same Transaction as the system program's `CreateInstruction` that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Example: >>> account, mint, owner, token = PublicKey(1), PublicKey(2), PublicKey(3), PublicKey(4) >>> params = InitializeAccountParams( ... account=account, ... mint=mint, ... owner=owner, ... program_id=token, ... ) >>> type(initialize_account(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The instruction to initialize the account. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . INITIALIZE_ACCOUNT , args = None )) return TransactionInstruction ( keys = [ AccountMeta ( pubkey = params . account , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . mint , is_signer = False , is_writable = False ), AccountMeta ( pubkey = params . owner , is_signer = False , is_writable = False ), AccountMeta ( pubkey = SYSVAR_RENT_PUBKEY , is_signer = False , is_writable = False ), ], program_id = params . program_id , data = data , )","title":"initialize_account()"},{"location":"spl/token/instructions/#spl.token.instructions.initialize_mint","text":"Creates a transaction instruction to initialize a new mint newly. This instruction requires no signers and MUST be included within the same Transaction as the system program's CreateInstruction that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Examples: >>> from spl.token.constants import TOKEN_PROGRAM_ID >>> mint_account , mint_authority , freeze_authority , owner = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ), PublicKey ( 4 ) >>> params = InitializeMintParams ( ... decimals = 6 , ... freeze_authority = freeze_authority , ... mint = mint_account , ... mint_authority = mint_authority , ... program_id = TOKEN_PROGRAM_ID , ... ) >>> type ( initialize_mint ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The instruction to initialize the mint. Source code in spl/token/instructions.py def initialize_mint ( params : InitializeMintParams ) -> TransactionInstruction : \"\"\"Creates a transaction instruction to initialize a new mint newly. This instruction requires no signers and MUST be included within the same Transaction as the system program's `CreateInstruction` that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Example: >>> from spl.token.constants import TOKEN_PROGRAM_ID >>> mint_account, mint_authority, freeze_authority, owner = PublicKey(1), PublicKey(2), PublicKey(3), PublicKey(4) >>> params = InitializeMintParams( ... decimals=6, ... freeze_authority=freeze_authority, ... mint=mint_account, ... mint_authority=mint_authority, ... program_id=TOKEN_PROGRAM_ID, ... ) >>> type(initialize_mint(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The instruction to initialize the mint. \"\"\" # noqa: E501 # pylint: disable=line-too-long freeze_authority , opt = ( params . freeze_authority , 1 ) if params . freeze_authority else ( PublicKey ( 0 ), 0 ) data = INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . INITIALIZE_MINT , args = dict ( decimals = params . decimals , mint_authority = bytes ( params . mint_authority ), freeze_authority_option = opt , freeze_authority = bytes ( freeze_authority ), ), ) ) return TransactionInstruction ( keys = [ AccountMeta ( pubkey = params . mint , is_signer = False , is_writable = True ), AccountMeta ( pubkey = SYSVAR_RENT_PUBKEY , is_signer = False , is_writable = False ), ], program_id = params . program_id , data = data , )","title":"initialize_mint()"},{"location":"spl/token/instructions/#spl.token.instructions.initialize_multisig","text":"Creates a transaction instruction to initialize a multisignature account with N provided signers. This instruction requires no signers and MUST be included within the same Transaction as the system program's CreateInstruction that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Examples: >>> m = 2 # Two signers >>> signers = [ PublicKey ( i ) for i in range ( m )] >>> multisig_account , token = PublicKey ( 1 ), PublicKey ( 2 ) >>> params = InitializeMultisigParams ( ... m = m , ... multisig = multisig_account , ... signers = signers , ... program_id = token , ... ) >>> type ( initialize_multisig ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The instruction to initialize the multisig. Source code in spl/token/instructions.py def initialize_multisig ( params : InitializeMultisigParams ) -> TransactionInstruction : \"\"\"Creates a transaction instruction to initialize a multisignature account with N provided signers. This instruction requires no signers and MUST be included within the same Transaction as the system program's `CreateInstruction` that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Example: >>> m = 2 # Two signers >>> signers = [PublicKey(i) for i in range(m)] >>> multisig_account, token = PublicKey(1), PublicKey(2) >>> params = InitializeMultisigParams( ... m=m, ... multisig=multisig_account, ... signers=signers, ... program_id=token, ... ) >>> type(initialize_multisig(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The instruction to initialize the multisig. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . INITIALIZE_MULTISIG , args = dict ( m = params . m ))) keys = [ AccountMeta ( pubkey = params . multisig , is_signer = False , is_writable = True ), AccountMeta ( pubkey = SYSVAR_RENT_PUBKEY , is_signer = False , is_writable = False ), ] for signer in params . signers : keys . append ( AccountMeta ( pubkey = signer , is_signer = False , is_writable = False )) return TransactionInstruction ( keys = keys , program_id = params . program_id , data = data )","title":"initialize_multisig()"},{"location":"spl/token/instructions/#spl.token.instructions.mint_to","text":"Creates a transaction instruction to mint new tokens to an account. The native mint does not support minting. Examples: >>> dest , mint , mint_authority , token = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ), PublicKey ( 4 ) >>> params = MintToParams ( ... amount = 123 , ... dest = dest , ... mint = mint , ... mint_authority = mint_authority , ... program_id = token , ... ) >>> type ( mint_to ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The mint-to instruction. Source code in spl/token/instructions.py def mint_to ( params : MintToParams ) -> TransactionInstruction : \"\"\"Creates a transaction instruction to mint new tokens to an account. The native mint does not support minting. Example: >>> dest, mint, mint_authority, token = PublicKey(1), PublicKey(2), PublicKey(3), PublicKey(4) >>> params = MintToParams( ... amount=123, ... dest=dest, ... mint=mint, ... mint_authority=mint_authority, ... program_id=token, ... ) >>> type(mint_to(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The mint-to instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . MINT_TO , args = dict ( amount = params . amount ))) return __mint_to_instruction ( params , data )","title":"mint_to()"},{"location":"spl/token/instructions/#spl.token.instructions.mint_to_checked","text":"This instruction differs from mint_to in that the decimals value is asserted by the caller. Examples: >>> dest , mint , mint_authority , token = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ), PublicKey ( 4 ) >>> params = MintToCheckedParams ( ... amount = 123 , ... decimals = 6 , ... dest = dest , ... mint = mint , ... mint_authority = mint_authority , ... program_id = token , ... ) >>> type ( mint_to_checked ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The mint-to-checked instruction. Source code in spl/token/instructions.py def mint_to_checked ( params : MintToCheckedParams ) -> TransactionInstruction : \"\"\"This instruction differs from `mint_to` in that the decimals value is asserted by the caller. Example: >>> dest, mint, mint_authority, token = PublicKey(1), PublicKey(2), PublicKey(3), PublicKey(4) >>> params = MintToCheckedParams( ... amount=123, ... decimals=6, ... dest=dest, ... mint=mint, ... mint_authority=mint_authority, ... program_id=token, ... ) >>> type(mint_to_checked(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The mint-to-checked instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . MINT_TO2 , args = dict ( amount = params . amount , decimals = params . decimals )) ) return __mint_to_instruction ( params , data )","title":"mint_to_checked()"},{"location":"spl/token/instructions/#spl.token.instructions.revoke","text":"Creates a transaction instruction that revokes delegate authority for a given account. Examples: >>> account , owner , token = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ) >>> params = RevokeParams ( ... account = account , owner = owner , program_id = token ... ) >>> type ( revoke ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The revoke instruction. Source code in spl/token/instructions.py def revoke ( params : RevokeParams ) -> TransactionInstruction : \"\"\"Creates a transaction instruction that revokes delegate authority for a given account. Example: >>> account, owner, token = PublicKey(1), PublicKey(2), PublicKey(3) >>> params = RevokeParams( ... account=account, owner=owner, program_id=token ... ) >>> type(revoke(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The revoke instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . REVOKE , args = None )) keys = [ AccountMeta ( pubkey = params . account , is_signer = False , is_writable = True )] __add_signers ( keys , params . owner , params . signers ) return TransactionInstruction ( keys = keys , program_id = params . program_id , data = data )","title":"revoke()"},{"location":"spl/token/instructions/#spl.token.instructions.set_authority","text":"Creates a transaction instruction to sets a new authority of a mint or account. Examples: >>> account , current_authority , new_authority , token = ( ... PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ), PublicKey ( 4 ) ... ) >>> params = SetAuthorityParams ( ... account = account , ... authority = AuthorityType . ACCOUNT_OWNER , ... current_authority = current_authority , ... new_authority = new_authority , ... program_id = token , ... ) >>> type ( set_authority ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The set authority instruction. Source code in spl/token/instructions.py def set_authority ( params : SetAuthorityParams ) -> TransactionInstruction : \"\"\"Creates a transaction instruction to sets a new authority of a mint or account. Example: >>> account, current_authority, new_authority, token = ( ... PublicKey(1), PublicKey(2), PublicKey(3), PublicKey(4) ... ) >>> params = SetAuthorityParams( ... account=account, ... authority=AuthorityType.ACCOUNT_OWNER, ... current_authority=current_authority, ... new_authority=new_authority, ... program_id=token, ... ) >>> type(set_authority(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The set authority instruction. \"\"\" new_authority , opt = ( params . new_authority , 1 ) if params . new_authority else ( PublicKey ( 0 ), 0 ) data = INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . SET_AUTHORITY , args = dict ( authority_type = params . authority , new_authority_option = opt , new_authority = bytes ( new_authority )), ) ) keys = [ AccountMeta ( pubkey = params . account , is_signer = False , is_writable = True )] __add_signers ( keys , params . current_authority , params . signers ) return TransactionInstruction ( keys = keys , program_id = params . program_id , data = data )","title":"set_authority()"},{"location":"spl/token/instructions/#spl.token.instructions.thaw_account","text":"Creates a transaction instruction to thaw a frozen account using the Mint's freeze_authority (if set). Examples: >>> account , mint , authority , token = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ), PublicKey ( 4 ) >>> params = ThawAccountParams ( ... account = account , mint = mint , authority = authority , program_id = token ) >>> type ( thaw_account ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The thaw-account instruction. Source code in spl/token/instructions.py def thaw_account ( params : ThawAccountParams ) -> TransactionInstruction : \"\"\"Creates a transaction instruction to thaw a frozen account using the Mint's freeze_authority (if set). Example: >>> account, mint, authority, token = PublicKey(1), PublicKey(2), PublicKey(3), PublicKey(4) >>> params = ThawAccountParams( ... account=account, mint=mint, authority=authority, program_id=token) >>> type(thaw_account(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The thaw-account instruction. \"\"\" return __freeze_or_thaw_instruction ( params , InstructionType . THAW_ACCOUNT )","title":"thaw_account()"},{"location":"spl/token/instructions/#spl.token.instructions.transfer","text":"Creates a transaction instruction to transfers tokens from one account to another. Either directly or via a delegate. Examples: >>> dest , owner , source , token = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ), PublicKey ( 4 ) >>> params = TransferParams ( ... amount = 1000 , ... dest = dest , ... owner = owner , ... program_id = token , ... source = source , ... ) >>> type ( transfer ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The transfer instruction. Source code in spl/token/instructions.py def transfer ( params : TransferParams ) -> TransactionInstruction : \"\"\"Creates a transaction instruction to transfers tokens from one account to another. Either directly or via a delegate. Example: >>> dest, owner, source, token = PublicKey(1), PublicKey(2), PublicKey(3), PublicKey(4) >>> params = TransferParams( ... amount=1000, ... dest=dest, ... owner=owner, ... program_id=token, ... source=source, ... ) >>> type(transfer(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The transfer instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . TRANSFER , args = dict ( amount = params . amount ))) keys = [ AccountMeta ( pubkey = params . source , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . dest , is_signer = False , is_writable = True ), ] __add_signers ( keys , params . owner , params . signers ) return TransactionInstruction ( keys = keys , program_id = params . program_id , data = data )","title":"transfer()"},{"location":"spl/token/instructions/#spl.token.instructions.transfer_checked","text":"This instruction differs from transfer in that the token mint and decimals value is asserted by the caller. Examples: >>> dest , mint , owner , source , token = PublicKey ( 1 ), PublicKey ( 2 ), PublicKey ( 3 ), PublicKey ( 4 ), PublicKey ( 5 ) >>> params = TransferCheckedParams ( ... amount = 1000 , ... decimals = 6 , ... dest = dest , ... mint = mint , ... owner = owner , ... program_id = token , ... source = source , ... ) >>> type ( transfer_checked ( params )) < class ' solana . transaction . TransactionInstruction '> Returns: Type Description TransactionInstruction The transfer-checked instruction. Source code in spl/token/instructions.py def transfer_checked ( params : TransferCheckedParams ) -> TransactionInstruction : \"\"\"This instruction differs from `transfer` in that the token mint and decimals value is asserted by the caller. Example: >>> dest, mint, owner, source, token = PublicKey(1), PublicKey(2), PublicKey(3), PublicKey(4), PublicKey(5) >>> params = TransferCheckedParams( ... amount=1000, ... decimals=6, ... dest=dest, ... mint=mint, ... owner=owner, ... program_id=token, ... source=source, ... ) >>> type(transfer_checked(params)) <class 'solana.transaction.TransactionInstruction'> Returns: The transfer-checked instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( dict ( instruction_type = InstructionType . TRANSFER2 , args = dict ( amount = params . amount , decimals = params . decimals )) ) keys = [ AccountMeta ( pubkey = params . source , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . mint , is_signer = False , is_writable = False ), AccountMeta ( pubkey = params . dest , is_signer = False , is_writable = True ), ] __add_signers ( keys , params . owner , params . signers ) return TransactionInstruction ( keys = keys , program_id = params . program_id , data = data )","title":"transfer_checked()"}]}